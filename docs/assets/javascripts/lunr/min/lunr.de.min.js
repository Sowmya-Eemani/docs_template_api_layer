<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a514bfaedc262d6214ee359f796021d4c89b5b710358745117c57e32c8991760d7f200d8b92607d43410c2198a907fedcdea8914bbdf31eb2c7a040ee84a937e53e30f6b8729d03fc55e929c030e4c2a6ae79cc0e63fd24b166a350c82b37b09ffefdcc756686b60408d439b73995d0c784211ef61ceee889a9c3f1732cb5a55e6a92d0b4fc112d7b1b4a4a11c90786c87861eb6565d85e82571d8598efb665b80c64b6180a6669f03b2d064791daa2004a87ce577e697373bf34da7acbeeb7812069f7f3a519ea2be31eef9ce14e24fb25f9c295306c438c032a65baa5606d283c99da3ad6b16d7d2f01877f360e9a01d77c6ec16aa637832d1e13068fad1628a6ded0888f63aada727f0d950c241505cd8e8ec69c44ba17f5b7e576932c7438231ca7093c0e676075e8f6d7ca27f7042850e514a8597d844d0636e50b1479b811b314ad9fbeaec9bc7cf63c757362ab95ed10bd2b0403b155d77900b4cbd073acd55797f3ce91fa225be2ab81bdaafa49e48311b5afccdc2f6f56558a8ae40dd0d3b0da9b38bc502677f1881d598249baa2dea523181df1d424d6903f11493a51ff10c0da8ce583c6bc27f21804e6987c442c3e9242c524125d6271d4dd253f9eca290b2d568926a8c971f11ce747d5828eb267a8b2534d2e9c27fd6385601c0a7e7dbd689d6983250b36ccb26c777256629476d16349e4eb1367415ac7b4c777f18dfa00d3c5c4185df02295f697fc4ff05bb064e03016ff5513243c19f19468d5283939a1184c1f6030a9cb172a54271020ae6209b0f881c6c2510e4668197d60b8e6f8327a88dba28adc3cc4c9acda7dbd656573b395eb3645629983c917ebb1501f4586584da5bd7db3c6db2f669ba22899ca47c33774a5ddad6d585e2f656c7247bd6a3a61ef876765c977c2248437af44dbe99efcdbfa013d5659d6307fd0ac422c216c9909362d6b985396ff9cfa9a5b4a0e07089fde8f772a22f982d8b34f43888aef2982f821ec05f30a254a86ad5f7b35814cea56dfbf9c77a643ad0c920bb7f3d52feec14ea3aea16c31660b63f33bedff3b81ca5eb2a24238d923cb78d6aeff20d68cb9da787d86f223c561df24d93afb0183b2d311c295b7e7c347907c950b0d17a8f6c9516407917d4dd3623ee3a801998c3744c9e08cc53c08b509745c3ccc82d8704913cc0dd4bfd4a9348f194d6ab235cfe2bb8d88ab3c8974fc3e89df23f3ddb7cd2e6207f71e097f410dbe3076770e69f11a4a4eee42eb5ba5540fb56c20d898af2838fd2d8d03330bd77aa736a067aab49407d5aab50271e2bb8b0d36ac6e424c32b124c33e9a3ad60cb7a1f52ea6185a56559ca3ad80a82f42cdd8c7751517e06ca4dc7922168a7e4dc30fe7f8647692f0f28a6c323e42245b4602200240b728915072dac1a69dcd891de7a57ec028ab8040ac89a93d88e16e42cd27b5ab0609fee501a68fb6d999b87924dfc2802070c600cf7021f11a493b64300d62ed8fb504b290c2de73e78c6ba9e587ddb020637c975d6a38dc721f58946aa550f5a4a9b13ac382c5e9ef0870a31f296f0624f592a3362022d74156ac720dca5d01f781df181a0bfcd133e49d304168d5adfd928231f34573a28eff938c8a0c94cf0aa783f6fcfde8afabc937c1acfdc7e0d94063a7b3be5847de9f07d963e46b65c5bb2eb6ff5030e6771dce2ad5f26672d4d16101d264ac80d1c325e59a2bb21e402f9e5a109fd74e00c56a83619916735516237013a31d1df7952b23817312d1007282abeadc9f477b1f32d1eead58c0c194899d01e5b6cf373b11b68cb08facd0ffcf01291fc4cba55711042e7603e658d29d4c115036bbcb12c1047d8c233bb30d60611004ed000b3ac190d0ed1454c68bfde40bc153686c5122bf2767ebbb64ed5283e4ccd7f9c97e1fd93e44b726564c59293366f19f419a7eba21bae37771231ae1108a646efda47b003687b5f4e8dac7d3df147ea51133c8319c8b8f0459bcc0c9c9807a2d2bef14bc9fb682fbfb9d267b6cbda3f54f601463cb91b87934d0f52ff7c715dd1e2ab56e27e32a4d9b0155bf21508d540355e40fdf7508b1a5f4c5a31f05d65f2fe71a7f345de9ed2ec2f0f03890f13cbbd9e5b40fc5bd9cf395b929e7b60ffd115e5053e6f2739b9867d3d7c7d716002291ef4d15164380615f4b9ee35901ef733edfc7a81c27a36471a92ee0824bcd06e9048cdd40a63ddb8ead1f9fb0f063c7bda46c169204fe2259b1e7abd084e1f0815d035751de381de0e16ee377c5541f014bce9d09384f2151d01c1a13071adfa1521dd7f791c1840b030ea048ea616c27644fa5ebd60a69ee683fcc2dcdda387039d9b7628fb0c67012e8fe4857372f1d0c3f582ce3b530dcdc71eac4aa9798fee7892916cd2c6e31accc3b69b72fa6cd4fcf770dd9752225d9aaa450649b120a2678bc433be4153e7a305a8b1cbadf6ad34f94af8eb95594cf5b99257b2a119a37dba1c73b78795997241e3ab0caef9585bec9112368234ad7ba173fbb2fa1b27a94a47f78c85f8fcf03e26361c2b3131eb853b07389ca93ce233e7d3645d9ff61aa9510be4b14a23374d20b5b0720c62b82ce22deca9e0145e41e5e71394412f48038b21aa10fdfc52b6b784232d75ba369cfff15ad35c3b134e22a638850c54c9c002d64c709e5b42c9da4e38a5b513ed9edb9fd753f64521dfca343696d51ab4f79cf67dd23544234c1d3905e812b0e60d40adc2d8992a4c23d82c6b014da2fc1059b7aa78a16b3bdbb0015f67c03b688356d3f574bbac585e2eda30426b37a153d56a62e8500498942e35efa2a89bda95631bee4887da44fd5e3eb010fc9280a097d3f0dd177505a18b1b4a25596e39d437c8a5aa4183c919b1171ba8aff81869db46cc29946e23e8cef0715d6464f5f7986c9ff3f593496e4b510461c9126b41696f83e32a85d42dc48822b94244d030b7660ffec8c3c5754aca05d48692779ee1e3fa274662d7b2bd6144b5ec456c13d48d1b538daf5bfa8214503ab404e7c3aa997fb91e51690f23db2c958ec1a54684885a777fe0906a8443fa2a1127d458f037c02e92b14c1747cfb4c6a4ee06471dbf89165c47afc5acaab271fb7fe5eecdb7cfa1921b15031405afe4cefdb9856336c69af47b07e9d69db0b0684d1c18de3d6e0fe0f3c18b23ebc9de571eab66a8ae2ae6133c4f2583a26cede7ba7a20dae32cfae95bd6c30d274c5d4a4de537a9438ebc9e25374575958eb1d6fd87b7e21f20f3a08dad3456f5ffeffaa2d719ec557ae33a2bf0f77ceaf990e7c789854098ff7df3021d63155d86506a2393f62c813e24ed7fb23378b9bc3fce2675636c14e1aae3164ea565857c4e850b077fbe5ba8be00b93b6d1fe871bba4604cd0ea73537a26d566da323dfecd37c5be4433533d8224a755417309cac509f6a09acac8ffd0986a18399ae385efe6b5991f3ba2dccbdd665c044f0824395af1d4b8539980acd43576e13c22d03fa40fc777ac03d3da7dd5f555347526995e50f6600cdc21b1e5b34853126c81547415a976215baa593a03936498b27dd113db16344a3ba982df7ba4c19aca21bd5ec57b8a87111c620f575968b309a047ac66164716c9e6294ed15a69c94a1634f4edb01e7ba3bd94c4fcacb0c2e4e2a657e763325407759be38e168d1c460751520f2b333aa9f490ba957d84ceb9bb525e3f0ecef059a88da7727917a15fffa943b3f55b0cecf10b25bb2fb8b96b477f99df6ae133b8ac72fed04eccc15493313888662bd73fe1cc3790946324be23d79bbf899f916afffd90c06dab3046b07839db0e0a0552c14ee111c10bc2f31942d4f776d33aef9fd65440cf58f652cd913088e8e8bd77dd525e7319169a0e6ae8111ee4950f3bda09fb206a25ebcaa93cd6384e9a3f81a57182b255aa6b5d6bcf033995357fe298b31032b3691983bd63443e58fef065486104600b253c64e82bc53b9dc4ce1f580e7f2d0049936baeb6136e64a9ad91158d14f9fd47c9d0f347f978adcf192ac9ae965dff5a19a4a9701c6d18fee2d256865277c9457b5b8324879841ebe03db45d17347278a5f6fd47d33db857a6c0917934f686dc5213ee16731631af111619148710bb86c65e4827559f4591a4e4d3d4fb8cfa567854e60f5ae7c84195d1098ceb2ce28ba78aac0b6ebccad0a492735c9a627a3fd5d63694305e034ece2db923606f7dce615b660686a190097ac8e2145779d62d332014b8aeccff5c07bf1b59ddba352ec7e5ac3f37912880e1787b7a78290fc08943ba09636b234fa189a2915f7fe245fd2f6eb3129ba32a7f01ddb99b36ac5a86c235fc29edf9b7b9f2a5b5bc15122d68d0f2fac179203cd25a1a62a3d37a932848c33ef3893f1d68fbd0280d0b6878cc6519d96d5c4e254d0fc9a5c7644d6c7ebbf01dd5ae72887d0f938845c3e0075b364595824cfaece7eadfdf1ca17312e44fa345b5b74a5e1b252d793820d45532f7bc95249701d88bdcd01ea8e7ab56f9cc64c9a7bf8ba2d137b581b279b014f9f90062637e63d6569ad78f7b41d4e9c1f1481a2c7b1e9eeca4548587d22bb811adfda76e34606c5938fab611bd13513f740b6cac179936dbc457ccacb87e4195708f1bf306ad9896bc244edc7cc8989c36bf01d8049878790e7100710955eec457bd05c93ff52add5341323ee9af7c85df4d619ddebc325d477fa5199d973d6c4f372087f28084e6bcc16e35a3fafe24e4fae7ac02d5e1775494caa5c53ee58c0b2c8851f8cf19648152b110341d2f7885df862950cdf821b7c0a6a1ae2555777da8e94167fc154930aa0105e769e33a52dc1607d87a4010ef660fb4e5c0fe650424b97d4a50979c2e2a29b0f2ce6cd8c348732a3586b8361fe84f7ba3c740d48a9b9c0e48fdcdbc3e7aa56e20009585e36399f4da43292b0c9bb21155d49f1aacad376ce3cec90f9156296ce49e2d3131f8966ddcc1e94275da670548e65a7632d1ccb8452a92fffc47a379956e5c814851287bc2b60db3e730db32db1ee015f4de4d66ca877fae753aa2d53e96102323a6fe82a5c535cb0cab5da9043b93cb6063a39ec7914a0089408ecdaeaa8da23bd8aa62bcd67aab59978c046ead24e529cefe251958548b2dbcd95d842a0a99a5031223641afcb19dbe269bf44cea4c63ddac3f49b47478a718d50fe4a2bb628d68ef1ba878ddf2af830e750cdcaa30d846f97fa7f91b5338c1cdcee7146a8b3701516e6fa142823c9107749ee35cc5cd4de8df58ae9c24815a6fb6afd6794a382ddd70a70702f88611be73d4d70d76b7ed6ee9a24f3f83422d93abf14242602ac85aeda35b72b05c537c6df91c0e50f960cccb6acc0915cd1608015ff4df64ead6b47f2f1aaaf1fabdbcecf7916878119e46efa721b7cc0cc090af477b703f0bc293d005dc1d4abcb580e171e4aeedb9a627510d1e583c5fcc3bbaa810006870eb16ca6febc2f105bcbce8c4d83ad47ee0414e1d4dc7b2b8574b15d30d03866cc4a8bcf9edd8494793726c9ad8696a162092ba2c15bcf2e0f768fba9f7df6e89bbc6104836388e125ca31bcceb0ec5e5c20e884ea264d2d94dc3b9b27bb29804d344238ec102db2bef451a9940b958d0882ff45f8758ef259724a20a00eb77366120c8e06ffd1b32b20dfb53dbec69205e60a464a209dcc804f0ebb3e0ec35c7563785586f45cdc9a579426e8bad5062033c46e792b8e4486ee1cfe95f4ab6b07876d0ed3c8a1b8dbb52f9c911d22eaa6fdd4ee580c7aa2907131da52c19f7f9fbdfeec2d2c1ff2139e2981f0f217456c0f0041ff3706695e576a56f57859ea33c9340db7293156514fb1b649bb4d14912d40d2e5de39ef85b55e6b839fd817f030170fcdb975fe2f74738664e6fb70618057539a5a9fd7a2775a328948c687123ea35cb2d8141b310b8ad114a35b6f7712091a155e87b0a91ad1b01c5906967dc7c763b338f4d7ce0e474624a91171a437b9276cc145cb480911ffedc399a64d3d87efcd9c20112dead0311582f0ce59929d77bddc65b1f48b6a767a61e6f9d0fbff2c4245f83f1df20acfd3035b1adb1f6e99f4d1b48c348eb0d764ae458a6add51b16404bf64caa9d565fac8ad8831df14c5c6e2c1cfb122873dbb4cb4d1bf275284474be5bc6699c18bc4a4b976ab319c4445ab27de67fa6ca05eb880823285be1fc3423813cf7c752c0102a5a34e03db434b72665e4221cd504b790d97612e2524820e2606671897b3091e021da6efbdb1981234a798ecbab0fbdf2dbd0389878961bbc56cb2bab577fe2758edf9219d02467dc8a7caeb2aeadd8f8068d84e856a29404e8dd48e6fece57540d23dfb74df03e55818727c9ccda945c1eb4185fb6c647ba29d2b8ab2f8d7cf800c34c58a4f37c376ae9e552606b1b4ccdb9da24d034fd69672ef25845aae10ec9d1e82b0cac4d0699d217a8569eeeeff675994b522afeaceeb9e304b1e65ee580e5b0c8a9d1f40fa8650a7b92d6ff774da78a1ddbab74f561275dd7122443a2be8ff7326b78073a40c3b6e704e678dd92ffd0f0ac3d8c9ef74e7504f2074d18b2a4ea5c337078d551eb3eef40a5837cdacae84b2fd2213ec9c8c45f0f228f3b4303c492d527afbc01e0e00b4596a12ac8acc7d906a0b434db143546b6c1d3376638a31d2fb97adc7a6f04fb21c2205ac33fd0345520c7915367857de448aba68e6d5ff42dd8c76be938066ca94ebfd1a6d4385263275f0fc9b6f32a76a4e64c4011599d55bea9adf1666a0a2ade97de2ef4efa2208ea48544ea0967c8caa168863c12ddac220f9d09d1d8140ef461739076863e410fa050d5f4c1f1fb2c6a26756226b951744b99b254f40d0f12c8180b07a85e3483ac8743f3d6c0fbc5795a32bb31d66452d92ddc6656f07efae0d74868d0344caf60a0ee6dd63d7b6ad170dc23539dc158f6c316f1064857147f8b38840ea1fc80d9d52b8c1767d10cce48604d5b3c08e78986a0e8de91eace15d1efe5566c290afa7c981bea11556d719cc317a18949b05910e6f5ca918623d6d6fcc596c3062162e59257cec3c023b4b2c7eb4df53fb4eb4db3be310a13ade5d3501502b35c939a1e5a3d52db36c55f463dbaa147a8f0ef76c7cbde095e3135a3f6fed30776abe8a39415e0fc243d12fb1fa36ea0ff5beafd98dd739517279646ec7c79b153379d8be95aa4c10ac0d3afe6d02a1fe90a6a500a9eb1e9ef2042bce186dd14aeba876d549de4cda97b4df08716b5d7f4a3b2eecc7c44302940cb0115faefc8f33a24a09f8e04baff025b12f06129fc73603fb8fc5425a2b596390cec99f3ac667fd9f168f3eebd8ac82a074cd84a5ea16425f437db0136ef99437eaf7a924f2e27fe865cbac2816c484529efd55c275e3d26acc90f67b5b69dcfc2354e48b8ef547470cc379ee084f12e4046a08576f9920127e134f4dd215bf408ad2647bafa4daf640b9a1c258e134aa4e02152054de9a76fe380c79328ba5b00a92ca8ad00c89afd3eca37b6c2714fbeb68e729dbb23cf5939f73d02637f2054ad36d403f0af157260b158dc08d059b08d13e24800cac01ff1b4790f70d0a0ca02f807e69669630815a39c26e8b885327f196db6ecee2ca02906b99578650ab017c4147ffc5c11a86e0c48f626b00715394d8afce5dd5dc24655192a74c74150f3a560bb52a7ffb3d2daf610208178d9e9a17273333fa4ce81df912a450e637e120a1f3bbf1afe753e48edba86378117085c930a1a5f2c2fba07a19c4189ec23ac3c13884c83375635a561fb38959639dd35c006afea8e52b168781c06e66a3c352e04f224096e707ad5302236d898b6294ee7410ecce32ea0d9745d8ad868608fae515273ea617f464955523bd495062f371d400aef5668b1581bfc3348ddb4a48a3a013cb169816148fbce5f870a9a86afd36f6eadd0967c069d30d74ce49033b64ecaf6e12824d863e6461d02f63cd3d8d799f946307487fdbd083712112a569dbd597414f880a02de1c2edc53d3dc60a635e587f3f0a1e4e7971820bf76bdbc94d95f5b5b8742739f72f0b13e8c28a03a2b03c0bba7c19befe2e690215ff2258874176289360b17cd5024a9a09701d34fb576cf858d8fe980fc8002ed3ac39956c7dc98b95e60db2d4c049a9feda1e3ed7e15d36aec432a630d841ec6346d67580ce897a0642400df45c822067989e7c41339ce47bd5aa327e388fe04ffb80f457f3b7d8dbd736bf8063685f607bdf39da9d86c0f5041749228debc7d98e3fc30e309183f7332762bdb1a96208e2b2154c1a952973a79a7879dfaa6d3159e954f6251bd9e6cb89fae30d792141c0ee6eed66f69f4b3029cb0842c33a944c200dd08632090968c6371460ec8f477f6d4475f08973d04ce1e9563b4ca7a6cc846fa624f491b42986db025740929629baffd281fc64167d061b96c34f68a9fbbd546a1e471d555dd79f5fc91f915d1e0e65bedba4f2ea06cc15f96e9b9cee41b409724cd4d9b66cf116d797eabddd109208c964840500719a0ab25b928452c0c394888e82ab827f1bbde55e2014c9301feeeaf79c9a63f87099580d4d12f2a3d38ea2a94c08c55516a1b7f87d0947015870b5e971994feaaec3944b08c99a8bc8b29b86cfecac099ccf5bf9499b94ff6800b3862c57a0cbbc153fb788321331d209df41121c3956f5741a55148682658bef226bbba33c6dd4ffb7a54b24fd1bba52","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

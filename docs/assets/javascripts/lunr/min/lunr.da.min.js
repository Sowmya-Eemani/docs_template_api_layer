<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ce5f32e11cbd2d2578dc555b6f13290b16d566e5aba6e4cf36bf44ae359c55816db5382386a05dd6ea07e1e236518e7a0c038673d48254df8c7f815fe4a2c121ab3ffb61184f9f1cdbe57cfe7aefb541e8eb44fdb31e2efc05cdb9ffbdaa8736867d94172cc8e21e789aa4cd19a9f039e3a920c2d86f63c65f8d402fb6a03d4dbbcd7fa8e40a6535c4bf6fffe29c329d635e408df2dc183afa7fe0e2f0e5cf2f6ab128a20dc4d959147d51efb2059b1ad073cd79f9991572833dffb8d9cdc2cf3e4b607922e87b17fd707c05332a92a8311ffe86c9f877e66f531622fdb935ffec836638db409e22513b5f7937cdc824ffbd86c34d856633527ced199fce30b49443f4f5570bb4a68391cdd8f68ba171067d78d112acbf32b07a19daae8d9ad6b6f6fca86256496a29f21cf69a4dbf5b50d61ba64093ddd65f7873c52fb7a149c6f63f60fc29e5de13f4c4dc3de159c6b106965ad61a3c29efc47a8502cc70c8567bb2bd9ccb7d3b1d66819cbb3f1dd83b4f4cd88b95606c41f1c023c7626f89fe4bfde2a17538cc8bd28ce3bbb32f105e4610cfe41be306ec01fdae7d658f3054315e6c251edfa7afe1f33fff84a6378a697ce956ae76416d6450fba1e08ac9b07b74444eb1b6db2ba0387cc276f759647e45af275fe1862cba06a13436763142a5fae3ebf983ca14b10e4595881a0d86e8e67e46efa7460fd6766d778c8f9bcb610f3ba8861a00559bf4f5c889e509723c071900a08f0e11eaf2b56e3838d288fc1606912fd783dac1992c30e60aecfa82cad31d7fe8e1ff146e093520efeae9003cf2e00aac22b3635c6a51075cee3a1eee7d064e0cd8d734b187ffe0ca7b6938c7e95bf9277825f2d953acc66fa6f8a3c7db7f3600c5a145757e16ef7d190ff1f0ecafd006d1343bbe9411088abe585d96f2839a6628f0a977adea0383e163be492a4d5262df112d7c6b5f24145a32ffcbaa51cde9ce01c4ee77e4b23fd6c2c649b4ce80befd95e0307aa7ae00ae0236a9e01fed22aa557a074ff2d136e755a96621d5f922508448303a25b5f0112a992f0a6fda65ddbbfba729325f6efd9b76699e09865f72fded1905380d087314016d667c0a9cf7499a678d542aa041734b5edfbe1293bc008db57fa51de35fa51073c694f084b565a35c1b1b526ef42ff4ec02721b7744bc10fb224136e97d0a6ef2fcfd3ee2709ee01b502458a53d986fec34b18b011eed147bc8bf56862b97fd17413fed3cf6b1fea438f01070a0ae6eb59e9c8698c08f2d57340a3016224f7b6be61c5175374a604e153b839eb5a313533b8eb13757a2c41445d91ea2aabf848351c119249e2778d5fadac9f321a812705f7c03fc0c06390e0cb37ef85f3b53b7ef9b54a24f8b010d9de04b58bffad3c9eb2cb26be10ab2a51b51515564b753c8cbcd419de3a2bc48f964ee0054e047909275d76d2ca8943561489675f5a87e533a4a44557c24edb54ed4829d576d4d56bc1ca689e7aa4421592221dc6067ba9f51983e1d6f09a918a87641e9ebf978758ca6ed70f51e56979e2a6dcd93eb82774be1000107ac5461c32cde16e012a180a8bad8b02ae9935fcb4b233563da7e3be208db73c202045fa9af9c8c3f22332067531972dcb4c31bc4f6b89fb473c6635d7523871d642381af3665ccfba6f8e6f4b60e27927123ee14eb4d1e093dc9b35034156931f27c543fb64caee48a6a64491335a0befecdc9b2dbdbcfa22ca86d3883c74b4a6facd89a8e1bab1c639268d3b0702d55507f8548c032f326bf77460680a7393ab554da601eb7e0e0616038658f82dcc5af0e63c0e31dcafbd002ba308ab3c738769f9251a490c1ada648bb86c46657c94d8c14f86c565f1e87fa8b2def716c7094b802615689524be9d738515efdf5ab3f2a505ebd2f97340b4e335beb6bcb6a6309142ffb0e021b7c95ee10be5d916a48e02acc81cdf6087604a0831b51b1366d89b38a1eca59a12ea61db8ca072690b4bccdbce13f6ff1a906003f40a6f4c20774a09dcdab0541412d6794eeb63b72c9a8a98be1d338c8653d80cc2b5988d8067b6e4f8252e27875e4a7798a8b53784d1c56dd556a44b9d2343748bf5cccbf493cd49463ce51ee7a525e2d871c2de2bc5fd3bcf52d61ed398acf2f7ae8e3415e421c8f9c23332f77dbc35c6c58d40610af106d0a19c478ccbb0c7fe3ead9e6f85d7be2bc336466f56d2066e8c2f469ac508a7dfcec42e2d4a576c1fda0f289fd09f970baffd75d15e06b3d9ac8fda89ae60fa6514d28615caab592d37ec8c7fde18c903b7c3f6ed54548f79371242c1a28ef31715c3408a95588f2f08260fcd45b856783e736bf208a73e7dbfb0f845760fc7159360e34b7e1c227a68c67acb0271b5bfeb031e67d50c6303874cdbac03e35953c7be6035a5d704609d632592cf95d2221aadd5e4cd8de83948859354ef3422ff6185c5cced16fe77c449801acf401004d3541f188611c5386822a0d9d05caa02fa78e442cafe3b49cf57d37c1d70ec75dd1a8c5153524c85aeb55e296eee36eb2bb2527e83bf7b756d85bc841fa73ca453a35f74af1fe9625cf83033790d4816b99eaad5bdf60d2305ac9746ccdbad809ca42e325679067bd7f9a593f581de0df3aa341ab5f3bdd30b1cfb0d71025912f32187be744685e484b016d4dd82af67ba42b2e469705c9cb9decd63085d0f8cf42e97045fac132468f6921545e8767a06072fcb1a2d1e92616f6916a6186bfeb0962c94f5e5bbecbd8e27e46ed63432b313cdbd0d48cd102d8d340320a6490604022b9d5c63fd063dbb4f3df083a8049a534ec57ac96418a604b431f500243741f40bbc3deabdffe7783c1a83641b6105a9f18343259afb20226431c7b7ff359b7fa55578dab1ff611c8ece5df24787cc995e0f3cee09d7ff77968f279bf4aaa828605ffbc92efa2d82ae1a809503ededf075b90371fe26530c3d24ed7c9a1483e70536c25383cfa5ca5d941134861d7770451769d6f9581c3cae6c9af40112010bc33b4451ea43826f5f4f3ee80f4fed1587d35c36d2246f70116ac8e9b64b838d76257c5d9241fc1ed6f9e101519fc1a49f2a59968d6df4beefc3d9706706a17b1a975d65f9577a6320d48a0a4f4651f414522e3d54373db57eee60afbef66c038ab8c4c50b41769f0f4e85cb1b5d34d2cd14183b85f1a916aba0950a6295c6ea3c5f1bcfa78bcca91b4ea2635fa1f013274edac7503efb15f317bc9aa7ef01c5ec04b78d8cbe4f3d962c1e9ff977cd9de6c4052b49e2959daa3dc0b4931c1ef99b34b5a5d67e61f959afcc8191710ff0a1c3bf94a15e84d74736fa3209f7af8fd4f70c6d712a608990616c8e3ae632703583c4a9b550a4cd65b11570b17801b784385fb0b8d92246aff10f311b51e5ca334cefe7ad1f68a91da6e1688b88928fd8f2606b1db97b2dde1faf3ebba3d3980996544b2f98c1bc6c5e525b9f2e11fdb946a8905e1c5ea53e8bf805a7ba34568a1290bdd0d5b60483f5fc9e8fe3777323984a5deaa230f1f6bfee4a1b7c4a2981b88370a9231ffc923b01ae1195e333dfddceff9236f07aefefe6a4e40761218c53fe2392875eda54cae2de73723c6932c64fdf9c7c5b269adb9488a09a8e967ebe666d8de3ce7f76d314736a74c1022ae0cd33137ccbe14ed56baaa8ff52164176ad12ae8bddde02461d03a8604f1704683a27eb02d9d0763d37c020646de574e9bab602d53f69c8bd788e8dffa5d4663b2f5ee20fe3dc3bfeafcb7102d6642f2bb216437a132e1d2b23476d7abba0a5f1eb17ed1ae9afdec838b14bbb02a4cd2952afc53cff9549aee1debc31c95101a1fec82c7e8de111fe3d4a1a6ef44ada420e83183c52817df2b74771074b4e5c9fcc3d786814519dfabd5e266b2415bc15e213a035e8d523478b6341be3402adf43c099efbf69211e0147664af316941013193b66a18e18acb7114249ede5721277b5282ddf6f1991e9acfac1db769f78bb9b5afeafb39b3209321ffa41128f5e86e9a2c445988fbee853d80e47e452fe5536ccda6e9f53c52347098503fe48f227439b9640f605b19e0b0fcabec37e5d8ea8a0a9351a61df766726b26380a87963fd2c0cacd632e4142a68af72d1e003d408b6b6cde8f4923429e65244bea4d51e4e414670f7cf3537731c08443b2d50d713043e93ebf1d51765b54941c883f9007cf20456b5783344088407e72e5f0148d7f4006533a6abfa6c6e41228307dc07933e8e3c9aa4c370184b355679ea1be47209101d9c720975159b337774873cce5fe1fe9f342500e309c399f88f2cabed3aa1aef44aa365a618edd567ba50bd38c521ceb3ae73097b8b34010a750bfcb7505719b8594106465962f3c1a3fa698d66cb0ecc94d35cc62237343c0f55ca972984708b50c0b4adf84951d9e65f50d8382b7553c96796167a6cebe72c72bcf588705f06bbdfc8264da9f3ce631c46f33146e22c99846d8ffaa8dec394e425f56aa4b1af3c6b7f908c4397d7f7ca99c498a379048380948a890197492770673e2f96426cbaad4d3c595a801789bbcc03ae832443f016e4b6aba268120a0f759560d4f7cc76d8ff6be9b1f15f5ef8f53e1912adc57603e269c0852d6bd34cab66ae304667313e1c8a72cc42775d6c4b96a7bad2298653dea6cb1f21412aa6b46460f47cfd9db8b235f2aad9a8f0aeb754d0678e1640d2a9ce2fa2797ac0341f843d0dce94749399abf91a13816f0ffcb764928de95e0281c16bfb49e84943487d425092d9e3dd13dab2a39ce623d59619aeec8cbc6aecafa8e93b35203f48d0c494e17f0e1519e1492e78364df3e09de074da603620f8cdd41573d3fbb1e4a6740a22285d570cc5b652c94346d9f1797be4a6c1b7e0322b57afc07564125198fe49fd54f412c1c1dfd21937b3a67069f7687aa71b5a9ac75d1963e4574a6f6a695c09a9253ed30db74afbe76be04ab486cf1447f94a9a9f8b079acbbd49de01e972a85034823230439a6eb2861563a2fe14c585fd727d3a66849d4c8956a2eb5c7dbdaeb26a279721379d0e9715f63eaa54d777bbb573ea8cc7681a110b1ce64a756b100d4bc417404140e5a2ef0088eae1e0d19df00045aa00a5f20d87d5318a2c31e7c2348fdf6fe79342c1d174f1848e6197d4d567516e2d7e69b36853d5e452224b0f435e3268dc744adfcfd084f8f94d8f1f7de91e3d99700827399fbcdf73cdd743ed4772ad33144e604181a92f385c1e43ea935d6a933d46003f425ba688f5d291677916c3c9ab1c91e8bb23d1e7a8fea4f540981bccc251500fc5f4dbe5a3a969b301b4629895b143891eca2e5423b5bcec18376396a8e131cf6ef2c8816173acce333fec32bd066d4eea5d7fbcf084994f3898e25fa3d969c54e48973b5e4e83c15fe325cbfa54e850a86e57f3e6980433f299e809083fdf6fda0696397ab9bcc15ac2e716a091c3498f3c5385b17534a9aed7546cf8e89c6de7e0cc2cd2b3f2686c9aab70fd0edd602fde0f016961067f7b7ba2c3b8b784da608984962afe7143ba38eb69b8e5a846313dfa3c6697866b1bb5770c5588278ae342baa4ff2544d200dcc57119c3573dafffcf77c5cb7808aae9d629c2d83deba74078c07018cee2934df29986f02a42b4fd3ae1952ca2c562710813a92a1cd315b3c94910ebb361148449991268ee2049865ab5d3fafea83b9ac4ae39f493bc35b9a9e2005bdbad29e0a04f526062e52b1e75aa7ebe0fc9528a95096391ba81522ffc4cd1cd14097dbb063b7a80643f090a041c08ca9f6f54469b98af0b29667d1cdbdc969d0feec83fc917419675646a4a70eb7002b3e8afea800620f78a65bc4cf7c897aa1ccfc9710e3a405980a07fd021db98b6e3685bbba29c8e2199af809b200a4acc35fee23a83b4caf492ff3ffed976551d62ddec1a2ee5514a13e0f2be52aad8ed9f0337c4f8d8f14a79d45ed2780eabe9e2d1dd0bba26996b462505d1bcee31d9ee1c0fd1a0ce3edad1d4601eaeac1a43d59b6da72f77858cc8eda20e41cefbf0248cd8d87b0b7d8e64e05eddfa96258887f9bfa64acce9325e2c67ae572c5f122a42269d94a88a8bf8b02b1d46f5082ee7e0b1d0017ceb19e6ca580f85148c07e0a438e3c2f1773d23229db30d09144ad8ad4c5418d25803d3da1934c8ac00904343166e6fb5633c6f0c50915dd88cd47890f2b1c4a02aeb3180a415026e563fa0abf33c1a3c7ec403ea9594cfd109328c165813264d98239a67a8d7b2b590f5a140f311a849aba40d9549bf97906760d8bd91b686cec0cf399eb76919b3a418e9cfe427bdcd794ed2ee685bbe7cb203d512856ffde97c410ec95c130756382da9dd059160403a6e83206a6fe5ff1e4e1b096c6b0553b5e1ba9fd9f146bc2deae8b2ddd3ebb609bfd4e554aad195db154747914397727672d121005d9b7b0e8dc7dee1e97c6d5b5ef07f671882494b5f3c9edff37549e9e49b8ca1b02880965835fcf4681e08fd4130608b6d028e8b745a642bfd05a76b30937f5516432b3dcc6638f359a10c7f44d8f38558594d73e9b2bc9d82ba37b67e5d99414d4385cc309e07aee511c30249c62c267b92208190f2a10fa97068f93b98b432f81917363788973a235fe270daee4c6df8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

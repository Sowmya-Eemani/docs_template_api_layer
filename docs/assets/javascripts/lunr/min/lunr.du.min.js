<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a511ee6993c4e62633a123c386078a839cf62f7f27a9f02257a30818c48ee7cb18b00d278526cef87040bf0e750eac4070045018e826999da50fae07e2c4048819b2d900e7047d6fcce072e6976e2fb46d8ca70eb5edb19bdd410ae42b9d1ebb23cbdabf2f38d8a56b40e732d631bef70b3ef97445c8cd0f094b6945fbe3a6c48daa79d2f2a4c818e26d85d7625893b1b47000a01d5f16052456bddee6b247dc9d39ce063f7b3d9aa0dae9777b1a072ed0c6c9cc647b95b471b5d0346178140e70b2807e9543e97f5a1290304cf45cf2b58cc3b654d9961c1258853ed593c44370ffa5607a32606fb621599a86452ec41c61ca10deeec2253957535feaba1c65c35157c79197255782861b58b9c1277b4192583a9f8cde0e673c88dc99e79d6da84ce2da6be23dd45f289bb149aa3200935cab68a8cdb7c3db2fad27a927799770475f06510b36c21d2017313bc31b48d06ed2dc69e3e95ea581c4d8e630454f886e80fa854171b894d1df1e3bffc2337e96df23ac0b35c611cd91043a253ec84af2676e1b364a0e91cae08d6cedd2cc6bf83f90438b2139e2a36bf45b87d8cc4b9e1ae319a8317b78fe115d796171073c780f35d4b1b6377b7cd4735fbc254f4d42b01de7af9bcfdc3aa4aeea481e74496ba9b26885edce6ac158dd8f0b8e3064b759993dafc0fa711ef32926d9e98dafa008b137ef0389cad151a77c3a3dafb0781fcb189d067b5eca517d97179ac9a33467f46faa4145ddf1e7cd483d9538bee76a84dedf7492a8f272a9d28445779c8691e72fa8df436eade6a637d3717915a2a551019209a2aab1b83dd0d59f3d78fc3c493272ce235c68286d387e030ab3a74f3c3d5446a6893416c406c1cf8eac730bef3016e8545911907d9b97ced66240c6addf31b26c7cd2ab55f8c4285856b9763875431d98decb2586d6656132da7cda84dc29138b4fcbfd8d35e1a4dff49820060781c901a96b8fc2090188ca03c2f7fff9a20fef82cec6690a3b46fe460a2ee817cad3bccb024f6293a0e18912b75b43d9b5b7123fde79693063ee4da39fdb6a5eb7c3a1a95ae6a04a9f3c704cf3baf7580d0d748e7e3adf5ee95e7bb04d70c5bab34c96c2bdf93442f0fb009e10aaf913bb9096fb8b78a59b7f033c0d0eb35b4d8ed931bb5347722019352fe9df7d636e92f9e5ea86d844bd2f4d4da9f91a12432279048201b2d923ab952320b748f3bac89ef3804ee25e8247a07fc8a86e1803ff629746ff4d7a5c6709ec25783740932cdfb578f0ea465ba0971eaa6c2eef33a2ac61492ed96f20559609614fa6adefffc7cff9ad9508520ccd65b9836ad5804a9d9f83498a9965085e06656b3878ad0c122effea79f1deebee0b653ed615ab9a131dae62ad2ed9c644b490632bd8190696b0f012401582f36134b1b8342e00fdf8858dd7b87ffa89492f92fd0c19321da2767f3b6e542fa81bcd1386d9a17af2268610d950266689f6e93d850f006db2628997b4e3381df1d7af1754a5a30b56f349be71db624882b76ad00415d68014dbfeb890b4bf19e3ad995c6885790535806a02eaf5c03926d1fdc53a18d5d2382eca4af3ae100e71bc87301ca093df82f8b9fa134be4937f81b7a25b51ef69ce80bba515da569d7e4f62e68527c08caf6bbf987822df9ce2609f6148ce5904295b0b547e0b127e15f5c1344f3e39fb568e42904d651f1ec33aebd4f4a4a76386f64f0a8dfef11980ee9e1a1efa37d022bd1808b66d7492f152e47cc77f3cb36e1cbe66c84be3cdca6d3675e157fde49a3fe3f7ba7fc1ec93e570ff4b5cc796bf559e88ebced489702d868bc0d28c8a90c47d195c2bdf3da59c0708de25c1753e2cce44c73e70e2756b1847321e51f6c810eb34558a4eb2e141270e668a00d0a8768a69e5378f1db0ef0ba78202012057b017188a83cabd45eb9d2af62878dd52d68614561b2a4d9d687dbf122dbd525af8a4b3d1613c0fa6cf84b0cd48bdd7223e1e67062065d756fcf0cce4924bdfb6062896639c90fcc2f0cde5ac4f8a9669e793f3d58afdb0d5d6308fc63871542e28ed57c63cf37bb554d9d6feaf43630e7c070f511987111b115cdf669071c43c1e08fab1a33814f307068a36260ec2534096b00ae11faf7dacbf79b127d9005debcb2a2adb3439fdee245e938fe894585f2456947c761b71505e563a41cdea744a30f7173084d461034d9a2a3cc132f1506a0fc694281600ae75334c4523a1c0403ea2f3675acc896606f9d1f20e0dd867946e091edaa78b9d9383204fec3e2e539033245a2ec1dc083725dfb2f0661ac020d676993397512d2a2e5913d98d4cd2cff6fd69484656cfb85a8f1ee340032d5cfbdb65e460bf9d3517d4e03a03fda39ed33a895e0cddb2213f9960414e98a88e491958bb5f9490bde9a91ac7f77bfec0d7f18b9486742abef70fa1c553c2c9479315c27f015dc07fe8d4fd35db6fcecaaf79e295520b38923c62adfc6ad34718c4ab5dbc14ce9e6497fa09f61add259215fa00043caebea7182dc0e0a16aafde0c68dc0a109785b88d39643d2c8c5713186134a6c32fd34864ee07f69f2332a62c7c512c02475baaf9ab3907af6200b40455ccc8539c8dcc6f0e0f113528318626bd78c5be9f2e830db4bcd260ec2db8300cf532df9363de4791a67f40b89a306eeb8c9c2d6f8892a16ea104471d66f88ccbd7122a16d0869c513964b76c91f20ca5dbe66b6ac7a4ddb3cfb4cb872d9f3f4d2fc3cc3f1a8eef77efa2f26e0a04a8fa8d0f670f40eb497c8eaaf3215257c84019fa7993136bd0b94c73ecc4aca72e616cf2e079dfe677a11f7bc2ee2536f370e39b34a008d341519a019a105e899e2e916daec2fcba01983ca31e8e5e1613a4e16def5cafdf028626d5532c589d809ebe0a34933a562bdc30ff827807402bf5fd2f8c4780fdcacf8e8339d63dece6ee76859ea37afa051e70f4aed99edf8c392962edb9506708ce8830fd8c7a712947262fd086ee79c3e29e35cedced9ed1f9f22b29128daf1bed1439492b6a49e98f6c02db00dc78e20a65576435812701e86b6faa2321bd2457573decad2184109f0388cace677b7fa572903f2f11128b1aa3ee6069544a5c63b1ec03fda42c224d8e6c184860f657a20890e7dcde09a98121913fbcec7f8e318fa4854bcf7725c3b832d42f2b5c4bc3ffdbdaf3840cf09bfb9145baf3b05a16c822d6fd880ccd4def13eec919f708f8554f7997e8fbeb7660eb1df91ea49ec50acfd4498be438405dd5bd55a2e953c57108e15f3cf393e44d3ca9bc0ed431b284ee0cea3440bae9bb1516b822a7579b4b560125e6a7d7bbb377c57f9d1b9473bc315fd79b77ddb25748f5f45e1183fc1c42b9cc145c14bdca400d02d0d63dde1aa00c68ad411adfc0fa7e9416d1bd7bf6d691b890d9df3f497116afb835a0e58475c8b00ef65c74328d44995190d02440c375ac1131a2fdc2a75b4657e87a0b3afc64791621b8d66c6b766795d6c72de65b07746a61e568f0dd7083585d962f1648b56ad16715c4be9160f0ecb13bbbdab507487c1b7546a57826e9287a33115d06688cff407f39bc8f10c665b7aa7c01ec06f8f79c36e63dedde7887eadf3bcf563ac324a6d70137e23f2690f20fda6d02b84c39f38587c6292273b32c01d7f74e96c5d27ebe6fc6ffdb83a00bbc5c7ad2274fc164ebfdbfe191bb3e24db2b84edb4ddaeb81d68efdce5b75991324ad8ec5ec216c5186d9e2ce0c002341d8ad5ed46342103b88ac82c0738fe02477a490ff5e264ce4e4a814cbd30e0f1b690a77c034f3ef9f28580117c975b39cf2b97157a3f4d14ca3a8415f62868e44819f7875b8f747c02c98ed296255f42cc425c8947782c161b556c873623766c64604c092a3d894ed63780a5e97952f6aa9f452260fc5c427f5a5e4454e326d4c0fd09a9063e5c7fbe0868e02ff7670d576f0e1aadf80d076855781cd8d5d4e179ad60bf551b402ef3c72a908127f3b67495a008b0be90c63ee8838221ed943f7cea567d952d14caea96a6536d69cec123e116a9280d8a8ea88a033ce08a229d5184e7b0884ba646cdd49f33aa0e100c87013411fe7f46f30b05cafdd7883d057e0a35647649f04b93fe0f6dd8109f413247306db22fffbd2eb5baa134fa68ab29449c7220582495807eef374c333e3c860c6accfd690862812321fc33af5359f6a1fcece4bf22a23f00cb9df6cfc8e267d2eabf3b5f4800e1eb2e06f971b59e06df71b19626dcc88254fafd75157cf27e87e7e9f38578a48e30de6ca9ab8b9f4e59ff9c1d3fb1e7c2c31294c16b71ed5f979da1db4eeb342a3c6625f5b3af8834bf31dcae112b2a330b3ce3ac29ac7f3f42e3dc128e4ed5cfda5332e3e7dfa77ad4ad35bdccf3ed87ff7f15e02c99799cd0ee55b04261c072e99876d1ae7fa712d557903ef227db01a426a4a9ccb8df94038c1714b55091ae55811a79f31928df13fd1853bac12a9f180d6e0ae0c13855d45dbb8ef5ece3d5f8f2cff901920996a2d6fcc86871000833eb1cf7881952f19d1d6dab0f2b8aed46e24cd92aed74e00ff8541d8e4f1ebe00d68dd14010f5c3be0b807a7ea1daa325807c07c6c464177f0f876013cb53bc9beec3356e854521107467d21b9e75a2bc517d1a71759cb434696087ddefe578698dc1efae702536e21539260cf953122bcfd6cb56ca52908883d269db9fbe0368057dba86912c22f87e9ab45829792c6f08159d558e4045d68b4c5272d3af5b54e7029042a1447fd197745688aa83e66731ba19998d4ac85ab423a6405126df1fba789344dec2ff68cac28de5f51fdc8a395694cf78fec043e7f3e4bf48b360f38e9a45b239bfaf2cb3e5bc3d339afbd1a32f3f03f1c739bcb7b0d02438ceb2542747b12097d5764cb2ac0ed7c15e8187881e35d499b3655590245ce85f8596e46e9dc548a13dbb5e1920c21625d34731ed27b9f0f8ea6fb455a2a64fd63af086b1580e0b7c9e9e393590c2665e402b840392ce3ea2c04e87ea76a45feea0754021c049def3aae5a504e7c4a0cc2dd0c1f226b286d514b119ed071fa246be7bc4d87da1bba26d926a555454e55cb5fc8ae317befded6f324ded80eb0f8b38d74300671d55c7cbc1e1c1d9984a84c5c031ebe464cb96132eb37ecf29a9d4cc4dc6668f1c2a73ce9142a2a73e3b5647d5753a8f4cfbc308370cdb69f768f671d957370c8352848bdafea6f9287f12d85e09aaff8ff670dbd8409b1755290d0dcdfbb4339430f47687ed060afada83213b1ca9be18b66f6048ebdc71b36cf3847310558bfcf05e81df7592fecd965f5d77a6f0a218cdc6b91103299522eb434f9c47536cca5b7c4a83151b4043839ff957c26d352feb7520032af0554733b372952d78904c7849a25d94eaa4d5b6e612e757d277b8ce294bcd5d33b48bf2894eafb91c492f15bbbfc60459d8a80f0b624f2fba372ccfd7546ddb5dd8577f934768f107c9fbc50c81be685a09c123511fc6124b666d3132fc717f6f80fc2396001e4b5ef3deff0c9906fa172d56ac0bbff132ca17d830853e44ea43cb39a9dc7d9b0dbb727d1599fd7082273d63cfe9b2bb3e7f6da8e12462414861dc6b42a49f44a32ef52a012619295dd25462bf83a8e5564a0ac9b10f3bd41602efddf20638d9e7ccf620ba85838f53597760b460cd4eceeee32ba6bc6551fc5665743c0725c3ff4dd806833e4154dff48a6cdb773495991db5280b87e23f88351ad1c0a52a5195c13bc2b1c2f41f078ce4037e7e85df1e326102051a9d772e48cd36925209fe9c7686cbbbb71315ddcc07ac898286a19d1ebb7201158721717c284f864fe40a9253b6dd3189b0c687a7790e3c8e4b1289acd6eb3e35ea0f7d83781f31c2b1bc07d25e0370b169546c6dbf665433d867b5ba906a1d8979c9354f2f722f0f26ad6efae0057eaea66c6a5f3e75fb565cf43aa1d2be9f1c0c8327a796611cf7940b191adc9871f64bca89f874b402dbfc4af2e99a6ee103c6904158840b1529a0ab4895de865d6be77aeab0558d094041fdbb618665a97b32abe14123b0f2941d40c6d6000b35fd394517f2cbe99b7e645f2271a515185d69f855631dbbb4483608fde99451af85a7ebee31cce939889adbeb1b102e04f8298e60e78841fdd7d0abdc7859a50aa7e09842529041a99344f37392f1d86e396244580f0277b7fe32e0f90246fa1f3271b93a0e2abcce9df956fd79513e25a6efc01515bac629d62d444af5d87a24c151a1f898c33a23757a238dc5bb675512548728cb79df0a08c7c4b74b2b5fce45983b5eabfbbf1585116c68b73bf921e2a1474bbcd1a368349c143a136fcd87c788bac91d7def8b93c099dde19e62cf564856d2be93d6fb680c9fc92373252efbb9018550cadb6e6719e7d042537c49c967cf13a1154014194734f9fe51244dd50eaf5579725be4bc24a2c5eb9ab0593641c0aae7b5eaf16596286795c9d616105fde003f664e6cfa01035107249c48f9ddb3e3fbca3e8b6cfac08902854498306a5ce7a9adb0af611c060a40e6a81931e2d7e961a18cc999486b982bf83a61d6c62b89589df17960f07da0ed0a01cca67bb956d40da24ef617a6db40c8c0c527cdda719c0555c614693dbed6b1a0913e7d46f56257c25b007a70081e166408b98ec0ad47544972b81ef5f6f275958b3534200000055d10df539bc3d2530e9acb41612fe1276fbeeda85f18b4bb958ef1fdece1c9e829678801e6cc03ce5fc3c57ddb86eb825274624890340a3154ded1302963e37b19e754df6da3637bcd623e4ec3fa9fb8a8961bfbb21aba9237d572dd1d11f7ad40daf0eb7c47de328f5640e80c3dbb6d2fa809221aa37052bcbe7bddae01879352dd911e1c491ffc13b808aa6e7fe8288b84ee3e366559035c7fde7e0977f43d5542e0ca05d710bf1fa4ece01f68d1bca398d7aa948e8eab0d14d55e9ec2835fbf0f6caf3c6c16d1e1134a0037954e028d093ea3bb16cf83610ba6575cad864a792efc049d0fb4f16a766504f2ac18db1661e7e24820248d31c53302ca39a4a65684b3e3a7dae9c7661a386a4a2eb7d9553c2e34cbb37667f138b5cf8a75b784be7f2e17a7081b7ac5aae407190a17ec07a71d14017a2f2534c63e17d42b9f92cacf86ee91c0529c8ea86c5f0651c16626c726e30b38df9d14068bd7b5270e3e568edeb4ba79ecbb2aa28fafe3ef53ff32b5ed14cbc1e766f1855a4fcbfb8e2d95fef518d98c4ecade925bcb142724f8da05550d68bce3acd5f609348814418bf1bd09be7a4a7d2048f65ef800a7b2e50ba449f33c963f7579d970424d9f4e4ef6fa906121b8f49f0e5d86f7b14d2879fb61bd33c3b1ff47663acba78de99bab127c9dad8a173547e69721201272ae7b650f3ece39f20e5331a2ab0e06eb1d07cc8de11edc5b7fedb0979725e79e14fc17e52978fe65cc9124bebf56f0628f32f135d2a43302352aa86f001e0163383e34fa60cfb431d88151b6e1cff4836920f456fd62e4534fd1f26d31bf4658bbfc8cff478d39d83054300e354376ff0003a7d4f0f97a1894d91491e4351c42150717ea6240b4fa1983b3ca0afe593deab866153f51de51d3624c1dc166480b119436046fbb355fd35571763ae1826873f558ca5ad09804a0a258d21708d1bb64e4de0b3e4cd7f7f582b824d0762a6f60d38d0b4446336a86e2667cc61810008f6416310d36e30923e588e25a91d32b46f3ceeb30e9984c2e93ff1e7e0893ac2bf421306815090c2ad156bc3148ae586c43731c9c53a0483523f334cd9077bd82afaf6bac354cba8fbec7bca488553f10e1294b90c987ee202b36f877da264c9cf2e0203a527acc95cb0048f1574457860fec5094c8ecece5441ec81c6566a3a3ae5d02c27653935696ec88b71f6bb85fd7cdab39bab5e1622b3d5e591dbe08200f1371d931ad21ebf58dd3a84b3f15063262592a2664e10f66b6a0cf9ab5c55cc4d76f8916c2ddde53b56a27cbdc5d4401fb499dfc839fe7dfee390b492a6689423094cced7e0814d044951530f014189e05bb721aaa0d977f75b6a5f89f9b0dc6a034763b6030adff93b940733422908012344ad3070ec5df81a326f43d45c44cca6aeb72245b55ae878058a5d3c0a0bab499227e2fd60b42148f5e99815a1e86611b474e6ef178f6d38278b4054be355cc967ba8b4733e3d0d827152d9a5fb4f1d926fb6de40de1591203604397f899d887aabed355c25cb21194fcf4439c769e5ba3158230fd2b3896be4507a9c20b8d12e3e22e2898f16a6f26e1320c21ba8851b947b6a78792b8482b1fd20c781ccdfbd2a00a5a0a50fb02d2e2eae9a1c9c8f8a7bd14c97d4a46d89d502b30681a9853ec50c1ab0531160b431bd2931fff6700653c23b4fce03c4b644783bb3dec245894d3b26f8f5907f71de7f409d090fa34ae8fe783c36ddcd5ec05992ec767e0fbb5e2c610d56562360addf5f32224d9f1476e201019eebbaa4717c1b0e50c7ef5876bfd479cccd61d195db0ec8f4f822c80dc8f3c8c9634e2889317ddee61f5ff920de16fbd50d4e142e74b53f236fb631f467161a911692977e957c00dc37ebe204d045cc8e37a2255f12f29eab7e98a26863b86848a264f412b82ccd71d782fbdf75563f7557c14a595aaeafc67a5a8c297c11dba1b66437978d3eb8af62f00f6858965f6c8ded66350abcf3338897d4af3d0e79d03d271acae7d06e3e180677b0a71ea6c75bdc80ac2c2914b5b2636547eac619005963aa9a1ce19f5456fef826d908769c4c13987e222c1fd9a24eded4e4bb235518499df8b9a8e7d2a3fc9c8a1d586ac8c0ce7236c3f9f2111fd3fd4c93527bb5bbaeebaaf4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7aced66eef54fd51977ba2fbd89de556c66e966755b2748f0ed7977d51146d7b3215e04f99f0699d85e610a4dffbcc56822b6405645d367f0e36537722be0dc2d88e6ce1b4a550c194650cc59a494ac51ddd3af6bd2b607421536e800ba573acc0c9c5e4d4db55e39042988a096ba0b2450d5bb401d371ac0e6a744bd473b10b7ccc00da0e44a4d0d6e8daf07d9515cc4eb50a2e96891a64632a7d2bb7655207bebd89b32750f3de2224eda1a6b9eccccb1347e6dcdadc32173e15d491f5caed44c38fa2788c9448499f55fe937fa43caab1c057f2d0b348399332fd65cb7ca25a782b5feadff96b827e00c85e48aaa14add77cfa74518e28cd0cbbe112713e57bf7e6ea71584e2533bb43a296035cda280e8fb838c338869fe5bb93c77b3217a82b0d9f6f6a00bdb1bf0eeaadd6bae4919e1baf94feee403c59c892d8d18b97e1bb5a20cb0b53708157d93a68cf979ae31ee5f29854976512c39f63dffa66196ea205494ffd659c7de775fffe859a8234ad4af2cb0d125ac42c0e013d3ba80ad269723349ebb2e1109bdffee9083b0b5ab36d92b4e3eb85d960499f9beea71d6bfce0a66618207c96ff6ac43dae57c1db82a6e1abd2559b23c4a00c4acf7758687bc78f7beaff9361203e06e5a8a50aeade824bac76ef0abdee74e9863b4965da7d4d2cc0122d6d9a86eeb4b9fbf9ebb7d7b99e0e7eb00c4146d2c5f2389b8cdef3da9db9b38d14bc0bae7f378ab9e9fd99b3405bb0353eefb540df75cf671cdd25b5f727faa65564526518b888368040f53b2f2a641e562188c4327674cb56432c054a2d9926dae563a75b924fb4b3ca5e91a35051db05f0ce5861682de21435a09b737807033534201cba658d11afe46a361d3c4cf96d4b19db4ff53c0552ae8b2921b4fac7cfa704b3d68ecff2f3359767c1d3f0680a627959334eb1da42706ece6455f0313d264980db7991d92799e2f5c3f811f8c5381f8931b2fbb9b5e06a5857004a2990c2f2854df776ad7eb6bba7c2e95e5c265c96173b7d8964959a00982ef045fb5cace63dcf07d88796b57f9d9ffc9a6dcb001865b540062019f7e1256e3f78ab4887761192ccd8e08711de5286b78de6552905450f7a1a2c6f8e24c65b326a0639687d996ce5b346256ed49e56141cfdb41342d10a92e7cba88d96b4491696d72a2b4376dd5bd889fe030958cbf9666b227abc1afa2e924419a4d2f7bde358655650f1e2f6647827c45f3a34a0690a135e4fd4c5535f0f710e13482f4878be6c301ba2f8032277948371562442dc6110a11f384a7cad1e5b36303664d0bb603bead8e7f89ad74ee424a9992555f991897bee883de63ca5fe53c9b389747e8dadb737b630abbd896706c0a8c8540f6a9b57fc2b50265c096ef8a93f44bccb23cf64cb3155a8305ed42e7b5f2d4c84c2c44a4f855a2209343773ee8a473c8ad865dfc1aff50cea14ade7b6fcd1542cd825943cc47aa221807e0a9f8698f3427423a44d0f3d2e39d67277f6a54fa8b6888cdacad7b83fa6bb7e68c54553392db3d7bc287fb82aee12698df72d2a61cb6806c6c1476fb8d1d9e904dee4fd99f89b38889b35f769e0a5bb6ca533f1082874ea8923b1abbece6b2695d31177de3d88bfabdd183df5e1b2bbd9228c7f83f7a96fc73afc3ef8cd9bd48e09f9674e5743ab16fe059c145fb220a613291e89ea90e988e5e7d18936d2a82ce5083b217ec2233a383e3b47f6f90377337037c8073958534e502a10470e2ea3e752c070777318a6071e02461ab2c4e7d7586e04abaa06ab0a9d07f3f2f0fd7b22b99abb80378e32922f69b71f6740673700892c43d8ee95fbb5e8490e02414ef4504cd5c34530468f793f06040371a7b1ec73742cf245ffd59d4590c4b5f38e7dc4e4f606508ae47d8327f31f8df61f222979fbb7efd865888f3d95ad46d396266524441d1f1c1f9b4273e3236b485739752717537f13fb599c1fdd7001a35d6485a852218506fe47a70e820a8aea2287613bbbfba455fee190a61946357a61702a0f79ee20eaccf39629a0c45ba513eff7fa5275043b30badbf297c11d7dde51072a12a7ff388b707144108a40aa5ea2420e9e5ddd71ed461474e6b634de21b1f480e082d596005ed73d7633e2c370db82c74a5ed076b82d38151df778c0bb1fc1cc2095d069637c1de60f5f6d11862f570b38eab3f0ff8f85797077609edb83a9a9f4a80a6cd739891c53642981bd4ee6e0590100da3a744cb9f4c4a1ad33467b77024baeb17b494341f8ed52ad0197601a04f30d330a53ea20211eb856257c4dc38db1e54311e8c7be14674f2a47f6d3eed51a5ef154df30e5e8906e88061df73321d10409dfb64b437d2448dd44641c35d00142ef207cb5946ee8b37e0dc13b49670cf9ffc67c03c35f6002d312c46980d2001956658a34dfe3bc0945925dbb022645e1b50d8953c12b763b8ed6ac4faadecaa092d23beb6c01726e1db1f8d27ce34f3946cfebbed70fc110bee6b2aba44aa90981338e329b51a55bbb4e90fb98acfe1cbac81c3e10395a4f3435ce7e47837e51dca577441c08572550f16ff273553c1b9d7249613fae7df75221fd403f84625ba96d568f10c101b903f7baa2c4ea2292d819d54424311a9781138f0ffa24a6baddd6f60b2e3b965d5c05b73132462bcca8892a5669ff142a97ab7acbc38fcec1e5080edb94917e8c1ec6adf0c3c62bb5688f8c9f4df92f202264f65d7c904a66ff7e3e40d3e52f0b1d70e5daeb89da356ba831c3c8a3024ab40a3cea4a0f3c002286b623e8d6a9b0fbf559a259fef769e12f9c01a9acfef3ab8daadeb4a2234d8e77d7cc3587d68f596eafa728d5d7b0a802ab1666cb578dc88888139b5ac88d6bf0bccdd7944e3e3711d33d15ac8abd3700f01cd2714632cf140617a1a2a7368e1e550a7114a4f25218fcdc639d7f5befd04dcc1847317594a305118dcd1b0e07ffe5cafc4433d7bd856985ae03977fa4590d9ae8e71dd2dd3d999e40dd989f7946acb41a6eb2b3ad3376be912d1e2596d36449a94a04914dda2ba40a033f1768c8427a412cde648e8b8cd23862560bca275dae7bc206c08c54f97a031b60ea4f526baab3bcc091bb4e05c50e56eec5d2208b8619ca60dc4595b432650a3def786bada6b7e5af89fc02a74249a2b016be0c11bee747860f59034f168fd20531b2611c9b24db77a0978d9f8835c2b5f0d9fd91fbc94334653223b341f3c75beadf441b44019f77e8c34a73db2bada2644eaab5295847da3779ad63b1d1b238ec02dea203fbf5d99baebb9d4f3087ab4dbfe04264ac292c33a8a9fe5a7eacc75594e3710438b710485c825ed769b4ff3789a55a94905ebd34af420737619e8ec7d346265f89a8eaa9512ab0aa92b0cdfe27d0a7845b0869d9a0c94afe87a201790ee2442f14348e39115d8d7b2c48088bff0e354f992764ebcde5e32598c6e5c8ddbcdf679dc4a7d78abb39c537b39d0d65bdf355e0c81086a55efbf39e2f5cb5d4272e9e6cdee8894fd93dcaaf4f3063b410d5d2a6d21dad3d1593d53da2f0e68715d7f783628153c19383941c514bb15529270b9a5062f27fb125eb8b9db96990dc87d387f066a057cc04fbfc827db4d74951e62e5646260b3ab9b99917977ac9abd833936c3cfa3bc90d7bc512331340aef4e7988365ba127124baa10884cc00eb5207592f727c1fbf29f0515abbe4bc7725dcda248f3784bbd929a96830853c040b2383b77ffd5c2bf71d684ad268445772b1af8d1235a0723f520cda76bfdd4ad4366e030f78a9b7798007450a15efa40681424e1fbb9ea5611f23e6b34ea59b4f79c4347df8899e351fdd76bf4ddecbacc6f851636794d9f1b7afcd5ed6e192b1da54c16b1bbcc1571a154efd1f95ee6840ff4cfcfceefaadbcd825b781bcf598c6ca3305af2965e198e4d8dfdfd4b97c8fb851d421d01afbc265a1529b7b4f53b30b72665f002ed0bda26420dfe6381e6aa50d1258bc41f415a889be3bd5b060c1887d8eda2c39bbe32700e27958f70ae480279de733b44d22a7dc5127460d2f18840c102c0a8ec89024474ed70f2bc5c597e5225f50a2a548affdc5650a42f5e6a554a2ab9cda89dd6d2a6cafad50adb1ece696503ef2e52dfca6526a6096220ebca454032372e3d843f89da737202209c42c382f5635537b9c3f761932c381345375a59b010549a431c0bf863d07eb109d2d19f4537cde6695e8b9a7beab194e211343cc1c74fd002a87d3fb481ca7dc53f6fed574bd6b83add6ea6fb74fc011aad3a42f07aa3dcc1ebe598a5073629af885da0b09357dc081f3173f8b39de99d31a45f0bb595708f26c0e83a0eb7a17e9b0dfdf3ccf805bf8ac0df36282462bcab53fdc0f5c7fae3d99f7a5708de11147867fbad0c229e123f0418d095ab08757b38a22f058a28589ae62abbb468140599908b29a66997111c7d41d49be7597ff1915de8ee68b513c8092f88691b79c7832d200b548895aa82c96c909b3f2479ca1dfb2fcc91a96ea4edbf06cc3e347d30e9da993b27859b3e0d06ea9e5e8d61ba73afaa94ee5a27f60efab95d53b750416c68c4499cb1c97abbf698b7388b437666f252e2c480fdfab5757efad9a6e3e07a42873648b5ced2fce37ecc24a07dbade68e48a95a77a71b134cb8ffdca77eaa6b4b71fadf9f851121085b350569f17d52239403f2261a3a41ba0dbb20129702da2998c86b793260aac1a0b99c3312874f7c852dabae955b65b43571e1773dfb03ef56373a247447f574705bd7b36523f35fcf3edbbdeb52cf716b2e581810d00ede990bee54057f1a9a5bbbc1af5734a6d886bd555946ead33a86b23bbfce6ccbdbe380305ff708a9e9c53ada8b493bc070bf053a1b3262d5837f27db50fa2ea631dbd5adb6e3ad6c51c6efdcd65705ce7bde5ad314be5f65a0d84ad5ae3d4a8ae942e9d9ce64c502a488a3935626cb81719c5f20086255b8ca37b1781c843edee1484348aaf1df5f0ae9fe84e0cacda101b4c74da2b6ae0461e9db5ab197f783d713bcede07b9d7f7499c2ed467d5d1025bcd490152bdc7301fa81f4d93c3b65966c31bc619a089c99995e81d87949f6fb00f7f30297e599f141a1127420b6d3e775eccd6bf7e293a520664944a3539c95df5b168b1fe4b345cd591e1ad7322b7fb283f0ccb5f48af3a453a32e5bf8ebade59b13c4ad741a0f85804682a01784e2d62312c9effe79c43016ea8e692b0c7f03598bf5d3bd78710fbe9b83b4217f0ff1e1c805c12cf0e189c5b1f20b3dfb076a1bba0d800ae372a610c930ca8efcb4856fac8d2bba83eecc1a4656c393fd034bbc61974afac0e0d691903feba4ad68bb38bdcf521b143fbfb427782dc39d9ddff2d4ef0d05e78e1e4598e7f1201681d967ef1671916bfda56874c6eb6e63628d2fa74e4ad8214a9d73aec0b1cc98aaea4520397ae312149aba649dd5a2f0ad3deba59d7cd205f91ec1127df1bf12d428c4ff53ba4ff2052368a6bb344001a918c6d735a3195201d35866cb571683059afc17afae48035e7a49d388a75f03d60c84ec12262b420a81d1c76518b4bbc1486ae5cc710458f5e75c10f9362a860b055a493e9328249b4f1818f8451c16969e25bfefb809f31aa293087670bdec3f78bf32efb18beb8a5619ec08cc4057c62f12d9db7332f7f31dd1b9db17e706e1fb31dad32914ccf38bc99857159a631f47755b2c1d6ff4761674df21d180540d73fd5ef3418f426e28f4583e61769706aca7b766149007a65b31d6b8af5adb74f0828c5a52d0897dc6ceaf1ec4e0692eda55d03acf5bffaddf4f2fa5a61cf374f11787f6fb625a22d39e0430cb3d17c8a8b000c0a0e8b8c232d615c996927f2dbbf4da468b17f526c68541432ae1c1ef176f053fb8d290d3e8e8d14e783b5bc99988b28c91cfe580c3502b5c496e084da1c6a594ad9049a10641a11a6ef39d13981d9211214ede98d53def13da42d617ebe1542d719deb20302d288bfd399dbbe84706400e6069f74ca289ad7e16ac21d2f5c919a384f85d0de07cf86ba22c353335fcaba6efbb3fb6694ef8125cd98643c6d10eee1a7405c179712f1f5738acc78148cdde3025e6c6e1082847d8f3d96f7a0c16549d1fb01b8a68175a2d2bc2fa2a37f1f5ab8f2255c4903071984a6a733e16936abfb314cdf57ac7e3ab6967e06e280b18f6a8b2787dbcc801947969ffad56b3ed2aea4bdbdbc937a33b772303810efba62444afb9ad9e57295bca7856891197879e284b7813a259f88667e65248de21657988ebe3a95329f7c85e1664b96a33f53af24c8c5467260f7ef86f1149636c66df1ba2ebfd9b7cd48c88d328b4e946b15c867c5a02f7114d0ed5acbfe2ab219422ac69ab5420aadf8980b79959b2a3064dd3ef63d79ca431bece44df6cb52634c766a4719fe3c03b48de043b24b75afab3627daba1a52dda979ecb9bf6417a7f4a89cf5ff1ea37b1d4c5ca89032b662ca4d3f3f2fa6dd50c1a813e3fe9f2df4942c4c5a65c95f83ea66acbf6289487bda941a650be5b6145d7885a632814762218032587697d611b400c253ed3d522dd12e10f3e81e579a0008a90c1d0dfc0541700d9f9cb29a819a29404af434ee1ca9dce0e1aa98fc18c2455178f475dd2ff5ec161d5260a7e0949786c4be0318505a3cfc1e4edb6c1c589509bd2edf2c43f6b41472ac224f3f8f1c7f36e067c0527bd46b7ac656ed2c604a0488c32fb8b5d573a47b833feb8429c7b1721931a5d64831df7a91fcbd3f57a92ebbfde870faa80e420fa7fe62a4c747aa259376c5ccade562c113b4766aa8f86c7f99ae88d3987c0b05603466f81fb26a7ba274927d86a4598784445531c892ee18df3bdd0c193e42a84543e20c1c3a8f8642eaf8635e3d8f092908f4de87a3e3b72a1705a01e28c4645d757424a03046655a886d9f1b4f51e32b30b4f436fb9bccf482f4b92f19bb806843bfa2afdf9fee12047a71dddc7c8d56e3d06f14ce2e0b9cb7e7b8314c1d43d525f504eedcf5cf8b52c8f556c810daa6abbb6b2855234db8ce67231a4997dec368391db4b256920e7ea0f9b499bab1e85204ca3cecd7d852dd3218014afebe282638f2ddf8163615eace08db1c217cb962f541921d890db8144d8ee007563668c5cce8cf076472e491e25e2df8324cd621615e34818894d0652ce3e708bb8f901291a393d5038254cd2e34d35972acbf33252e6a935b41af6568d5543989c9511d3dddd04c3b5b6fe6c32fb2faca26bb72e2db957ef70c291d13df6e6b4bb2f30f18abaeb6ac7e35e0a62b42fc94a609a6070fb1f74e9b2ace1be0e0b67a5c516b373c2297d4c4cbbf04709142dee78d595a4add6cf055f87fe61009451c9f1dd178f5080e690b10403584c49d1a9e06755743b6f05d4e0c0d22e24d4a9093784a42e7f2e970d43851e4ae2cbfd2d9f7a35229c0fe4879c6db781e2e5970cc5bb408f49f6738ec7a84c4169f6536b69ce4801004e63ef2e472961b7efd70abd3bca3dbe195533cb9d202e989a1b8bb86f34426c4020ac9a7693a0c013fcff6606c74cf9d756075d8fd608fbdea85c911fcbafaa62266c3e0e3dc1a6f9f8bc122563a56ce407cab3e3d1bd55668437aeb503cdacf00b7ccf8bc959f78aabcc4a99b289586f25a347f73797687d56c88e366f57475db79a14f02af80d66bcc39172caa780ee72580a0d15e6dd78bae9b85639014a846ad77b791df7e0ec1c2325642bbe6b6416c732022583674cb31e4134f6b80a570149f246c37303313fa91b809b4af4a3d8c84569e0d9778ac9147898f4ddcf37e7d2b2bb223977b472b519bdbe6d8632d11ce3d6c399cfd15d7aec6758decfd1d375aabdb9e70f5726acdbed310fe28012b7bf95de6b375b124057970707c9cdbe1230bcb9a360c541368c6eeafd2ae4b36a22d7b715e87120415fedb2322792928f1f00d8532b586db699386c3d5190fff91d435168f98d15d1f0f9404c276011e1596eb4ae00f929dd88c5d27f88538f68575d9d727465e457fa4163b9bc03808f99130ee7d9469286a3f3a7d57b0e237b8a5efec6023e6f2b2031e392388e6adb445c6a1e5318bdcda1ecf898655ae86cbe2e36c1b299f55e04cfb9e47d014d343f719e05b3c03d1283278bdd7f4b33666621cfb732b87780a7ec9d11fb20cb212ec00d8dc719f29c68757e4aec2a92db4b984edf1c5de33a08ef6576a8bb052713c406d8dc19f8c0273079f7729ca3f19b0947dbf849f8061edf14606541141421e8bc0b61e673ad53ec815abd3a5eec443d19aefa15544c67446b5fb426a7cd7031a8fe50f1894f81b2ab25af2bcf843c1e9a23dfa34a50af0f22658be6b39153971d6358c364a34a0908c9661501bc7e4d0d5716a7bc5160b96693e580ea2ce66b910ee5edd4b4289efd798d55dc3e561423d30d5ec4fa053b0e07346cca1a6c1de7233afa88bdb78dee708a1dcd8ea2bd478488477f80b30d53b8458683d3649ef5e5ec82f6adc1804ecf0b2d1ac40c1908d3bf7407f6d111be38944d9066b5c4ce78987d5985eb95e310278736695b0495148111c234bf7a4fd96c470866c172507a20c7be6e5abc5ec940f71da0bfe434f3389499c6340018aae506c02d57775b627c82ad8cee7d950cefb83c6eba57257eabc1b4c6429f3ce5f32e279c49b44d059d42ce4a97a597fd1eab9bccb41d0eed8988f2773d5fa7c890bc76a821f4dd5c05006ef6f871aa38003533f18901ae3eb69f07850aaf9b0ad0b77b42fbe2faa4a36b83346bd1ac2a2ffb53e2eda977eb1087dee1dcf196310512a47fd98ee074facbf2dd92711536933a653bc1913146b52d69acb4300334a229d235ee0e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

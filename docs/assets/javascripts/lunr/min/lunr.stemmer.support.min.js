<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4909d9e1ed5f7ea9d0b0d45fe9afe9cd9ddefb0003d352cb2bcda90ff55c121dce0ef7ec75f6c7f7a03560422db5149cfb7c98306992b2496a63b6b577032abf7220e044b9b4330c2f60cb56a37adc810bd19f7e448c2994e7f5c36b641273f554d5bb91956ce98c929f34771a8075afc281d1df37b3e0c9e2c01e3a8fb64a9c5dbd3e1f8f336585153126d6c3a761619d5cb382763a5640b90dc34000f8f43f1862312b483dfc3e561ca85c3236f628f0bdcb787fa8dee2fce5886ac74c95f771194ca30ee1d99b610328918f6effe6fdc9e3b3ba1edc273e75318e960f16cb60b361de664de0a35a633a0dd5887c75063838dccbf619b5594744fbeaab1a9d508c25056ece1275e3e444c4281f966a255244d0df9535109caead695b8ea0a1547409bcc21c9fa75b9473f05b4b5bfc504b53b6ed2806537bd223eaa7fc512086b50827b51cd02cd12c2d8939c67ef9dd019cbdf4c065dfcd40b283ebee2787f7fc7dfd72b6db5a125b07bceeb0fa2f859d689f65d70c201bcd72cbee59e9870c881af326db4dea4d2fae3cd8c35f940864fc25f384f4849365df55ff03fb795b1ce3802bca2d13eac2c4729b2f5b68c5937b120ea00f01fd8966901099b58bd09b97f0cf566e82f65b1d60b0d55561f8d701fee7e12c1072cb3ba82c1b2058da79a64699d63fc2e4d8b62e0a3a055eb9be61c1c0461a8160cfd0914d1ad36b040a3ce58f16de49f07e2ff11c41010bea5a60cda162303b30ee2f116789bacc261ea1545d595dd0f3e24a4804ec9c19c1bc7944d8553c130055a57e7002d3b36695821fdc41b60148a13c0a8987163f5eea5203b7d4fcf45356ebedb1c671631399cec21184f94a96454f68138dc239d682496d16403cb27546078b0e0ea3c4afd74c82e47754b152707a780d0b83008dd9a565119af07b7bd79706df8481bbed5b8cf81c42f92c9a16fa0f9286c86a768276abfafd76ce565d0ce6b451b5369f296eaa08ddbbfd344ca680505e356399401a68d50dffb0b41a3f6e5cb6074d6c337fea1d41207396e55959fafd90ef3d9041df7b8899de29815bc420c9ab82cb8bb34f50c953fd2ffd61de7640aeaebe5b191e689bcbbff20cd0ae3edbf277929f30544d7ad79d7cedb2b1699d1678f5f1ce7ff325d0c64fe0fb487e22d3e2f528c41c3807392e8707df4896940f230620eecec002fcbbdc56b3082d501d1d70d58a72d8853b762b8561d4e5d4bc210d5338e002a3340ac3b6738f44df91bc77d377e730696a1ed22959aabbf28590b2bb546a19a53072a5bcf398b746b9f4fa905722babbf0fc31cdfd64f20829293c32686d5a0f5b23a508eaad8a66396e833fed524b8c04c67aad8673e649dc308c25364b2e1dc66670172d38151c29fb2bf6ea037dad79c0d21471c32d9c80434f0fcdac8198ecf83403e3b4dfaaf6702c0789ab01b96273da618bd55082cf5b65c1818865582ba611f2cbbc0d065f943dd2b37aa030dd1faa9d50310c1771675c47c345f2f5b4cc5d0bd2e4e461b98c75193090372ece3db62b5c6e3f7a1665c93b0d93dba1e0e2905bf971c501302c21a3a925f6cf87904b85ca5d9e9686c29b8e17728d5482dc7506f5e34e033f629a7595ef09715b25d1335f0bcdc85d9189fc712a3cd422e088dbc09a61fd12db73d22bb50069aa18fa64234d60da84f5da55349eb58c5765d3723d0acf0d8d632d1c70b70518cad208cc49ec4d1bb273ab21b3ae6ddda488f3b2c17c357779b400c574f4965766524ab101b3cc7e90b6c3f9d51e8acc45eb0f88b9d38f8d495c294de4c66f8637a8abd12924700eb950c72c5918dd4115eccb1ffa95eb43b565b4623738c1b198058866ef5ef31f1389638179e7b2e4ebf6385de585c78584c8e25887a321915f1a10633f8da881998ed29ce73072572fa482a74cb171c96f4c741ee42a99632c54c4fcf58a4fd78b7e8bc7d40d0eab0d216bff61e5b0fce08394032292b390e349d56b924da07ab129042ed30b9f92d6e8c31ec11ea7893c3ba246a561545e803fa3776ecf89c3ffd3e235e1099102e45e327d3e7fe856c8ddc4a493c66094cbb72a4ada88a172b7cdc8991a48a1cdd0b5a6fc4d4976a769caeddc9ab0a1e061e1fc504e74b2080b415607e30d566812da28337a5f48b591a6ccfe4beade76ad9405e2ae4ba880f3d091e39a77cc3702c2166cce4b52a124e71022919226aa7960946ef3913275b77d0827b3092c558f1ef85a84ad1e3e73f35081d393340c2108f6caf5b9a174eed83ae0ae73cc0b8c09d0a0bb91343d217add4b4d6556d43f0b2fc3a029164c7b8dc754902cd298aa73b7f35640002e8ed42b6005bf0ee7f7fa50309fc7f3e9c6c73d47de7c444b7878d213028289c344a6485fe46a1ed61a7030ab49e4950beb191312d1419f43ba743f66cedc70aa39e60477bbf53c22d0f4b58cfc7f3e63136debfe0e615e6f96caa7def590f8a02a254d1cbedb5daf1f1bdb4e479e4dff8ca6a7274b782dfcd0700bc41b11ef7c1e52347f928c8b4a7387090c3cce85a67310fff92f11fd365096b796605d4da92b2dcf6b836cb5494a1e97d51a87852344a3c47dbeb731d49795626e08e418cc113ad346b4ea1488da41757f536c9fbe199f98e9467d89c37d123a095f1a35ddf6390cb0bf1aa8bd996add4fea2e6b6127d78216379ffc691fda492805755f4005befecc227374f94f57aa63c1dfc2b9874de5e7c9f136c12891f1bb868b388fcccd991e0586faed40cc75d8db6e9667d6918d753b3976f4ce8aed2ebff7f0d78ab9e2ba82fe0c1f874081b63bb9c874cbd19ee32a73c7c307695b36cd13dc934662de0d064dfaa988db823027ea847c83d17fff5c0c30d991871b5640bd92be07a579be6a23d83c301fa3324248bbc104f7d664f093c4d6574a5bfdb452e0041bece1cbcb8ee9d64e00218ea3515d48540cfc316ef5c360d43b2b14c6564e6e4b3a862d04efe52fb913b6fe4ef0e1bdf4cc85a43668e2f31ecb346f8f954ff6fbc919f575b91c38309f9637fcd7582819222eccee77e958462343898f1f9139aab9e05417fb7b7659a8b258c17a3fe6918158dee29661975141d7cbd53686006be725d165c9fe3796abc2aeda946c0c06b45b4c71f95e6000e2adecf939c81610b7bee21fddfaa0d20ab72e51331179f2b78c8a06a45e7f5b6f5af17d99dafd1b1a7a4a5ffad932ccfad90775616a5d977d0700523709c73384b8e0f614b6a4d819b9b86d23dae7eb39c330e8f114c7cf3f44008f641f0db6cab1c4a4c2f89cfe07f4ee5e0342c8e346ce02129732f13561ca19fc1f4cd50687ddb1d6daa23fd37151876c893804fa8f30627c0db7bd415fe33b2bc469a6359da4dc1071a44d95760eee128364bf244dcb90385c272476cb3d193d6f13906e0c7e3c7756ef40aaa54b1753053294110abde8dbfe65e43500c10d5f08d91148f9fb6b0cf11f82bc95e2453d080fca6724389685c2c3be9a05bd971441b555dbf6aa6aab288464aaabd14feadb993c8021c604c153f535dddc2461bfd638a642d922eb809c2343d01f34bf40114a91c599d0de3b9a8e2579f120cde42db6544f854f3e925cdba458e03cd00f8b0db57c1cce5bfa30816940c6737528421633a551ee63d60c8395ed1392c59243836a1570654d8eb102b6353d85590f0773afa9611992deee121eb67a78c85f9a8a7fd8a6cc9a3e71b2d2506cd8e8a7b7141402afd23afe2fb21eb4a1a8c712872b19a5cd227a88631539172f4739c6a08637036c61a53062a6747b4bb982f51a1b0708ea517405b179b26875b269ddfac4bc45d202b0504e34aef37eb648f5fce0833ec39edcec1a4c458a24c24fb5eaa9c980cfb658dc1077358b710ff0f632a79f03b6e5fcff8ce5b5db68a0bddd2017f4efb7dc5fccad3e7fe5345a0afb7fe2eadc51c4b24aaf77e8a1646238578fb789b0ef8242c9fdc7be3b81bee1d1ad37e94ea104eb4a50d303ac860bcd911d3855e01ed2b8cb962a4c13d8e5fd2aaf91e6ef4ffb09f3d7c113924a5aff120d8272f38015d66bf9e3b869f1be742844f5b79fe935f08776e025ee8bf561ee5c6ebf3cd923071287f5a0ea1c04f15d8bce76abdc8df3f1bb8c3713ac206d4191f91b09db07a30421c31f1256a38dffa644ea3300eb8d75d3613c4ca428b24ca18eaa047288b5730730d8cdc4d0afd0019753f16eb25bea29238dfa367978c7d2ea24039521852913641f18087e5412982ae822fd910e14d4ffae0e742ea6efab5d8912ab190422952ab3d803ea6b1ef632cbee7592567ad443e07c24d1dd329837761b3f3155ec42633218bf99a4560eff374754767a41a2f87b875c7181888fcec4afd4345c8acebea9d1cc6ca023329fad237be617acc220dffa9c282216cc84c52fc37b82b40fa217ad454ecbca6df4df5112622f38a600d5051fffdf82e7ba0d70173223072b77eeaa32d6a936df22ab2c7bbc9b2379490b73362fb81de2b36e6cc0cc3244195d97cba360e250d3c7fa745df108bb81c05e033888075b05fd27a2e9b0f53be47b2821a09bdcad6950f64097333c17c7612c37c7a776c0685d5af25b1671fd1e66ab8f80a976bb016a0342aebe5d50dca22e319850917ec49085e0285f7ff7f7527a9995728e2ff5425b892c3e71663f5e0ac7a7a81fd6e0fd87773dc5ee2de2a59eb46b5e2b985798caa0d0f348333f77d00a648b80f72ee66259300a94945c29d593990ea794b7cc9ff7963f32a883f40f9dbab741825f8aade72003d164476cc5f9cbb319c23703e331505353923bbb7c43783ec5129124389bc9631a4f6f906250844e279cd8f106ba4c960e355406840ba8701a223d520ae229eb723533224ab45afbfb9a357c5599609244084b0b59c9d083de566bd2aac882a1e7aebf71521a092d0a8ec336009b49e51eb58d55cb63b239d156cf1d199dd92e21a2a11264bd6b2000d41645cb6a918156595faf14a43c0ee9d46fc9127065cc58f056628de326380cdb9663774ec082059de2063d37549ccfc87c32692ffa1f29de84efe2732bf85c8e355f83303b85cb06a59e153b0898efc6e4661e239dc96568ef43cd72ba83b90fe3d42591154795b821f21c2ed4d0f9959952d6674aaa4e501885ad1c0ea65826f76e7b1eada214cd218e4212db38d90eb54d1e3d3704c823bf09a3371028d1719ca9db2aedf0e6f07d0b71acc9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"754c77e13e7c90b7200ef592239d201c3a93c542880bc554b9034c88c133b0178e5007dbd840c5adfc85d5bf3a8a0ed1eee6d4b46fe8508e62876f37ae4a1eb7808af38e7c80346fd373c03fb980e9713b941a89704cc5af1ec2e389ead5baa186ebac1d0b4c414a3dcf9ffe3aaf06e56a3e9c3b660e92f59654812ae4f001d4c672be3fdd62c142c77aae05efa6d4cdfdd6eedc3670d2c6d29605909125dc0857ae46c81d2d1606043078689f784d50fc8df7bccaa19d1b0f6f0b6bfeaf99b4e0b891f83c2126be0680edbb3a44eb8028009b1d2e8efc23ee47613d6f53af693a88138986d304d8988be99a4bf24239a1cb33511937e91d422d924993aea0d4593f954af0c53e2dc563c203f42a11859dbf7e33c6530e405662fb05767d81ebfd96d108b163685813416912364ccfd4f7da3a1781fe46d4cf4858fd13efb127cee54cb7dd85d9f25952a23c32921bb51e9ca467d2f96705bba0ce0d8d3081422bac94fa2bd35282778c82b15a1293056870ec62455a2b57b41e0cb87e5dfacd5386c87a8c21eff5cb4f170a65630975c910cb3660b0b92d37bf563b21d6673834e20bff1fc4bb06bd5f79e361e62ce422c3bd24b49cc6725223bff706c00bb0cf525bf615f4e01690c20760c2140e4a4ac2a4da3fd70760a6965049027fba74d77b5ad67de45ef4beb0c00d849213596e12b3a71a0908a6d73396776f39401ad2c54f9b526f6852f222e7745c66320c866abcc1cfa82657d33abe6e7eab02b6c0affa3c72f4df0dbf2a05e1677d6bb0ee66f92fe6b34a2ceef1ba4b4ec8fcc5615f7b7288ea6092bd3af5a08c482d51ee38062d0679af83e121171eb4b81679a57da89ad5d1dcd50c0d2bc27b12bce18cc16331be77988ccf1ddf4bc567504ef52dbc9d0df46f2c810901ce215696b520ce87815ede8a74c0b62022dfbb3c1d99b204a50ac18be733764e3643f06d08df408ae8856ecdcc32a76abb703b93a140584d0b66a0103fcb05067b7c7d92342eed622e245c3d9d6c17195561be8d416725a3625a8c6d5aff5bb5019bea0f242d9450abf75e8376f3427d9642b4e9287e238a066cd5d961eaac2d1d2f6283c272a807b54df1148af133de20dab2b5f4b79388095da8d823876f0fb49b668e50cb5a21ccdbcb954d8579ac28b8b4634055731174ba87949e69e1d10efb66999ddb40a8eed2ee45fa31638f6d0c7880cb41070dca954a346f00da286957431039d174b5360a15212721d50f4fcb27c6b17b27533a11fc2513a1706196d9b007ca0e7482d5573722449ccc2b428cc1fbe702448bb9f6a1f8db9189477026a87ecd103cd42c3b91bc0e1d1896123154bd536ddfc3828f9a273d275c2c058bc1d62c055a4c0f1de3debfe8f9798ced3f6d2bcbad4e6bbc28ee1614ccc958510129df9414a2989ef129875052982cef72e6791987f1ba62d7e0bd8a81de21f9cc99c4556870655349e18f4acc5e8631069d13d6e1d3a6b8f40fa479f077293f0fd7241a8d93d036b29bc927c55084dadd7de24b719194f42b4bd7a829a515badab2a161523f8c07aa9db93bbb83844ab11afeaaefde7542668e7835fad3077d02ffd5eb09936ce500d446de77646713e5f41fbc6bbf923c73eb6ec8882ea35c708509ab2418311862b1badb51dd54d8df20f2993ca8d2ded51b0f83969f16cdfbc44dfb290df2ac5feb35aab95fe7e1e5702cc916057a9a2c750c32dbd3585bddcf7bd7fb46b792e14f03870d70032d5de649db933adb3555d4f629f5d6086a0512e280f34cb145c1f56855bce045a588c8fe518f05415ab49f82cd244de8ef99d7a7c1fbfa43e9df5161bf343930dd692ebab30a3db76be0acdb89f6730ae771d92320ba6ad5da23a6dcf68048da48c56323684d2a7b8b0d2b11b1075d950f21724f631f03e2ba2cd20803c34ada69471251d4669523c9dbcf574c38ba509b88502672d07538531e94016a7fbb1b1fa716fc7d2198e4150634e71acf9ef33275c1c0a050fd74917d956ccacf371cc6264f36831a5bd09e813fd5e7dc780335933f0231916718402e16ffb8657a9e277d4f58183b5540fae31e97175b0e8deb3ad85c2791a083b3ea2b817d9391673f546aedbd0d530246833fa7481521b29cea58aba4e0c46c611bfc05dc6e8a1def9dcefb4b22212bc3b105536ba7b6ccbdce506247d069d5d0809dfe7c1ca899ed48b65a850cd854be7e8c463af5f18f883da2b1396e2325e6c705ed903ff596df2001c3c4362f7c1c37a786bc008d7c6062c0c33f28fe463b12df566db3cbdee5d0f741da2bd4329bacf7f1ce3c1fa8aedded10bce382bf531a654132a6f33b79ac53b969a5714241430a0b61f7c2727c51416f0154693bec4b667275bb6666e3a5faddb76fba26d57645298bf7c7381cb5b9c76bbbe238601a5e8282bb01d7927d98c8bd6954ea5d58bda11b10f8a40dea950392f9a98d96d6bd77e97b2f90c9f84ab743eeaad880d17eb1f39d44740f889be0c9b4d94776983f9e7abd73e0d129f87cbdf9f28bf84b84b6231e4c322242d09859a0a0c8152a786764d6347d4c7c4b07827ffb15c6845f6d69ea7a64ccd26de88934acfba6dfeec8698176d9b04354dbdc342f94a95a70823fc78f554ffb082fcdf472d55560bde575e553b03d862d0eef227db313df4581b1fb8109f2f5303f8d497c50dcab44b623650421a7c64ae8058c92b481de9fa8e55b87fc343f1caefc862f097742728bbda67a3f820b173a22c8d7c38fa060765025fafdde6e032b25f3b635223c478b236652f40aeab1b3f62845fa0811d8d810d1f8261657b91ee997a82f64d204aee9a874d2e0f7fefd64a548f0e26956ff97ebca81a9183ff062c352191a06a5f54ad234c18554fa3aee2ce478d9de40dec35f87b690dad17e02d9de486779f3d2f644575af45c0572674fe413f7a822f4522692a6c540ac62398b76733c9290b677da3750ffb071c26f90285183b3c54b37c962275203b71074b94a5fc2603be6d317cf6996fa4bc643915757f0a5cdb35039cc1298dd454940df2e9746332c8dbf63452e896ffe077a490d9f5c5f5b5ec8dbe04709b19e2a027e57e527d005abc56ef941991a5530c45e0b105921f157b427f8f045d0a6030f76b9f94a35247d7e20ceb0701260d2a1c28cf7884309493def8cc8c0f085012089705e17ce192670da624285c3be7bf4a03b5be7d9bef9b50fb3c056a1d9152b0eb32b8440541e4d70554a3b1ebc8988a1e6f8b25df380b67c3f481f48c23b537c68585157f5719ac1d4fa27baf75a1864c831469d54638803394a9354104e17d7232b5387996c7eda72f8835ad369a1917a318bdd91b69bb21324f0aff2e0ee15e9f6b1f76f0af35ac6644084e745e2063269e2ac6d6ba9747b42adcb71105e8eadfd6a64f1c63eff5d4c5b2b836dea0888da23752f78c5a208b8375aad412455457767cfccf05011afc743f419a05dd1060dc8550f26a1fee6d5f303f1f96204b2c515eb553c76eb496358e9eef9a8ae1b21d10edb6aa415d6a331b4ed9572417f5f5d9f2a9cd53e823cd780973133060f39ded8473d2a3bd777881be32fe17cf740844689d35a2b5abbe710213b681dc59d10bb397f041fde21936d0548f8fe7980e520cf3f827a447c69b14ad28195709b227b585cedc6f6e2d83efbd186deb852ce08a01655d2d3c3e137daac13b5d66d255c0217f0477d4d8187db0a4de00163938ab3037bcf2d817a90b23cdb68186be0453a60b480c3f51c5ea2cc6e725b88479868ff52b0cae7347f4c005771f9512de2e922e7219d3d3530f2f56c09947376d2453c744f62153048dfeefbb26a5d4b35ea8faf5fc8b0509ab0d195c6da6133693b7c47a2a5f6441ad7c18cc60afa2cdea30de81042cff2acdc09246b1efa8e46860b9d4b11adeb14ad7c37744fd78b37e93cbe4513831555ea1a63269eebfd054ae0d654883bae5a0e02a2d68c5e7c76470efe1def2a286f5f105e4831cc30d8038ba5f0e2cc3222e878559597e6bf2cc72fec03f612f28f866c813753fbba5683899c374a6a51b5d8c6664bb283885d62c8e3f86e8665f0907869f60bb1ccc4db714ca0470d5e22ef50a962ddeb72970293d2c908a192f48f354a8d242319d8fafb40e9078b19b8b6ee6e626b570c2bcf649e40469482c3f181ea03cb84b098188795acce34a21b8ca9bf2813edff477ace87868f316796ba113c9769bb62289c432e35baa5476f0b12ae403d12258dba85a20c2cd3e922f1ecca29c344d8cd5d24d1f78832484f0443402eae7882f2d729546222fb8ddb6392e65a3ae4716ecb23aa3a6f6307188571c17e0bbcdc47b0292d8aaf1b18bede7729a3a60faacf86d64335a6cf4cf3b3c98fa88ac53bef6bea90126835499af01846c1d279f7fd191228b6d543afc1ef9b06da36b99c4bd8532c517575fa18e0f4459720d1f41cd23c4b65fefde3660644a5e66c685faf8a4bd5212d8a46984d282467cf4ef3d2ec046ea0468349c816b1946538c419567abef625e95e7d5ddab442582f49bafd3557c2d34392b1f4f176e28f4eb96bac3f279417219c240713ef764ce01f1b08bb031fba3e844bfe3b1d213144bd4d91a72cfac0baae9d75f634c195a28fc89a77dd51fbca730951a6f63800776c91c775f978a5fc970bcac6db5e4d41567b2e98d2c46c7828e310bbf50a680518dd00f6f8bfc8770a7a46d0ad565fcb1edef9ce8d5fd6eb59c1d3d996e20b36b0556d2012b67da3f44102f5dc40539f35b8a87255aeb62b7b375e50ad45aaeb6dc14142526b2c33b5085dc75cd9e9bc00124204d224f84241d28c6101417e3f6684e322c37a7ff7c8fa74ab782ad614b9adc74fc250d31bcd16d9ca81b505d08172176a5185b9eb1cace8ba9c6798137eb0a9475c31c2d721e7030880f8900d77034869067fa9276aa030862b77e579183f3709d05f3b71617d452ea6f04738145e50db890f8801dc1de850291fb54eea5cc3d436fd086cf235449b994da83f1494b906be1638a8b72197d1bf000f1738314644eb2339d74ebb9b755e520c0d7d7812fd75c817c0e4c50e0551a8c20455798a53c99a28b3e16d220ec9fbc645bd5c5ef20f6d635db843797c17d578c5cd3cf6956a700588f94398ea56cf5d704ff263d48b14a1263c6222b648f29c0c5f8eb9732989a03c1e64ea671f5756cd6dd5ad8f227a32e572b00e7326dead7890b334c67c2a836c353e42843ffa50ff508bab9c775bfb44b47bbfaa2996e925d115349e4c29f72392e9710b8a0c336c51667410f88331dfd9ba19e9545361ecdaacd559211c0d79b7dd375ee7cb0b859c36916efb6799ebd1d75d77b9502792204bc11cfe1ae747a4ee61ee8f469d4fad0a41df2e0e1ebeea127c5a08504c484f699819aff0dec70867e04914fd4c087f53a6623b6864f576c00761cba4c4e2a9298dd67c8ef87ff387cc43037e850b631913c0b9317212bac19c6450c44e6c6a725ef765debf6c23120510d678f3aaad8265e64f8c7f37f08e99601b82ed24cdfafc3763cf77bf25764ad758b8a6fb885ea719fc022bd17fe936df00ff2b05784a8d298a0be4edae06d0540074a411e7c823b3c5cf2e18de61ac8c5d6f68a9b3a1767ef5e373cb5c8adba920338f356a4f93c869e55e3e1cf577b04b560799d7ba3a4a996f5146d78c3ca2b2d56c7d710008807674887fa342285f92875e640957e41c4a6e1ce18e65dfb928b00c0a1033066760db973ef7fec2f17f2d690ba27df494ab8168766a30e5f89a10a55cca231c94bc71b2efa989fdfde06aa3824f96aa86529d923d37f130c7afaabea62ecee822bb32df51f51180af4c4f2340d80938b87827641017ed934b0fb82bbeb2a435482e1a7cda00d28c4421ae24993e6316ffc993361fdfc3f006db1a700084ce72aaebfa5364cf4557bebbe4ba7b55604ab1e48d0ada8ebb2b92cccb6a490fb9d89e9813302201c493a73b6cb2cf209a7ce8aa930e22ba01521da07c48e2cb6e7f9ef494934b3e191dc89bb9e04ea2c3e3ed9768b3f75bdbecaf75ef00e8cf0f31cbef1e0ae05c872d4fa6939f7fb4f339eb4341698e7bbd386ebc9b06e525ba52c390c30d08ffe5ec8f8d1f55ec9b2eaf6e2ec4752c108b1ee98f37a818c625f3086ac24d49bd140c6f5a6f2130841151a1a79814b0e0471be72ec18b9f7e8ab1a5291f02328379d5277a2b05cd76fbc0d5fe19e923a2d42c953d08081975d32ced650c62edd5320fa602973a90ff6e8d9bcb8e8c2b1d9098fcd6d6f74f922b62cbb1bca07d46a2f74abb01dc28903b1e49679ac959d2848be4e24da357dfea0ae9b5455df1b79a1f711dc93b98f0233c402c4dd39670a4c63c3573bc4843b36eb1406c9742908f95892088ae68d6f0f732e0e41e81179ce4866a641c8a46332cfaee4fe1b9d7c8e060c6e68481d8c089166ff4e9737cbe8cfbc12bddf61c77051f54f7033524aa44d5966920098c81d99ca4e3a80f60eafc92b09b0eb09a8ec461a1307fa667df3feb47c4f56fb3ba3f1579152cf344f044160db896ecc64e75f2176e919bf5dcfe02aa0e19a1bd5b05202dcf98db9be313f1e9dd1d2251b3818680c6d4254396f72e29149bdf224e6501cbf49fb3b0f771741a396fe3a326f0988fa5aa7576ffebff5d2076bb5ca29321dbf738f6e21e70a3592735c4efcf4d81e32299ea566e99d4955970f88eee782176a542b86163f8e0652c50428a0609f44e3bd5e0df71d8f9a88ba203dee19128610647153b2b961be7b1befd07890c29776b07e9e5e3690d236d75d4fab59eb1c1034ee841e9f4185cbf244403a3e43f40c74df7c186dbb0d40b9f112b31e6abb76824c7a9ee8868c76914abbc16a238d739d5380c8cc60a9cefe35f474c7ab0eafd560ab206143aa79ec7dbafa88cc94f0ad27091c215a9b64b350edd6a3a665ea8f4126d390f8069ba6f5b319ec80d9442fb70a721fb8e3196904748e600ea4aaf5a177c186c999f7373077b8251218d9589f9dc56eb895e976ef4b0048994aab7398f2a5bf11ddd15207214e7fa2817404fb4fa508a834a481c363871ecb1c5ea2f4ceafa1d54e5e3ca9a10d9c7d57b6a188fc946395918212d7caceec6242085f8570ee7b3cfa34150f03a73f755abe2db4d376350efc53e855f64c34c45629f719f6f0220d8ac6c12fbc9879618516ec66f6e1cf282010ceac481e766d9835c0afd8c3e70a4aba6a04a9c961206cada22f9afacdf9840f5e4dfbfb49d7987bd00729fb1cace66ea17a76aeee3b6bbf05918dcf2db6eee35eb0fa6881cdc447f488d4fd544d183be7151c56929dd09ad8802586993fac57fd5e17fd4ef4ef5afa87ab8e9f96ecd58d3ddcba7728a23b330418be3b385d3018576c69abd0a717659e9d9de444fc91934bb38647f626644535661d8d3cf89ebeea9d7bfdfed7fc8f9a7c3bee36c359c08aa57f188b0a4126f22d15af2cbc9403ce9098ce057c19300ea88fa77a48312b91953eda5c7a59e053842ac59d510d0bf08409ff88923f508495d124c7c384542610fe9fdfba331d2fddf3796e2b4cf8da879469ffd7e62bd475d7a7e5504f295ff2e7fef5add41ad5fa550ddfc7ff3a22ffa0d3fbfabb0d139ad09b1329eb99a7c8177fc304de1f878fdb0e687002821ad4b2b64e6eefb8df4e720d70e389d905a21e0e308bef1d99618a3963a35502a7b86429c4762b412d9206d374a331042e749f520d995ef15d2c1810af82a0823f5ca17e72b89e335f8c0b0396e0bb0316b47e16191e6b3ae4f6bc2cdd4321788d52c4d0816b3ed0d8b7560923d812582020c56945bbccf401aa56f6ba038a704de7bdc896bdd94e32db03428dce5f3e63fad2f92c835af8d1aedcdb31ad42f3c880e9d7792ab7d5c830b2242ae5aba3117f913b6d36f25a0d4c83cce9bbf527f76a987995fc9a19353867346b69fadeecace68183c54a6891b16074a0c8c0047da614daeaf666994e57a5c55f02a6af3e16d1cfa68325a99f6419d35545fe6a8d9efe8e3b74cec5a27a8a7000f2f231edb1d7441fac186b6faf030782f7c93b3864f9ffd9052990b47077859b21955356a14bb356559d9ffd0e20368fa577a11a809eb08f6aa457f3b1ab447705b734603016074fae7bd2ac238bdcaab407cff118d452eaf90bb29f873ec5a636998790b2f19311e644b40490e48e2bc8693cd58e31fb8eac21ec1acc35913b23b3735f872712575b6ef92fa36f8bdc679cca91353fba6a3016daa9dec3f43d9fa83b575fddd9ee428088bf608428583ed722b4ef40066bfab677a589ce19585105bf363ebd250fd41aa2caa32a91b698be467f5b875eccc3cefa68b705ca56ef43b808da26e2dcd8ebd39a52dd44916ae73a367d13a4a561d6e981fb8d68fa0239f7e842495f2fa6fa06f79cd3bb3e03823a14710a6347e4daccd66b146cce5328ebc38382bcb00df31c1030c9fa657e4af016e8f85923657c23dcf438928b4c9ae076906f943ab193dc377a54e09e1fee6070cb756c95cec51e9ead2bba7d57c1c6956423b296977d3fbb251b1c96f513d068955d013360dff686e6b20b3231a96e65e1dd5d562296652028ada746911afddfd78d3eb339b043422bd8bdfbecac3163b74cedabe4f7acd0611a11b365c4f484d6ba9e40fdc6aa1bad03d753f6389c8659d7b718505687563594d43e040500bc49fa03c456cb91bf70247b7f43e3b33813e676a92c1ec0dfc906a3d0924985cd5f47d40740ed41f4b22d8bc6db6969f6585fa4bc3d7dc90ee38dd04714758ed39a0c1ba04b3c1776287194201e4ce8837a0aaf51eb0ef7359566f1f4da3efd9b18e604eb0d2069401aa2afec723a756d1361b3e772f10176a921e882dff97faf7762e6707d42f6ee75f6c9c94f14cf04a565e021d7d678f5635a83e3dc9ca40e5c3e0b98f3a0127b8ca535412d805ef62d8dd47faa867ea9d682e53b4efec95695e683c56b5b26031284369e72980184a0e4d36a0706e1789595a820bd9105c60362c8141c23e08c1a8c077fb8fae7a4299956281fd7c06c5a758446b9eea6594352655e3ac98d30ddf6f862d5e2452b0c30a4e4513b4773f45e314f6abbdf0585c8ebf731b3392279fc485a0085f4a6da3b36db70afbfbedb98f0273f228712a25b12e4a0c5aa5f699d486da7d2635e2df88ceb860a2fd988f53689a4230b0d4f1fe0091a96b834bee58cd7f955dfdb2f910997a147024b6a1cd25bf8f4f3665fe724a617aeb2ac9eb2a4b5a3a491bdabf5ca7ac82f7b42f861c702b595c48f8d66918522a17e2c55ce048fdfb62ca36adaf82ec63ea455e3a76818d62a95edac45484ef7dd4c3faa936644ef8c428404390f3c1770f6fb379ecc0dffef7670df15719861dc0a08332e55effa3b537e5a3857c7493aff064f95d37ff63edf8ba89508022e775a10fd5baeee624a784eeadb60f443cb7804bc907d96812a84cee76b864fa70e0f166143c324e42809bcf6f25b6e8e37cf3b58d5beb0b8989b353349a357db3e216c23a70eb66cead70b243cb4ed8775c4aac2daef6b004b65cd22931a50efdd35937e57fa0288372096900b52a164aa7f4ca593fc1a50d26817f60f5e1b6413c9d491bb3ced65916c6091817a2d686d2e8817dba18644d0e1b6121dc5c568879d8a049e358f3d29f05a94f5a20ed3cd96942f14433a13a7c1170db3d40edc01130a083d58b4a426329ca0d3673ea3022349ce76376f4427c0441d115b5890d359c56c7c0e4851380c70e3d4a16494af2d8f745e065b79f6027ecdc2a613a7373fd27476d7d43687db504bfe543b1fa785d546716ad1ff7c4fabc2df4abfbd64a08c04b7a26c0ddab078067a38437a4e82868f77b9b4accc10f75315315cca3bfde10e542fed16f3ccf5b012246abfd15be9016d397cd11d7a7d9c47250dea53b193e263d6b4b27c1bad8643d8bba6d2d2bbd75ae3495e981e294764fd87ee50e6341a6dfa08879d08dbeed84bedb8b96837616146811a9f04d5bacebf5828f18c908a935dfe5de14b6fd91238d4f625559995a950e74e7d71366e8ab0dc533caa20c624a2c3c4a8b764d3528e9fb42ece87745a603d9d07c716316f20430b47262cd41b7ccc3b1fb444e763d03c6deadd5d5ac2f3c93c3889695483f29a5e2e27af80ce8a078f2d60b4e7808c8a00879bf01141c70c500e79bc6ddac20569d594e14351e737e3e27715d4fc1e5d1e460ecc22dd2c5c7c81c43f0fc21a6805ec61ab7c22e1d843a087c18e833959da05bc8fe70f12b6103d9a85eb40b218964b543030cd428d35d085b02aa0cda2590be7fea9d491f0ecf6752472ee4effc45e5b6b63bd38aecee7be91195087d0985cd7a003cbb4c6b7f82b18c5752e9750e30aa027a1cfbd27d055ded8a8b5876d8025501d7bc4dfd27efde211ae945e0348fcdff02926ac121d56f6a3cab3ecf92a25c18bbe162d0f1ce7c52aee0511f6214ab389f3aba9f772b0bbc0ba611d07bd8deebe748163b23e1604dd9c8070a46cf68626954150863e778eecd7a85b895664175cdb081c6445ab307fb67b09dffd999b10d454a1762e1b0577486ebc89868a4a0b174330e6e38de2204e430636d60eb9bd5aef5232dbac4d3ec34b9d633a9e7a6537b61d51259a64f9889ca246f00245c543cc229c493ffba8e5c2a46b35d8f227620ea9d8dd14add61e18fe3507e2f7f75c1d1ac1f3f7561a7ce3de7c4c9b72260213ff6ba5fc6a9b4e6950a9de8f6387d2d5d22ae02b90520edbdd13ec151711a83a184d46e3671d313b1ff738e53fd66908150685477e7f28b84fe5f8a592cf558869e9c32bf196871cc75778d6f70e02c5c15daaae8326977f633c128958eef5ebb8a1fbf4115c1867a4b48b8930a564d13a31cc43acc9d94103be9c0028a8bb32a801febddff23cce011264fd7436b6311686792fd47c7ba5b838b6536b26acf1a40b6fb83f65aebd650d2ef8073720b93524a69698ddb9da1acd3f70869b56da74b7bb1a5c67686cce8a040358c0231a2f27963715c4bcadbc42b1049b243a6e334772091209e5adcb5d24b0f21074b188f648295050c7599f99bd669f809a9f1ff85eb9ce977c8848f06c3e86d6e0aa13cbfa4a499c7045d27fe6b114d7d67c920f3e483fbd688520f9c0a79a8d3fce29cc35b59aa3a91d1ee9f1b6da3736e63612cd184c4c3608a61d62f04112328f9165c656498a631a3795d99602acc2981c9d0b363870647a3f88e47354f793fdd5e9b4dbd32e897a060ab8ba83d43fefce66f34f81703f42f02fcf080e5cfb227c7061541860c809e90d4374d61f74f7ad43482044c13d06c808c8d64175e1db6441c1dd0d36507d9028bb75f2ad05b27baa83da7ebf438f31360052d9d8417af00132554af62b9f1b1d6136c5a13ffab2b9930132ada02e8d244b41c51352c1b0bc5ce7f3bad3cab966ee236bec266f826e22058997da1db9eb6d937b9fb20c0199f800eff603d389bf7f9f1d6c35102e0c671ca6ab73ceb868100457f5ea5b94c5db73b32b0e598e115c34b210db758711e69f36537ef52281eef147f37bba84c4cacd0674ac3afb335ae9cad069cd60005dc1956a9d999f93882bae0e98ee9362e0e883c03888963219f5d946a9bdc19ee27869a0909f6480891380760b981cb3268ab0987a4a0961b9ae08e01db0449cf189be10904f433f1569f4efbaa284bbb0427e049988e15cb68ad3e6544262181afcc97a0ce7f0ad0c1d5e0f6f8fa4846beb7960d9f0ae82409a7fdca914a9fec639e1ee70ec40c43d2c04f7b9ddd25f3d03f3556e9311a0c8e0cf29cb5728d6f01f1dcbbebff052c2437c91889f06c2611f9fb156c2dcfce261abdf15b272d20314c2f4cdeb14f475f52ab25566a19f5caf26800a53718f9b236d710caea7aa11acb189879b7f70e0d9e0e0c9bb77c4d6bae5b8287643bba38177b16b9a33f26e0ea76b5cd96d0863d657a4d8f1eb8029eb668a8892284ac549f4b9afab2c843e4a63b57a32fb4846cb950909ae93121916495d1eea819926e2c98644661c6aa0b11efec87b1d0dd1752c6ab8a63bb374d6770fb17ac8582f95f2e36fac4e6b8117e11f0c2ef7d241bf814544ee0b858fbe0a109a8e7ba5b8e9c5289e3b53f96904cc6b3af6a690cc4460f22a4cb9f4b0acf23526a6678c2dd6c33d0a76747468c0592357dea2afeeb5750dc28ceeaabe723b2d498ad17940e357086a9b34e5ac7a84177f2d007a8598b2e6d5749dbee90eb63fe498e5cfb67d893f0c1f2eaa614590afa5f004ca49699dd1797e34c547d3368090e38445ca2f097c3def932ac5ec84c4d08321f7ada3d131a4879e9bc85d9f1b458b5fb5aed37fe073aba21606c138b687fe3132bb501eaeefd54811893eab8e60c0c0ece991ead590ff0e8652a46ccdca0fdf4972bd236423cb040d7b100f99facd8714e3cabb7241c3276741c81e3f26ea30523b348e4e90bd11a98e4dba3705b2e478eb2f83cecd0fc14ada7509ff36c9002f556ecb337e3ba5a45dbd4e0769b8c8202d37f1c09d725e26cabd4e857ec14e4de728cbef074f820f50d649b050faf3fc3f8d13a7eba4de7fb3880f47279a538fcf8dc07595af49d5493175ed87c936310800ccb31d94d3b207fc89a574e5f178c9d2fdb9d175e1915a70ec6f810fabac0742a1bda120ccc1d0d81331fd0e5ccbd254c8783287e0951572073c6a3d7bab95471ed57ab13713e72ca8ba19f6754bc181afc0fdc7af0769bbd68d094a3f4cf271de6aaab357ba69935b444ba422a41ba6bd5436135c620bc58a954c4b4709bc350d8f61b3246f105b657a910f783dba0cc18a7df7414dca4e56b4b34051d38eab9989fbf91e3eb2bf4e6cd70934cf4874606dac230b65cd18ca839e67f989804cc5b7f89ceb7f7a9a6e14e87e821705b3d7177a8ed583dc7125d03fb6702a1677ecc843949d7495b41fde6b1441184823a32e7f85286b2dc8685c602b23cd9eaca178f77221e659793bf8f21d384ae847c4566e959930541a1261e1a73f10b0ab8bbb58df7f48b80f21ef39a33093bd71097cd3316acbb293bd11f5cbb3af7f8f640ad41527fadda8b5ca353d48f271600ffd84cbe07b987ce4ae7a5185b6ecd3cc22ab7b4a40f92389f5e1fed01cedb0c1dd477b368de82cf68b633aea894b0b09e0520547229a3d46ebe18b3b2bcef4ddf9841e5f3228d93ded26a4a6f47415f151b2e727db7ae917bf8cede10fdf7581bd3da9cdf20c40e77b54f12e2aca12db9277b570415c973639f0d42d9ecf449dd916c3f0f11ed058d22ef6879ae991212b3065a3a671abdf1e175786e1d143247b8e13f3bae5e7bda9a0541b94d1954c636c2e0f4c928c31a3ee28f1eca1da0175c7f5ea5913c0323390ac5903f7ffea51c17931637be7c1aea3d3ced37b9b61c296b6c5ced3652b46b7e741a937833d26062d2a1cf05dc5689375a90a28eb032c9395a8d3c65f8bdf9baceafd1bdb2bafb381e5c0d251a0c9c2df9a4dab2fb28bac6591ef9264e97d0f4d41aaffa6080538b55bbf5cac308edf5288ab03ae4e135a65dba93832c62a48d955b1e256473c57c0ba6ebb85987e833509741b87a67dfa26813ca9bf9acd4787244f41e8b234df195447904bd46a7e09fe5234eb3d87cc13d79cfabf34c1bd69fbfa0f84cd5c8c272227483e015f875ff6bcacaf32d40638fbd2230b49a121fc0c4e9ec2b1ff24c4515988401b34f7e6bf9ef7b5240b6d3cca739b7c67fefc94b1e17d7d104c87de4e3490a2be5638127d4c6633138cacde417d5ba12db3db5632df41afd7c205c48d39c4497ebb1ba8630cf4a927f8fd80207a211a304b94cf36648c2afe89af7c5e989e3becc2adb2211e4098435eb5122ce8ab78da9be1bcf6584c2c43e87142ecf1b2888dfca23aaa295378c8dbe3d71df926f4a8409416151ea1360f8d6e71117c37ace3ee3ba428d664247a9a7ccd28851a85610ba8c841e9a1b54e81320ff7ec237efc4f9078864209740210d15f7ccb911f4df168eaee2d6df1f320a19ece96c271dcf6050c1751d77b29c5dd6abb3857920858c24fffe4e1526776fef11f80fc294155004906b81ae18b43ce0d9a6ab682197e76cbda855816dfaf9cb742b8f0b52d237332e82b4f60e63154e7d4d1806559081c5e2b4ca19a796548106d3e00dd0a571f2eec16921c11cdda8d112d2c70813e433414fabbbeabce335e56dfc4658599ef66dc55da36d7f749398e007dcad2a5a86c8fa74d605b015728de0238b1a646c54f588a6de331da5c073850db3eb0769f1af09319d4d2383d81235c9bee212d5fbb8f7a23da4e45c3efdce8b974f9a14f731ca9aadca3b6ce5ff5940bd1fc88274ce52b744d2c7d7c30ac178a02b7c12101f8de40ecb60b2c88aa9a72f40dc6009095c72db1646eeb1c6d59523853ef25ffe8f174f1607246972ad8bfb6c349916ad24222dda686b735f72e6c2fe165da930e32baa3d508c61bc4550b7947d6f746adbc715a18b1a7e60c28a5cc673e42b5311a7e4a312e2ce88191cf1c48980b0395f993699c5c604736b2d9d451c9fcbe630698e4541f20dca5102ad2842ef33c939c4510ee9546fe796a23f649f4a3fbedef11626ea582306e27370955fecfa65008f95ad77407f59e0475c39e89e43d8a396e5bc2b5834503630e516e51eba43a70643bc2b20f1005ece8c76dd27937d941fb6d6e1c699f6fa4d2eb59acfc82c6cd94498e2290b275f02c6dbd6c4e162891b9c57c51a1e05586234f1ad3b47f88dd7367acdad8bd357c23b8e5503b2b58d288b242873f17ab05091f1307125b2bbd89d89bad65c2b5b161dabaafc0056148aea5fa23094c13f73527b53eb1946cbe2aee446685ba511e30c132b609c4808689f76f91fa550ee1b234017ff2537064ca5480c3f57c49011cdb4d3cd52a313a086d9dbbef937038c26858bd83b5f4037fd4cebe4b83651abfc614ae4dd0565a2f48aac95930ebe47949ff95e37e0e055956cfd57eb9916a6f17b713f7d95288333cb74895b9d137b898d8d4f354fec2555d32b8a17929a03eea78ed763f17634a6b9ab237521d58345f4e9e7b4c0112a0c7c2faa75b02a35180a33057d7e6eb9efc3c585fc85fcd5c6ecb0b2c46eaa693b80d6964284cc76","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

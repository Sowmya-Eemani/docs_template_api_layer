<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a39cd161fd83a197f0dcf61e98ff67375248697ec2e4b4ac6a39d9ef30ac01055f057f4f5b93a72e5c53a190a59f3a343304c1276e3861e4becd02ca91a0e101b6743003d5cca224bee05cd2d6de9eeeda7bd4f48a23fe714f18c0f818278c43da60f31bdf567dfdbf79386ce4af98cb8c4ade199493c31e3fd4112649d2f02e85533ec20be479e72e2c0f9cbb463fb17415b8df3882034aad3ae3fbf089c734e0a5e5c6b94c45bde2488777d55130cf619c3c204ce18bdc18acdf82f2d6d0069ca9215f37dcc2970b17bf90d6b242f26319208c82c46b2e011fbb137a113eb977a479f6dbaea6e346623388105f2cd586e505433b941e4761cce11646865d85a19e12fef700767741d137fff5d322bd9d52e5d013bfd5348f681aa8e8bdf0bd991c52bb98c8d0886d3333dea13b9e614335d7247135a41f86cd4be1e7ae0ca35cbf25189b60fdd0352b858347ee0e47db1cb7ecc472975a91a61bdcf11aa746870d01d3bff072274ee26762adadf184e7958c07e21fc426fc540f5a49265acc1824024bad5cd70fa1d22811869ca5a710b386fddfbeba9000d74ba2279c441f040000d35ca9e3457cf0d4e7df14377afd1b5484d0e33bd8b3b06abfe528899ef3b6792da776a3e88c5ab1a278aaf7c6fd30347f2e3a71ffa60f2a2d85176cec3bb737aa777aab0fe332a729eb27ba89a10fc9f203a05cc4866f550d28e07f1101dbffff45f55c8ab6bafeb3be12dd4e1c64ca916a44d7f7b0c81fc00b34915b7dc262d45df0efb1d45968fc66f1e18c74cd8c72f72244ab608ccf0a3b13f8b6460f9f9f5b6c32b018097292ddaf73e50a9ad23ff7f0ef94444951c67ee44a3ea092e4406bdaaaa9d719fe7c1ff4d07ad2d7290ceb4490378ff2b0a66413f0ff559afcd55df2b8538fedcb09b1ef05eb9f8b12a069ee6726204184f5312b036481da4045fea076910e790ed98452e8b760fe7a0f8df80e976c8b77421703e5a76a7f5f53fba25db093c76f693d96a4ceabf31d724f0d26d3f88c525d4fb749b3aa3761fd2e1df05bdc4edde3f68275ceaf967c9e6af7198f8735c40f54b7c12d4c28029d6d65a521a1c281b93d665cc66435de5b754160fe135ae3100003a75862c21d86bad7c7a360f3d398bf03bd318e753bb3616893eb3decbdd642fdec750be4b22ba1b610a48a02ae946d06dd60ac0b91b69c68877ed118d46271fae8c273b8229c1a95df9502d81e335408f57e916ead326cd7e33ef8c7332c4d83ddd1f520c7ec32660f622ff95f66d35db9a50ce1f2c3b65b12971a44b12bcae50e90f73435a2e60f76a02cb00d3264c78ad52451935b314936f4c64eb20a316eeb89e24b0b496bab3f07b1d336f1858316aa7c3e7228e61777e0d9f4c34698b9c59db685caa6f0465b233f9d908801a989210b503859c559990e1ee9127aaf159409105c55b5130de515818601dbe5e4c88238a9da75a91b638930052cfcccf37822b3a791852913e6e563c4b700d2368f39a9c7bef1d25bc34e982a2bbf4bd022884de814cc42b346a0e95c98e6b4abcdb9bf87850a5f07235575c51e8d6bc0f4779fdf6b440a1c2fce6f067c084ecfaa2b97112ebe9718c95cd8737cb09b224b3d4e8262b25d4f4a03d5d4050f7d2d408667ff7c3c61944821a8c10c72f5957a9ed9f469bea49c93e5308a447ceba5eeb2043dbc444db7d6c43c5c4a84ddfda6e9c340612f0ee0c8e0517903471f8983624c662832d7bc6f072c9b1d6d287a951868ff44387b0e70373b14d6005d31d9cdd213e424c9b920f29d749147d4fbc1908720c858a4fc3477bdcee6b7dc1cf51b28572aa7418ba782af658b2e02bc1f0055c303814a38df756fe07ee036d3c63f85c31a0b973f5bd200347bd578c5befb4683fff5e42c7bd2dd4326184678359c3ef751eb728b9967ed3a5130ba19e511cb343110fa41927bb67c5dcfc1de8638ed9e8678b2e9508170acd16dcd64cd582aa56748552c2e72e02c9173ade93b0a1c565b1ed6785101a9e9323a02f00aa4a8beff6acbc859e6ed5c54dfa22abf2ba3a5b1b323a13876034b45d4faf957aa1c554c31934b1eca02b05b0aaacc84495b7fffafcabe7e392a7c22f0475b06ec308ac20d090ae4ff7dc8300480529d410e84d3a111d84317966517e93ab26e6bed60685681480f79eb1a961d5013afd3d998d44674f9fce8c4e5ffe17d1927139bd1a02970d68b56e4304b77408b6df85649b731952e508a260ecac1b79ac59f954efe8324bcb68da56d516344009a65b3efc12d0652e36ebbad301511e1a046a227a5eab63646a7f969427adac089e6a3ef4af6cefa16311878670eba09e061a5b5b14212477977a496545927cadf88d9821180cfab670a9829cd7df734192ad32d47dc929dbd82ff133454bd99104d5f21af3ee9742de0a347dda6003459e3e3853062a686de9fe4fb74e72bd4c342f9842d85a84bd8b99df425aa76e87958a4d0a10682d224fd27a77c92804f90659c5a1f2d9832e231dc92e47f9de388bd7725356a49b31fce830bef8f504341022886fc91074346be16a8fae2a96f363b92092238a1e7774c2ac798eeb834d77df2cf71c4734edeb65a991327136be12ef4631342f88ce71f5e34478c8045be15df1933db6a886a2e1ee46ddb385bd1f361446a806be741022855aa066da4e32ba1f1258fd4fbe721a1fb62338135517839bdad1728b952e8e09f1c6260af150291ef251989c2b5a13ee5f349bec87ff51caff37f9d78e6ccb4ec00e2a0ec0ed70e2b437eb7aaa6d78e9932adc27934830d75fa916769b4ea1fcaa3d43c8334bdea3f56fe6059260da038b572aa5016e5d46d92af6ca985d9c448b5d5f321716d9fab7bb59e6bd66339e8dc64709fd83d0e98c7fc57b645dfddcf1e0d1f3e56f08b512b9657e9ed706a923cc3f7289c85a8f8b4c917d9371b521a6c73a62b11a8797acc5eec5473e6ce27217fe7f2806a9cda8e35045808bd0dc3af42ad933cf09e2fbf5ea3179cbecfdd205c503562a28cbf7ca218da5b7d6000ce7552a289e848ec17c28caa4afc33fa54b16135960b7a6bb14e55e7f44100dfcb2fcb475633f4ae40c1686b1de94d382d5b1d2f5d25cf3a6f0a5f65a313110a8461e5ca4d1e824dda0eb8248995029427571b6b8e774dc833922e0d165b09d02edd34440064eabd979f72512e353ff8e8bc6000b04a44bb89ad98928cbb71a53dfb32aa2c3adb6f30333d84243ff0b71ce50297b49faaeaba33d813f94e72fe2e760d53b8945f71a3e08fec60f4faec15fe5a280017dec6821a0716437252169f5addb8a7173f9d681c6aad8dbf956a34f0be5c3142b71b139e452de36b070cd357d2b97b0cb6c808b6d23ab30b4cac2dca64ee96ca6e504ec74da7294e4769964946b886940f41ce3df2c397b3b862aed1fd4956eca49693ae10d9912d2b059dd35edd297b8097b1d2bf2fe650230cb58bee3d9ee4fa667e0fec61bd41360074c678d11849eb132060da0574d7eaa8b29129708edc30dd568b456cb7daf678e68a352896807bad349fefa8ee4ff8122618703ad4bfafc2781cfe4d59f0990d90487e6e88098adfa76a15955d47b985e283d78f65d81eaea21f1c3b4a3d0185c4539cfd4da2a40f6ce443839b0be14efd4dd11f3cf7750c324fab5542dbed8032bbb45c745c5f2383860ecc0550703a2e54ff20c1ed300e4a82f849b31b76efcb34428f232b03da9d767f1effac9786f550fed6350c3f8c582f8255d9fb854b9de584edbf58316007fa7d7df98b41d0cc2c8b1838be2a2566db64c565d0b63b94f6813f72c1e3517d9fd13c1a1a35e30596c756ce4eb6e6a3ec8465dfb404f9f92ff91ec39e722ef3989aa9deae9a66d1b724e8cb16ed984cb94f6f7760d11ad17d48abfdc0336f19ecfacb8ebc9038034d0a21489c45332547281c7dab96e9029bfcd5daa9eb52a9a796da180f44f09644c5616c58ed8eac60cdb85a315b5b46e06ecf2492f99147d02e997e4a5a92c59f1668ee845e66ffde4b9672d5cb764b2d039b2cbd37506c37c5c8c81f7f8a9894e5532299fa350b253a3bc39d4bf76aa1e9e6840eaa8374595a13929001fc8440734d7510c60c6436add10edd42cdd7824eea763ae601922e49aca8bd498bb2fed54c315680c6ea8d0c0c6476df42741a3347678aae9263372bc56cb310f104878211c96ebb9af58f6ab67238d26ca1d0c2a3858bab9c22f5798528701e062aa8a750fa60d3e82a6b005b6f09fd4937db7b74d16b2f9e6c4fad0719171494e34c00dcd8dbc3056b045b86bbd445ff7a088a37716b7b397c37e9052bbf981115cb08dbcc38abab68cb20e9d1d17161cddf46d9bcd76c439f4a7d6934e4109bae234855d6019945050979c497bde801e5c444aff6eb0bf2a59816f1989a6253c2867d9b07d7ea9a3a907689df22b617c204500b7d77d8f275ad27671f509b1459e02bf9dc01287370348cba5dff6aab79e5156b5cf74e56a07079a9aa1ccb3f9e6157ff43df71b672efbbc26df154ba5a76160ede9bd2832ebe50e6d77bb674278754578110313614380dd1dbaa9cad2ccc1d77c2082eefeb8884990463a17833519ca12df308c2c6bd13f9fe1962de1ea1ab1c85f9cf82d77f27459de3260a8a71c97accb9f69830ad77365c871807991e5ee0144dd7a33a66fc83136a5d0fa8f901c3d000b07b6ec755cc3f7cfab8ca1c24ceb5f7b9b173c43ecab111a9afb1d698be9de4cc2c659bdc9509df4c8e6bf1e61191be5b8bf96fb8d34a3a655a44d572c8556d06c6f6fb6df23ee79e2b29550711f968a1e451dbe60fbc3c79cb9a39e0a4f32df9047939401735f7d41288f1cfca22b7e4a794d34b60ca45aeb8ec96f31a4a4e873d4aeb49932ab36282f8a5018e4f4b22b85b40ccc80e241e538e04e35555df326edb6f3b4fc16439adb5bd53455cabfe5c2de271acec512f236299ced140fc9691e8e81b110a1797a19ef25505b0d1371fbba1b640bd0d4ab20d85e9d94194b4c454e48f7ecbe4b2df4fd96fba2b0fe017a5f55e71c960f251ec425cabba4c98c37b7a1f5f70c15bc3c9a6ac25161424b7e72bcf8a31f398a9f1ad45600ccd28ecd1e90405b3147b0800d03a71b27af73578daa9f1d89ab3b249a4575ea5bb5e3947bd57726412a67feb357ab25926a6006e0fc61fb7fcb569c7a0103f58f349c2d4ccd48e5fc69a20b7153e98d187d0679bd3a717d54dedb9e617030bc703bbd5d7b8e7b19194d110fbca3f50400e9aadb7deffbbd6ff1a1f4f0bbf35b10488e707e9813919eee924625015f6d040561e25d4dc81bea0dfaca5f2019addd5db7caa6168b90c191e488e149c9079549989ea02370fea5f9e4f192f4af23f31d1c3526bc6c320ca4b58ff938d700a0398831fdb2ad9bbedff0dad198c32f399ffb283ad4e26594fa1333c06786c27a6eaf53901ddaa94cdedce52baa37a94997410eeb55e17af6eb3864a8280f09d97ae9db1c801c87546ac3ec3ff7a0d3e893b16a34a9dafb1f6b4e1a381753a4a91bf59cb039b944b92942e5525c357558acdf514a70aab6695221e867c08a89d11ee6b2b3288e86214669d9caa1d6a8f24ce85cd4cbb930267e93150b081ec0c9b8fcfadb3efa743ade59af24c87b3ca8fba33c27ceb07cd9adf79626cfbda310534ed63bdf7b275735669d1a9f2629784cc599c9cca68d0814cde493fcb49bc3b74fb16b6132fd2c2cd93acf46b439671526fa5ab676f76cc469e6728f3b5bab234ad0f11b06cf0e865f1b8c6cc84078788425e470b5b641f41d22d8c2c7b22891cbc79130a39f062fc8d6df0a029b18de4091feba5faa8e91232c8da7cb971818922e2238c44fe2766141edd3f9989544486664c1d19bd0888ccdc8df05dfe743602d22f58fb5f58d12f4c303e5b0a7173d801f43e02b4aab9eb2e1857d923ef74b5dbd177dbd0c671ab8403780599c48822275c137e9a5e9458529c26fd644f156a46fe9782eff4c2c5a38982d24074ece624c8f5e28fbb352f150bea53cbf865b069d582bb0153b47160610049ca336a98819cb99f04d79c009dd6343fcb69c265cfdee2a5dd70f04d6e53dd814baa8a7ba0dd580b205efd472fc5683c6f6d2cb2e326f7baf912470af9e1d934f7befdf30b98458971d222f3190bc3ac9f25e9f09ad00045fa778599bd0a3a42bf688081bab3be3e7100bcd51db7e78bec9f295aa27a5a7cd131e02051d5db411a5973dc78bb2c563c8d2d092efd45284ecacf146fe13bff12c7c7a481437503b8ba29d467d43f01cc95b2975cb72d29b7a3ed68a0abff57ef48b12d2bdc50f5f9683b960908aca49a9dd047f6c2d0a0716abe544753a336bf91c000ce5370c2f61b6f7c7290556c99a67c000efa67bb65a2de275cb08695c6ede36c51875bc431ef763f20fe9a9b5259bc54d50a48c9193cb3f98a29b2cd807c24c2355d9198646c9328e2dfba35fe31592b4b3c7e4cc662ac06d6c937222fa5148b6631131fde3ff300a4a9ebe5d613eeb18abde2ecf23a051ee3e6de009ec4eacea6231aa6a2aa5389c82e12262f3f0c71bf3109b790f1e303db15460f6f3afd6df42d46a832d3563a42c1a7a2b91ae74b0bff17f10e931299fb90aba5bd8014682463501519e5c7c0c0fbae125e847db65ebb6b64b51b1fac0a3b219872a82ebb6d193a2d7377ef6655dc75bf9c0f292eb641fad0b18edc003f1fb5131f96f7906cdb99ef1f86af389dd39df357cef4cdc9dd114e2a6ebed689aa9eb8e099e7be1eb700ebd22025df23a911357c66d508882906be6ec358fcc5fb2906a83a98f020386928f7227b20806bc9bf3f2259a6df43de4435fa18eb0f162abaa74b0be786d43574198dc762c0382cbdb3a1a6d14f131826d3d90738af4fc1506f4f423fba535f68db804a450875554563dbf0e35f71809c8ed6ed8aa0a47a4fb0aede796d363aa94bbe43317e60d6d2b031e36b8476d8e0ddf524bd1d1dc524c13cc510b7739ac0ad30cac4f613e6d4b2271a584295b579a4d3cf1eb5466d5483b118830256553b5f0210fc41f446688ac74635c5e5fcda6985df048cb9b5abd23e8914c4d9f57449a77621e7fbb14e5c5af4a3a396cc7761b227eb0a8d23085da5a4ec1d8fe2366ff42e4d5f7208de246c9904f43b62543e2e9b32537bdd9d1a19d0a4372c8652f0db14137af65c7129a30eb85dd428dd0bf439486070c97ac5dc73a837c2e2fc2b264074cc9fb119fd1d4deafe11948686cdded00547f93ce1b38776d4f7012b156ad7be5df316bfc094ee385c14be0eb7e32908d77b9e559c04ab797ca7b8ce1f4952a595b9f6d71a928f5e86fbcdfc53fc56f0fbfda69b8f7c49a1dddecbbdd1710ca775ebd5155c9ab5cb7a969251f798687e35583fab6ebe34cd0a6f957588d471ddcfc02ecd3e0b76723cc9dfe17a6534e3ef3d45c1c444806411a4a5838165fb64d1be69333f253d1968151ae6080830c2f41a54f1cb1c8116a781e0f96dd95ae79cd167f29fcc1b40ef184bc120b6ca11ac7273c58dfb2c08075462f71171ef62647e711939b852c231cec25b3dae5c9d3c6720c347f0c7795112526bd55ca6516b1b004b41865f9011b2c8076341e85f58b11dab992d0adf9e172f090e4e20c193e7081b17775ab251b625677857f1c42c15009d9ae9f97c454392cf155e3e032434b6ce0e0aa5ae67ff055eac22df28d08006ad6be7c286c1a9957d56db2f825e0729bbbb8b54efe0d7da451208e03049703d1dcdd77b7e32a2bd926823eaea85fe15261f8d4d2cb1e968956a6d4facffd88c0bdf336c3900b1c8d7d71216e9c25863ea3771c9ea13167de5b7e8aaa3491cb592a91c107c0060b3379fd0047dffac7d4870b9ea235c069766313472b32370e9d2a72af943fffab922dfb21bc88c8302c67d1f35a150a5892827fc0bbd8a1877137b69cbbae75424bed51a2e1f40a576f7fde571f6e2719301f1c8505dea0462c55d316b66ba26dae088f8a3a4a19b994087bb54a4bbd18faa5fc78a3f9d562b75f87689e9b158ad3ced752a3136c1431f89fcbc0fc3c0ba6e556b383a99d88f3057ed22c93d32e05e51047570c39829141de8be18f9562c245f9384f9824959914c61c45ef770f9b74bd9f1a7ed095f3ac1cc093800bc7488ef7426a882d21ead07fa753d5e4929828776c8584b468993b9bd0f3113d33e7ab259f678ca6803310e91d0baf3ed8c4f819a55a6269a0b68966305a5640b543b990ba2a8427ba20e416355b8ef2698185d038271d79d8b80c1e5897c2fb3ab1c8dd5341b1013e3c1545551c3a85267a158dcc7b76ee84f7893c493fc9acd68452ebf26dbe5b88c7a4747db8412ce8bc5418132fbe88c74586c953e1a8703cc525c763927f8dafa1665a91b029ace94fe91cee9be40abb305d64044616aeade20868446e1aa9c6fe982cfe2bc2957c4e8fb0ea938dcc43d5c457ff6c60d99dd2f27c3abfbdc33d37361e7ce1c644752c5811175298bea784599c4ea9ae5d2971894adfa5eea49240e093e8a689460a66b231bad806442fc341e5c29f68a7be611e296062269e5984007ebd298bf77210287708b67575ec3561d77f1275dd08d6b17a7a95250a758bcf493e9b0d2b9bd80f76f30397344ff7469337935d09b324969e0e4cfd395ca975f39d7149f1c90e38aaab8041d61c7d4acb8ea6fa73651d5d9f9f318633ceff7602c3318aa6f1b549633f90fd2ade7f6399d874cbb941ebe62dd8b3970655e119882581ac86768e228dd7c92f4c2e41d8edb9c6e07912ef21efad44212fca609f6d562be6a8e41be069b3ebfb0fd5c402de64d409962c9619f9199a3e0c650d2d13f4e06d86d4f5801558c9a70cf726ad22b80f07192b8d06db148f04eb1403e93910df2052220631f4c9eea38a6bee68192a86e8c506699d07199d6c1dcac7ee37e32553996b90edc6260732632cd9aa93cc97003bb3199239a327b6dc55811e8f0ff5ed0cb09c4d8bd0197d0cb8712ad5809d35cdf6eec9d3594fcd73705290b0c811db15202d2d03f4a5c7f0005a50a5513065d0c448c2180cb80b30cb423962da24a847abb9aed7df80ca52cc776e9ab2efb542d1f7a662e6162c29ecf77111049accef9b1d9d89491fc7b551e9ab3ca3418c7f699c82b0f3253f088994331e8dcdab8112bb7ad9183edcc398318aeadb1937a7f0cc8d57492bef43716ccb7750c3626be3bea7d993ae84ebe4f1a1ce2e612db86beac8f1d25efe1dd25709e60e5ca092f1c365c7581f20da85a438ab9d40305d695aaabb9e7adfe4a411f6eaa41deec0b7d83dcdad7837efddacdee51ad0a2765d1d73df1bd3cd19d91da42c143f5ed4e2d02e6002d09a330ca2e48c7323e382d752cefc9614cf27eec2c17f9bc9188d59ce4f91cc0ceec0ae7d14337efda92eb27ef177fce9b494d040e87e0b0816d29ce1bbdacefdb45870ba7e0082486a3d22a4c26c29bcae9328d14b05817df0fdca78ef38031531db15a78fa85edc59f4b955214ee5640b86b41f23bf475e4a722851044ed8167a0fd561e8756db32ea31b25ba798808638620cc08d89a300d3db20c57687a4352d11d8d180553ce4b0b0c4c02dcf9502d9cca93161481eeac0443bd8aa4427c4504641a55c6bcef93abacef3e1973271a40b8b8299adeb0a1d19bc9713adf6e4c0b56a1e16b3277bab90a2c85deffae5dd5717c70a760140a14918994ab1b4a35fbba43332504b74f833faef3699a5354b02b768b5a3cf9d48bbb8892786203bfefc5d82c480893d2e060b23be33d13546cf86b34dbc00c4a2b950c4a86f59f2f67ebc8a72bc987cd6f0f2b637296d32a62469dc93549495810ad32569f0248e89dd847bbfd96963651260d32983739ecb72d6343ba388de71a89ed266b0face4a4c69b91734f9e29aabc06c9f807115cba8561d2d5a148ea09642417d69db80e37084bc625db15bd6e82d7e16038aad79a5bfd85c348309590a653602ca8061eacc0c3472efd44ad2d14bea0d96a3af89d645a69076a038b3877e99bda5008c4586be5f1f73999fe86e6c6a2d0255b5bd401c5680d1d923e0d32fe9594b851949c3a960ef44f593ec7f29d16032f57e1f86b7fa43946338e75468ad34ec1828872114a603087bd7e4c979f069d4d96aa338edf798b3482072083d92f46f53a6a03419f55cf6251d1f30484af2cd6aa1eb4b1536e051dda144830bc5ed4a4950c08450506d6006b24c30682cc3ed0b971498417eaf891e78207544181d1868286988c8e47360db0a067892fc4e49177425b6bc25209e169455571e6a2cff19aa121067148ab208155faea364a0ba0abb727164d0fe80e759e5c2f34f5009d083c92be8dc517dbd0d9e4402a2b87760126d635f190f51a18354f3f5e3f58b746409a2a808430f5bd1ee974de1b888c212526cbffbde91e70a9e8824fb3dd92d179ecaf480eb9c15801009dfcac92b1a9439ba20a40f4b1a58a20da1c3c0432a2c2aa6e537739ecbd26086d4a72b17e032504ba49ffd9f711d9478127fa88ba7bc5186a7fae1ca71ebf0eb083e926ee404b29fbdcec3f42415dcfc08e4265d7138e954b83b1548bb4d3eb0367ae519abd56a6f29de849780b402cfb8019b1342a0a5b52d86e88dec701d808a1217889d1de1abac68c2f122ab245f7b717a5a15c4699c9f9f6e15823d980b43480ffd46bf8af7c5a3d35d676b75dd52e24932fc0915b8f852374b186507007063d6cb7201fdacf86d78a617e8c01860d85e5342559caa9d4e68d5a142555dfdc30dc3aff236ffb18376ec5e69d788ed5b1c8f17adacc6f70e0721979f3445eb56c9f65febc24fc06c0bdd42889f68e097472f17e5d1e8464c434d8cf29c8ffb8e293c067f48cae158070c86881a13fc15bf584afd38edc87ba38084a06c92bea54b4d8dd6cc540fcde6afc7b9262a02f04c6e97367177b354836f8304c5ece78d74796b1da122950851143bfb84a31438bdf73662271303f11a9c3a0f0f3ccdcd47f5b72a4f332491ef72db94b60f528a6c8cca2cf25e8a59ac1f8f0c0fd1445de1b35561da0a9fd1f0267c869127abedf2466cafc702de2196cacff291a59a14b39ce549747db57d26167a090201c2df856f087594b0d8ea6344a6713e1a5c782c70cfb95395d23665207851b10319b7f3a2e52425272f8236a399aaa77577f9571cca9c92815813fb79d822d9d3affcb3e4cb4282a2201aff01f387d334f1d1449bcc3d9a53287dc7487af7b179c36db4333647644e8ca22291f8afee1327813c018db9d4693f3cfd1f9d113e9ffdd5d1d46952ce2b3bbad0d0f7079f0516960484d26e80aeed1876629282de9d01d72332ff414d806e93e23a8d590dab2f250208d603e835535e2d07200f768020c0572ff380d926a58511c170be2ca23ba25f347aa65bbd7cd6ebb4d9315affb34ade37e003eaf1e52acd5e1bb868486d3355942ce35732dee963b4e6879b743ebd8f5766d4b44c2d0fb421ac307fdbf9dec6a945517b9febc2f95ce31cbd8e7da5175bc35b5b2f4f7165cf2c8947abbd37cf9cd4729050c93a081a83203b879809e873c34685f3a3303c4c6f5ce1aad1265d00ea87340a028808002f1858cea66e63f4fbf1eef7adb0d4f345026066142bb9bcdba93d88a16e5201868033c0c6f2be94f9ecea23756673f4d77725d126730fe55498224f6b710f6fb44ae907332d532ce2b90c734c6d9d68f21ce3582cf238754104e22df0a798b57cfa6b85327ab1d831a4bd535e7f957cf9bccc51c60d86ae8862336dd4f2a8612e36e04d716ca1e9a94b7942a3067cc9e6779459ee83ceaa69cc0f01e5e929757fee04f7c2c16f3ffc8e50305f95a2322ffe8e257595b3bb15839103097f1222c0d8bfd8b9aee6881c22d19400fa60a182d0d765cd7f1931be5aee92b7e23526b441ae6af03da17fb3ed16fbf50cb5b360138d81604feb9a830ee8be26fc83111464b0ed4be2be362f3044d6053751ea0775fa3060f35fb2ede39623be20668d0daec107015429a67008914b1c3062b650dae98a9a69c32bf6f2955a4f1f9adbd0e84ed66cd27a555b82828b5dae730c979741eb39231b691046402d2f5415629adc1947a0087abcfc23ef4a991d37d774c4de7bebb37625676ff2b22d605e95eb6fcc949c524d58f75bba0515303d8058cc406addf1d1ea9bb6594728957edcc6638fbd945672946d3599a64ed00a3bf7854aaf7ae4056b52b4ca31aedbe70764cb484da8cc9936d3487ce19bbccda4289a622f99f3ac0a6cb2f28b15bb47e3b5a60b2962f9d3c970145b30ac48e2af0bd7d07d2c53dbe047411ee75fb68fcb8fbe7acf4a9babd527b1e2da7d2e1a2c55b54cc3a54c003ec3e152b99db2409823620f4f04fb4625378371c7bce2548f90cde256cb7e42021c1bf790dee9454934461e6d3da2cf3df1952c65e6bba7c2993bd0707aee9c8a018fe53e371417d12f26862be2d058e97220b3da2e7c7e0cbc61401a362ea1252a108b5189ffcaaaff70b9864b6f2c4652e60889a267526068a73bfe81096d546660aef54f94335ea34fcd1ba7b434d3a52514b2ca5358127e581780577607023731e194a749a9ef17cb201b34d620aa0d83a067d13be1c65eb84d7b318ed39b963b6e101bc312512728008a9559176e267e528848658196fb4b03220d5d9f2c75b71f7146dcadb06b5186c2d9793d03621d3a0fcd6f912bcb9f2c9c1e92dd12bd23e9791c2a5b301d2c15aaeb985081d7c7b7410041c0359f854347644d89806f40447dd3bb5cd9f5c442c9bbcfaceab66083d99cebac6f7269f5f4d525c0d150a8a770a3a5bad6fc4349bd70d9d825e02052c4641d64332def31e150b76f5601f72388434370ebf6dbc30e4a1ca1c383b0a8719fc392a754e45e03fe2fc23dcfaf75d9e7d85c9d389c8f007fcbb76cde617e4b334e757f064fb01e8f292855db31d6909dbb0358eede2bb9eb79cf056ab150a82186770b5d792af6a3db0d316f3c8f3e571c77722758b42b68475e10a7e6fdd7f4cdb7f4d060c736655c40b42950d2987dba270de4bc9c237905dbdb858595b375b0ec78de32020f89c8a986f96e8d2cddb6e47b01eb059bbb5014b8d4076cdd8e76e187be55c8ca8e2b7f72b6b7c0f7039e307eb988a4a6cc981dace76a05a6e3666ed689db53fc55d2bee5b193be4e3b757f0e9d346eb02c620845c68da80ba445e6b699eb9d1e1e83b3d31c566b036265514bf1c5b011f902ed2c18c5ab4e6d9eee23e4b0f2b8d9e311fe140abd4a3a029cb4a8a737645748f3611e36647e25a9a0235073347540137184a9c2f9db7e449321fab7ea5955d14cca8555280cdf5a8d27ba22e14f704846473d5f78340600968988bf471bc5ddedaee302446e4b3f94201ea32bd06f84e5177554db1c7b3b6f8790422351ae27afb755028a15744a381d5ad361115380b59a2c956986a965fb14c84ddc85224d410003e1638d147bb2dcde70457d37742880c0f8a4d1068b4cf9d4c18217585780eeff10e0c65e03e8412b2e2e1b8bdf19eda8c7295d6bf66065124be70cda8aa5f6d9ad2b3bbde8c9cf5c6d0d704907bf9931370ee7da72ca82cd2d4eacc060c3f36c63036ce4065574cb9c186046f5ef5478b1a7b19da6d581de6ced9ef63fc4750606e469732b5ded1830e000693e1024be2cf266c5f9680e5dacff990c40a2f49fe1c398970f3e72ac9693667969b7a55d9dd69516fa4f1b7bac1e7322e55d07052030a0af2393aa49159fa2af58f51c71f2ac12e001089b16c77e77ba838da13a3490aabc94b57781d34985311304060807ae5442e700c0749846ee576b1d0df6655b254d69587ef48e224cbd2b0eab7597f8a93b00c95488f24a914ae3ed351caf3aee426099c9789a8aced3be80897d667f65dff8ed0a41c2a302c157b7bb0c858aefa8db64f23e6cd1514d040ad555d0a068422b8d21bc798a64a90420c787cd86b8bffe26b86a18659f87c3a91c69d61d8695321c2011e2e1acba3195aaa32e2c6463702ed5854bd3863e06b7bbf7c5a09cb34079e5bc88747c66742e087b33b0ac21f0d9bdd4e9c73f6f48207c409fc531e4ae3e126dbf25b555bc642a304e1256e3f855798645020a1ac9179b78207f10b3dc600d34735b2952ca9b692ccaceaec864158dd1cb51a3a5b4e927d2d3e7824ce453c18c989f1fa375bda06d3c4d07f1dcf9b94f53b39921c17b47025613abe33c0c8dea51a0ce2d010f570f45975f045bdf9ab048116285fbab0bba101743e5f64900fdedae8af1840de2fc3c8fe518ec0810f4a0d281f0be0cc4eea6b62cffa207b30a557ff7fad0f78e28b5e6c3a0cd0bf3711382debb87f8ea0d3188fa7cde1e44bd4514e13ead4aace68f8be7cf5520a3dc41187832fcb59702bdccd7cf2738f3eeb44ec25299b5ec025d684bd80e430f195f78399d079c8711d50897b3a13fe018f63a64585f6bfa10ea072cee2d2d9a9841ed1d17a7c404436172baab7af17dd0d66343058513d1b9a5ab52cec8e6cd9370146d78ad5a2a77e3b2698e71de291fcaca34cb10a505b27cc9da72620b74b01f365033062000cc09bd6620f03d95f6fe15f6b41237319c180c22ef8e8490a343c2f750af990a646997dacf1dc3e73f86ad6137ade679e22b1e9251f3dcf0c30bf348ce391b83b0fcd4dbbdc13de902751334c7b3ea9e22ee714e9675e11e16056d5168dd93d9e71542cf405a52a5d263d6f7338330f08acf6b63c5fd32b053b0382a086385b98c4b795d9ef598f5185439fddc530be1f764b16706ec40d4622ef531631aa87353d8af7e070f2232deacaddf668ff4ceb9962a170ea8771b40f4aaa45168bb858e7ac3049108e4da4aced1fe8e175d50759395a43ac7aa39ac72418dd46e70e99a8d5928be2995ff2b54427f358f144b11d88bf5442d08ea6a695e59af6edda658fc232bd6b5a853ade950b07b7c8beeb257389f1d50946097e533e85a899acb9132d3341915042a7e44769550709f034b28e5d47b0442b875c0576921272662005f5b7c7662a563c073a8a67a9f44c6f40d8e386478e81fdb4ec61d512ba06b81f097688e708ef9e75018cfe1e7d656cb2bb1b2c6f84011d3a47205ea65f7d24323367c095dc9f61ba21079c26806fb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

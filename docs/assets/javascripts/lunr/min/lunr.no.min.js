<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ba9d375af9054c43f35c54f499ba4e93b6ce08f18d40f9c40d941642cc97245e914ff0b63d6147d89db6f097ca20e7cb15b4ccfea98c5befb29f1ddc984f23a62afc5655c39b61a8efdc5a739554005a5d93fc3fb3a1f24c960a0e06cd5c05cc4ad6fde080e5e1a13a9e663601d06dfc0b77747364324cee87b7c5dfd6df7c45e43670874ffd557b877af7393612a95d06f6d7c39a44c8ad415cdfca03af6cb3b54cf88b0f76fc87551efca6631d8aeb844a938cbff74fe0c0b2bf11933f2991602c298779720292419efa5a4293df7c9781b392c53d84ebec8e87d329a3fa5c4262559d0f05701e82eb92a1f2c708a053bb6a5d87e0b72f741082ac3166e93b18145dc278143a4312ddf46e4db5db8413160aa786ca2d2f3daca0738c44af23dc29aa59fa4feb53062d6e328750ca1332a3e2f2dc188696b6a5158bf46af8c04041cf1db74f1a9d180022dde1856a705d85b3dd8135ab236d41229cf51730eb6b4720f405837a2f401f3da515a3585ac885fa89b58b9672930e7523c52af9697e733be58be096fd473aa5b440343de627bac932c8995a23a92f10cb7d628b7be3bfeefb896bd52ccbbc698ccdd2e3ce788b472f41c1888b2ae1aa7711bbc88333d0c59a45491f89e6e385e5682c8963278774543139b53c64265589bc4d880701991caceb21579ea4ebe47ab8ea2a034e5d2bf9bf7624b4fa0821866105c139e230ac61a9fd409c78ce40c6c68f4076f5978cd84ff359c6851cc34b91b0e62362a9cb6b92082762d84739023aae0c2aaf9e3acb85dc09d98481f7370463f88846d3d7d06cffb74f69811f0b752ace9df45c6251ec1002ed3dbf885027197b5a2c872870a53de2638a3b39106c4548728170b4088fa879e80f993ebdd0318cefe34f70a5c132540d4b6d4ac853cc16232787321fcf7104ece4f938919f940e154293c6ff3a1418db7446901e91ff7e8caa2853e30b831576b59520e5dc98a616ca85b007812decab96909d68f6c7092aea1140d28db43dd8619e27b71f627f8d87b8291248204a6bd8b26348c7b2e047bee34d82b05c07d8064e52fee97a153473fbd9635bc1b32f2d2d66fda9fc391e88f1315d3d3da21a114a621d5df51cc877b7fcd4a90ec949ea10d605c649204b068b1604e19bd8f5347ee21d9e0b5fef6fb2576c11776a84998a18255725a45f5f5a76e9ac2e6322f23b9f24280014e8d1fc9544907a890cb381ab9bf39f3b4672ebbdf7a043ccd85c816cb6739311f2d0d6eef69fbbbf93da4c64b7520f6313ecf159846aa8435081560d13f22f58661909e300791660efdbef954d80ab25af0c42e975c8c2d8b5725a822345a17363050155234282fb635b9e287a8e58713d28cd0c8491da9e665ac61d9ccb11422894b65f11196e2a0c708247e90c066650bb93044ce9660602adbe60cc466faf9a3116c894999f90bd53c571882fde06aa59df6f884f44fc45fd3bb141298fa8a7a3307e0b9891353f8bbae7ca89bcd3f5bd6050b779952b38485a46724dae7c15fad631fba6ab21042c6125a572e0266dbffcd70827434753dbade3c554d1ef8929fd9ab961bec62b79f4f4859c720c40128fcf2299521d190d716a34c425e246cb6e3b93761ca932a142be5b26ddd7064c263e0b13081d5a12a0a5db4838fb56a9b14a11e8f7bf0d9402a9266b696b29f32cbdeeeba9eef56e8673ae34af6d6f753e65eb9fb94b152290ca016bebb7ad4fab7d4fc91a4956462af5ea2b83c90240ce690af06e58c39710de69d864d6ec581079eec9ba80cdbc806cb5e61714f13ad91655da4fbc8bb366ab1f2ca328ba177a03e203ddda097ddb73e23c78b8987dbe052f1f3c1a7365d95145177de766498b8adde71bb872a78ccfeda778388e1326ce7dac282b5d440b20cba216bf0dc199cdd36e7a4d88812370b6e95e4e133f40fd40ba511e2b534d2c454cf01664b5a68a3b61b3dcb2bf4da06af43cf0d01d8b4e827f589c164920943ac191b4cfb97801787797e1638e29c6a4671fdb07d92573c2db1586ce17cecf4f42ac949a3f0044e850b5dbad95abb3b7fbf4d5b462007646adb723b4df0f720713f6c6f25dabb848254c5b3496397d8d055f2e9dc8b2ce9410565a72128c819798d9f4514a6b6bf30d6dcf19509a3ca066ec3f66fd1d3e2dd110425346de341dbefab52c7f9c1abaa76699d7f4d0badbb7aa88308510bb6f368697c7a8d7c156dc7a4d10698337c154741ba20e4bb2fa0499435effcb9a4a87a79c34b8b4254fd9634425aa073e3b42ea08e621e6f571b0499f1d578cebba9ace1e5fb847b7678cd25f8923eaa6fb20fb81f33782d7e39b78e2180276025e181310def712f32025c3a7a352ba620fff2b2caae0f03ea326caf1a96b99d1065225489b25086b92ace30b6d8af9168c8b3e822caaa4c62d421fccaee175410682fbd4d259e8f9860926bdb6de3173397728eaea7ea3aeabbaf7b4ddf7e0aa60937d6259dc5107be97ce51d2221dd0c02737165f93b4b8eb36cc8404e12990c589527b035ae4c100919d50ac23b57b19847c6167373ccd5fe984faff947baa51f6a6aa4647e48e4bae2e20dc8861f4801be59af2e3ba2cdd89d82d45226e3072273971bef89d60a034f866531665c73e279cfd5433dce87fb92c423f1bcffbfca6af0be7a319b5645a4f36f5534b832f4d219e31bcec0c20c562627b184cc7d67d2c8f6c8cfedebc3a4b162bb8bc82709d660fa1cc3ddf4100dbfc26d5937f0254217ff1be13a7ab8b78bdb1d648741b88d3d968a019a0440551391f3f6e8494822391b9a8fdb8747c4cd3350727ccc16a0cd50550132385531833af69d033915a02e80e0a7b6074838d45cb333935726c7042053b9930ede0748ed8f4d1cc355e45f1212295f947bd085b280ed9b749272e3e5fa6aeb1645b4e1cfdac6498a20912bb1beabdd6968409bea6e8a3600870774a61d013919b9626f97d26aa89d124bf818bc4130202706b0d9314beb9a474efc6b144448940a4ca5df8ab902a403815fa87ece2e604fe59cfacf01562ce579a8f8c23cac9029eba03547f09383b4dda3e0fdea364ae80c6ac2e1e74b23f3d0e1fd992918a3522893461018369404861dbdacb978e70375d60206ddad5df586a988f74432dbec6618bb88d85bff4d439070f114c0bd4d27f6f2e2f0f8c657b2ce94f1f3052e123a70b4696dcac19db4d7f6e5b64c13a3d550c1956debacfe1e2745e28ae3bf989098b9bc5513c95094314dfbf6fd0e2535cfd5d424c1fe8426eb639eb8e772ae30fc6c1f5a112a60f90aa4ef6b62f4b91fbbbde07caf128893473ffaffb8eebc46f3cc5b98eec017dbe724c97ea4dce15dcd44149be70a1822f0bac6319b4482cb3af94f2bde69ed9d3107458df51446aa2dfe6a09389163ff3ba48a6e96a6b1844f457e02ccf63f4eba0a461bf15485a16c7e3fb83f2e376257f8c9170be8755cefc09e94e0124800b29d05484e5fd1cb83234965f5e0d80222ac6521f605d066929ccfc1853ca1f636630982343fb0a6b9580194d84ee4e0dd772fa453c1137f8ff47c492a064776b611ddc8c3e3422b6a72f7398bfa220d0780baedc8f476eae0c657302b9883fa7d3d6ef75a87c951bf1ad8d93cf669311cc8ae4d039c24828b345afd177b78762e43e56f9037b6a5247f198eb42476561236a9fa62c6e644883f38d5496e5eff164615de11204ecf43828ec129839282cfbde75df2d6788a10e269ceee129e393621118fb565abd74ccec662c365dd1133ce9b33bc3eb367c353a0275ad74d82132363ca0231cd38aed4f6cff6585400099ce1e654cf5cdcd965234a9e279b5d8332c5b8f8a4f3c27117a8d21c04f9c5549cc7cc9dcd6cc145c0c49317b9c43897bce8350a6df9d6c37f3be0faaa2237b4f9c38aa84af3c690099de674678539ad8ad323cfce5b87baa179b76f2ce0489909c8ebe3570f2196d964ad7138f902d9e1a4c95deabdc70224f0329717413f0518559b0a8b6daabf9610d481f993b397c036b9fd7888faa2171784f580553e9d47e03596cc0a05b3105277ba9695c72a78e35042b9ae0acb33e70bebe7cc166a751133a96b6630693bc16e3574f0c117df548a8f77fcb136171909294dffcaeed70bb6c58ee90aba1e66ef0b850bbd4b11f3225590704b9e647b46298391a2e237cadba4e818a00f6038c5d94d717b34fe6ab9b8227c339938faaa936f2fc7c732a69940a48f93c444c18e8e9658812ef63d14508dd458525b031d04761cd6d342c1c6db56fc36036fecadb9edda29175e649372b9bc2086f8826d096112ff78ae23a723f453e4b02e74092c4c5190b0d08d910086e095e9a2378642374d91020763b7ff42664f070eddfe98172a1e569ac7f8412a42a63ba5dd0a6434f7bd22cfd78c351096a3731eabcfb081fc8e417d8f5f575e9ea01d1c7c50990457525066b2440eed912be45dda2717d581354e48ef8e6c91f52bc2c523ac180eeb9f6fe6598dfb6dbcb7c9f0f2de28828fca861ec866aa53fc8909d962c8c2c5e6db8239bbba874dba22d6bdea9850cb9ff02dc96b04d6c4f0c9f1c9e30a7ffecf87dea814ab052a960b392199c5330116768f3ac8a5a4991513b5814a12fbfdad7742e126b69bd22ec3dc7d95ee8f84ec245c0280691d4bf377ef76d20d04f1d25edaf18970a8b7d9bc76545fe91b7b87d7699f0abd46ae2daec8149081af17d65c2ec17c60d6f04f3265de6e7174261756b299ad1c557b11fdca56b6d7095013df062cb28ef3560e7083e1be228d1fdf655d8edb92fe0326040990aad7dffe0cc35c8a6f7c973d9f35caa623117ba27570f00f313d437153f26f3423ad327ed2bca8d9200c043355b357f9a6a8d9f205e476492171c7489894ef11c2ec032f86182b5bfc99d280177ff6d0a29b783bf57e46b4bb92d9d46ec8ee0fc34c1d3187ce1c5a70e07e17a004fa19cf89aa6b6c429a1bfa5f6935743f2e42e7a76a8d961ecd02168366290b613930b0f2ec3cc219839590fcb72f8275b1192ed622ffcf0c76febbcd2506e1dc830eb7e168f0410a4725b792aa85016fedade5961309ad534619e613ee56f076171130757772ee1916893102ae798cd2313225dc0d6d1049fa9406adf996da31a083ffee201bdcdb89a8475e85e219a8e45665203cbcc606a061477133cdcb7cc1f2ad4f9092ba3524bd6e1b27608610ffe5956417c9e31809bbe7c473d138589d89bbd4b94dd954f804329fba65856611485e563d129b2335b074b94d4827134eb0b7f575b7a628e5ced3d7e143b52754314ffd0816864d261a9348ccbde4f7991ca2dfaef9853b60ed60fe0e417133b962941660f639a8f121711d47150fd8373e28bae660f6211972a95f3af1751407eec4a645abf34e77066e6ef2bfd0a46354269bd8003e0892f4d45cb7d39329a86da845d1f65a701d18fca17a74f25afeb28579ad3d562ed102a3a114102511d562324f410a65ee83c84083f7e8e78ded7495fa139ede490ef40b0b4a87def334bc782fca81152a90a0454597743e31f509709d053ccdbe8a945cd4f3390af3e7a2a0f3f9f898df4a8ec3c4f0ea8aadcf8ecd5f2985dada50c426ed25dd53f6f4f1886ba16109dced01390a4192a329403eb4d2cdf18bf5f9e27a99319aecab690cd35f930e2e132f890e8f2e96a5c8af6e35476e2e3b5228355c05df8b8ef29374fca9ebc1d9883eabafaa676078eef80a4e7240223866eb3bfcc60e448cd697e0ff8221027d3471c4d9ed5f00ebe28e85af4d2d8656900bd97d59cd9d928a03b3ab3a35f77eee56096f0d637cde8815096b9fc4624874eff83f91e305fba5acc69c627c3e3db0dc3ad85528a6fd6b21f38232db9c862c1d708a2bc91c536b9d2016a09f9e00ba255e994a893840065afc78d4e11644d89e813f278e192700fcd88c2c77afee1595d145d28724c64ac280b70f6bbdcc550a8e89e6b8722c17e972734a6e6090840744f1fea1fcde637afb05b623508edf696411a89dcb533c4703783d81fa171ad4c0448a7843c88a914486509c8294c1153cc3760df224444fce0019407fe28d07cd20ace7a776e86deffb1e61aacb206ef5e5bdc25f0f5b4906e5694247842249fab32909e4bffdaff17db980717d5f0bb43a3752fbdb8d1f268566baa3059bd00eda3caa2f13936160fd95698ebe51a740878d1990db714da9ec4f937abba848e82ce73bfd6325aba92bcde9d8e2fb1cb9348066701e0782498bfebf7747d5b9a77fab0b5ebf67d9db6d5e449615fab51ac3461adcec5a1caa93bb5a9273d15e11fd9321a5ad9b9452b33fcb3d650d4ff972395fdfc497cd50c27beaeec2d68e6df760991ff118f3f095490ae78974356c38a47658b8cf0eaab9750ccbce11851c4a74c1801983110f248ac62d1deeb49f14385321582d1fc5bc260d74ade428ea405202df8afc76162a333bf278d10aac07dcf8e035aac4c0a40657bf8bcc6180104c2160828f1e68a5998666350512fc57e0367f8382b67cc615028f516e615abe8c0fd182e5aa886dd50ca06f5c3a4d14de1ff46963d51bea6912530f09b7694cc9fe6e26f555da64916bbb0fb6bfa6127bee23969187b5518e8b4dc146c9a79862dd64014ea5a50a566003eab4c82d42488bf053a256c42fd09a4bdb54f7610c766c09379c9cc5869746f2ac6697f6cdbaa00427cacd594c35de9f9b00534c842e42bc9f7b90e5f38948cf241a1381b284f99218315369e13804c5c1d41400c22f96fe6010835cea09d5f8e6d7b96c3b544f1c920952671","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1c6df98b199a46c5c12c0ef63783aa325705bf6397bcdd9ecf2acf7cd8add333061f31a8b37b68217fc7b6fbf882275efd3640e1f8c12d121c57da23c0da15d77739a1debb80f01e5f81793681149e5df4136cfd08880d704d27e08812d1bbdc87909f0354a7740a38fcbff0e53ab7778d92310213c16abff3a79393bd96a579bef42a87db2116afe3107962e380d2c7c53be2d5b91018742007c00d96bf0a84b546062b66e3df9eabc19dd0fa4b54007fe87c4dd55c6c6bc4865bc0317e5e2d0ae0eefda27dd57889f2c891c1d16fe14dba65ca125dfb4abc34b9f5ba07c420498d3c3947f3c5eafad044b91b00791acfaa04b20066ba3fc160f206593275551dff36af9bac36e2792594fc93d3f56316981446e4e39cc907d6bcb7865a6d2ec707799ed7f33e42281e7e1786047043d705ab6c348140a2f12d7b5dcabd40239e8d91e6465e6dd114bd96904ad432e7a2d476366a4ad462ce0632a5410427cf70950a5476b189569e5210f2d0e32dc2a684133ad3afc739f7c059ee4cb62f813bf35ba3872c0377cbd10aa054005666f257c04bc176de39244966a0edb3560bf4621c03768ac78e86a22b5c862847914a5e8c5dc89f89e51fbaf5b7b7abf014a2aed322f18b4207c186323f1a8c70d210c92128f3dcef949878ecc8595dc6da5c8271392af634bcc73407bd079004da617a8bd652618a5f16ffe18089d804775b0b70f581f0b85a0d9e1d7a8de6f8c5798b642d382d79a0db5fecf4792a1238f046f07feaeaedd88080116b45aa9bdf8e9e5f676e056f0a450c9347b3309bd290511bf84b6845626fb84ae2654bde650bee126c52ac6e869fa318fd3cb48e27dc55a6c8cfe31a8d62cb10f72c8145051d527f8c9f0b25042180dc23c4feb56b301e86f6352d58decd7a0c0938599f35065866d04c91bf2bcc94432942db70f11bf75c4eb2b5bb4341b201eb8fcaf44da35a57743a4ac138b485863c96476e62d780dc3dca68c80a7564047216e2dcb16e3c0a9d2751ad7facd37eca8ca7a40a34b443ba506e432d46f882266a5fc6669f6299df3ebf7af67118b65ee689790f01a02e3e663b5943b45ecf2401274faef039716ee7de5f843fa705892b1f718bc7471d6039d00827c1fea18ca3ce804ea0957d44ae3c715dd199160adfad63891d735642baba9866590eb5c6f54e6bff4b665fe651961d40d1cb5a29121376b8383f3366e6f7761d6d75510b021391fb00674177d6abc1004a951615f25bfff89998eb8763ff54a8ac908191438bc4950558645406b2c6d48ade8177b20b533c5d45d25fcd5e8681fcfb583c91a0894a2bdb706a9e0bc53d9b40fb1f033989dcb1a19d7943a935e8759849814fe178d59902bf1f9c60ba14d30030b000497d628c43eb533f70b21efe925faf19f4c0453cbccd0e801a53082a6b3e6c89a593beeb5cb2ca591c73bc449a005ab63f569f3d57fc773a3ffd2f872328680fabc17e8d271bb66203037a5a8af7335195dad6cabbfb915985843a2fb5618994b35dbc15ca467bc9eb51eee21937bb0483433c8179f087ca56ac8e071b6a89545b700d53362944bc6faafb0bd070db25c373455b672462d51d12edf36d08ba5d867e2a9b363e12969e0c58402059071c6e95a9accff04bf1e9407d0cea5eb5d8d3d178ee4bcab88387c5c2b1cfe1339b414ac24c3e77c261b70ce0bf4799c820273e65fb519609f61a35d66daae387f1ec6d04c5ca98ec308e7f5ba5d44342c6b920980eba8fb7ce0d935a414f7423dd27ef54df22b486a2eeafe555bb198297edffe3c833d40d1e23c9921a8f4764c617963351d56fd215d4a554e94eaa6a4640e313247532ef755f3e4caf1ae9fb6d5f80d544a10170e72a9e6c74af614d814b4fc8ed668ed4a941857a6b8c9f610ca8272eb62f37ef71f746764328abb6d10b70540769bd4d4e912fa8c6d404f610edd0f36e49b706cb3afd50122052547543716eb11377b564b41f7eff7c946b4d795560a8d7cda3926b0da8fd44ac9e3386fa750548b13dac7e84988dede4880389c311859174db9629f365b822f9cecb2000e7896e4677127a75ac0a75711992e707c7d4916f6c899d749c05807e2e1e745f3183345fc9f6904d252597b8ba7a87ab723ce1db0d7b894a5e46f73e8f013b80b570bdf9a3f06105cd9e70c98d7a3bc812c031a559a9ddf9ed735a5d830faecabfc0504bb10ee4d15431cd0a26ae9843340cecfa2b00c47eeb7c6c5ff2f9b48d3edb0b56b74ebfa5a6ca45f85684d2e39ac0a73e2e490d6a757c4e145f43818cf57b0276f617f4ee878f08d0085854eb7cdb0e1344e5144ce7037b9256d561f0cbb1a89a92f1960acdca2c4b44574ae79633b03c7fc9dd5e2533e040661c27460dfa9835a2a467c741cd43a737e83cdf4db4c99aaa95b594cbe35f4376aad3a35f94d2f2f2b6969495889b75e71fdc913505cc1418b898bda736c58dc3cb3f6f349fd772f6bee98d8e42acb1e2b32130af07d3665f16d80056b4f765682936d5dbf3b4017ea8152a191f0cdbe49c765b43ae99f401400c30e0ffbd04c801f4ca7b3b68aec7048926e7e5294594b7a2edb3e3f25eb048a30c6c358f885b41380c4806ef3a018317f7b85c187fd2dce06fc2f036359714d8cba76ebca23785ebc65cef3b9094ad46c99e0196f295c0af621df99829ddcf0b8d8924619147abb15e4c3fad1d57d68cc63eca762288c6c9ca18ee2dc8dcd55ada37a8cc6dcab3816610aeb07201bbeade6dc6a595cfa47825adf62f634943f08bf7c2fd0b4759c4d5b24f2b173df112c7a43ab716dc3ec6fa598f1815473445c01d22062d72477364eda8ff243e7f9141eaa6a672860235f51de7377c1d8b8e510b06c2b7848b690cb5e7ebc1093462c6737710946e7269a1443ba68204af1a3f5dfcae00451bb63b6e06858a29572969162355768ad2850e18b7f051047ed7d55e650d03e54c7992771ec782c036d54a6c5b5ef72e0c41246049dd2188576c3395a3605c5dd6aac14c8f1e7d46631f6a4fece417f5f2767c1c4c02860b37a849aa7d42a128144f767063d33ccb8cb6bbb15b1c42ac9e3e0fd55634108b808049804dfdb5d28da7d01e16bef2e58fd99aca11333a273df3528ab9a2d63472f020305c6ef9e860281b987a916ca94f1fc9a2997f0379b51cce24250a392c8ac953e8bf2ab856f7292cf7711ad650550e02c893dd17881cfea05b6a60a96fa849932e0743067c75ad5538155ed267ab457c28c55789392e3adc3af928b59a02d7acb35eab5d57d278c7d75a249611eec1b71db71935936214fd52df61f193ec5ed568aea5c5fe9f5ae874f3183fb392b57567640ca022e9d2a75aff61bbce5d628f52a1175b919dd2938bd40445f1830f0a027e811e383e0c3660228aa6b1b19fe5ba5e07581a2c54b689603adc3b66b296e586b4ce295344c38b342eb47a26ee20611ac607e625cd53d2741d6920e37b018005d48434c67d4f29eb803e30bbf514129f7ff4185f5ae427641bda3eb4a209f0c2c42ed0939ffc57b4eb753c7d202347cdbf2b04e8a1161ba078113a4ce30b04da85607a0b3a9cf0f9aa8b6c22676395e5bde224511eeb66781a80bf762b9ad33335cd026c18da1d96e4a57cc72e492eee5b4365017371adf7d25b999843d731ec64a2363fe012daa0ca9fe485e33ef802c292ee4a2cf712ec96444db5c695b1430ba6e9924d1dd5da6f135b3fae16e4c1dd8d8997617d0da17d4727a7a5b7f965b00c84e7fab358163f4470aec606c8f04f4695c225f32ff82caf7530d2c9785efedde1e5216d052100744ee9abbab28cc31eb533c3e9b29097e53dbbc5948919647188bca87810e3f385b2c24dc3379003f8445d42245c665414c79853c564ce7ec42b53a9aba25ff6a5632ce1d1cfda5c7cde402889779bcea740126ce39126120dcee0b8fa7c9583f94aeb2959ccfde76926d065fed01bc26b120ce1ea0186f661206cd206a00118a887084d1af6d7b8f032ab39d109ab59aedab49811e7256abfa3066ae294acd7f863a641e47ef6cfb3fdb7ad0bfbd09c5d513d011e34226f4fceccc6be72cc68e156eb19d55eca6daf8019af55bea5d03254fdffa51855b649eff448146ea16ef8bbb8589654813019d3d6db52f24851c958f7faf76459c57a134e7168576b82efaf3ef2789d91875f2a208b30a26ebdc4ee0838b5aee0960132371fd28d463b76443e287c2db81b84f047d4698df64170448e8e23391aee278c7cd9622a7b7565039965e5d1a6d6d2f493c659e423a97acf0660fda0594b8b9531d3f38ac87a3aff3e98efc0b4a14b41ad77f5b1eec522ab245feecaf2369afa7879ffabd690cfed159452d6527791bd192501c5ef039e004f614f91c8b94ee70580e60d71053c385b0bae6685291ffcba3ad57447d226c3682d49355dec3758a3408229c3aada3bbd864add31e31f85906404a45a811534e8ddd6b14b4db4e79bb71b354d5f3bddc8ac10a04ff68d003204d68d2c8ee1aa4ea0cad3ebaf8facb7d003f178b70d04203eff4e0593fce49c973deb6486da37a5bd80b7e00d89a23ecfc16905bcfdd08c256cf27fc4e6c2fc9dd7eabd678dd244a3a77a34eadbeba6d70483afdefe5930fb662adb8947bb7a0b7019c3a63fa7d201dd2d071dfa1c0a3a0e59c4b4fe030585d7d92305410f8d14676fa4709118bef57e917e3a9490ce7d6ca0f36840224f079789acedc2703fb9c8af6c6bc839b5e05b0b7b347f8e15fc770737b81dfdd256da7264f2926d6a9ea7670731e97facc5e7dfc181138711bca86c82c042efc62b40f39b25228854a98afefbe255cd4d4d7d9a92e90dc4110635bba7476504c403a3fe144e010df883f4a1ebae6cf5616f48151afefe021bec05d6dafe25fecd48ac734cc35b34ad462031589243d963126a697bdcd46dc67b9f7a1dafde43916e9cfdc3ae9e43da54c4375ea455f527023a45c287ef3d27d6b9ca5832fa7b70bbb8929fd918650a44b3f8741041a013014cd7d941ff342c11b40befce06056bde420d329ef1f60eeb1d940e94b118f5f8d89e2490075ca7026e6a53e9a94a8171e77ba368b17a68800f88f78606a2af449d994085baf5e4a042fdc48696ac0622f2043f83bc464d94cc91c7cfd18ebf9b541c92ee078272bdff73288c1aecfd53209026b1e9e0ac305af6f53d7454dacd988f6b6dbbabc870477e20ab17eacc922d578974e49036332ea52f54122bc282e52487e0041ea3e3950e2fae1b13736ed808e0594fa20764acbd6cdc185f856d2f028783e2d496423e92847b86af80b01b62f4b84ce40994467e0d2b210ff60b0562b24f0db2127df1c9bb95e628d8b86c501c5c3d96eef11abc1110e0632c6f78dbd8f6efb622a697c9751b3336620b77ec81051455be894c459a4026d83bb7d4154aac00663be673a60d6b0d970b3d320b5572aa1a1f0653a99ae05717693dd571ff053f11769d1f0342b3c80c8e432eb304be30b00f1d525dbc374240e293925af1c1ecfb74f612bbce176b541e6d24cb64064b1f0a3afc19011b018f0fea5f97e2436c7b3328b6bd27ea4360d43d1cb3faf8bbde11041671937e9deaa4bec4fd60afe6c05b8012fe80b87c23a080abdd1458ce5c8db1ba60507fe31d5876084bf48b44daac29d5fe66c93fbda62f22fb79a5f8af3962285f99eabcc5f1e24a32494dbb7ba92a6d5c53dc69322fb18fcab44a75bd6136bac9d18475f97c1bae4a0bfbf53c147486145d765fcfa1fb704cb2016ba801537f97760fb431e5202a5a212bd13a648dc4a7c290d890e9d79559a0225a1f19cc4ed669061d39b1cf372af3799d733d19507b5cdfcf873078c92a34959a8e8e14389c3dbf83524f54b24d1b6b2719e8e371ba6239c9b9ab60d99f4a59ece98c2598e3d13cb839e87aa0d48b5ad42f0a7350188bffc5c3e30b0695798dfb42614b5e4ba21fabf8657ff3ca243b2ee2be7742187829b41797e88a40150401d09ab29196685ad0c965f3bac3c05ffb37b30dc1ceb048c2a99121cd1f9675db8088fb99f37d5de7fba58e574ace4f9298b9153d10586084b5065437c568c701759efc15493ca10387858ca0c05ef43a4b2e01368fdc3625f60dba2a3a5f1eff38ad935c5794732870a11ed9a5ca887524dc18975058cdd9e6276222fbd1bef7838132e8333befe246e868134b390f9aa4d52d7afb9778bdf1baac67a87acc9a348fc800d8098d72fb2c5a4051e2da35533d8cd02cb62174f8764228612de1392b8478e8c9ed075034dff0201dd10ccda05ff91693fe1e8c1e9347d89eeed0123e8a3d9624ae11a2b71a54728e38b7de6a7c4e8e10564eb2c06ffc5d567388333f46c515050b4f5477cf0875388319f4bf59ad7b0c9df6fe6f6b44cfdc90a9db2582c1b325e393391ce3e38946532df01d530979e9f61cb1c72f0ed490114c734510a90e9d5912fc0cd8ed8c4914b9ab1ce41f87682b22a206a122bf2348c19977bf4a630624f353a67999afba6f7413b6f4a24b66d9aeca3a29b54ce98533b585dc958be468e83a42cfcb87ad4c555e0036a93b4bbc28291525371725e794505610f55beaadfb191f6db872d47cd3b48be7b4f1cd5ef188c9b011a69700d2c4bde9f109770a4903c05b831997ff8de9c3b05eeef5ca6db2f08f3a5745983cee2d1b3b4132c48acced35961892f4f2c6bd0c5d169803ef71df3c0ab703cc222b8b5447f6eb1fdb13af96beb76a80e2f620fc24e2988a8ba84401d56d846d2c795a8d27c2612f8e4ebb2cf3fe7b4624f645eac3593410483da55944cba732d51715f3d4bfb295fbe391783322263e353be0618bd07d080d7054657dd22e9da96437b906a076a7f81d15a5e5eee83f656e7c36189522274d62da37cea7cd361fa15bcb18b6147834a3fe49440f609a76acd0877beed3d402fa82a267fc2648965020d73ca839404050ad07f45565339daac35e66a986dadca6b2621b8dabfd4f415e0c8fd8a1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

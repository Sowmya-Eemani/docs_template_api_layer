<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"96b73691d7f888e7ae0d85e4a0883968a6d485858eeefabf43b2f22a146b28c26fe9deee0ce4a0cd8284fc3cd3bcd12315674309c76f4d5575d16da7bbae0f64c52c0fa91e3ac7448da3277df91c6cf29ab99aa5e20844c5bd0ae42e74c23e76b435cd21c701f730644930312f617a2fc79cbd8d1c260160c6779a2219faa138b61205d324e1690587b2608ad705ffcfc0fcf787d971d4259e0cb4c4dfa8df7f9c2e136f07bf52d721ca66d067cd1cce2f6239264f69f2fdf2f539988a877f58c8be6c3e6e80364b6637c166c57b5f7e58eb03c7854ecbd0f1670038cb1bb55a33740a63d545242ce85325c83ceac823630967da85215a49f350969adf26042c051d0c93efa09211192fb434d348ccc156a0d1f68f8b483e28efc8720ab48714e78e38e7857535225acfda03ca3476bc6d8f10c8f44bd9b0859301052c5cb138ea986396b3bd4122ba76f1646c8e22e18e2e42a9273b599b6f3010f8c3b8da4a1e9b6d6e9512264f8fb55f866990d24eae234bf5c6b2b1d24e653f5ceb202e9be5e7fcfa99de2a30b8b981fd6868a284620246f73e9b701fd247cb50b6b8c6b033cfec40e01986fd70c0081d175d6ffdffe42d3d9da0d9e2d300d7db6f643046b9fbb42823e3f68bb7b8ab8d99d0ac9315dc86a3557ed0ddd2f24ceaffc62cc25d042a7bb8ae9ac452da4e72721b3977e25065ebaf9c958aacc37ab5b3e85896c98bb592c11a13f5bdce07541ebcc76594445c8c4c786e626d99ce6a900ded1ba8794ef9f09b727bb0771214087a6fcba10e87f292874833a4f446f131b010615027a0ae4811d380af3ecbe710859fa333852c6ed404f8cb227c54f1c26914389dcd21f13b4819886c2cafcca0923c37306380c01d192e7cdcc79cb9c446082d6ca458015ac7f5a2e4387635a4153ff26e0cb22c9e0dec7d7f82b91eeb1e4872a34f6dcd0927ba1b52894bdc325f199d1bfa98811e0f14ac33635d6afab883cefb91fe8af12b418d295af48bb1ab7070a4226be97a3b6d439ba3aac5c4936592e098519dfaf020966036ffaef52c0aa5c6937913e65c4263df2095a6d8a6a3efbebbe4d2cf5663ee49129e7f022ac673938cf2e427d17c138c69c3f48975ddfc998e47f923f1a0dcbff70bbaa4b47eb06070c61920d7defeac075bf2b947f157e2923e998f237bd8240381ed9ed538c17b0ca72ea0e49f2b4c4d6b0cc71536a41863739788505e8f11b2072e34f203ca714158ab0455342679ae514678fc133fdf79f72ab1e8dd20b2d4244627b92e5dffa055938358da99881682dc25c9ff967acce4eb2a532cc846e7f5a4af6789873c59acbf9d0121c98f0a24b60c6d72b729d6e0c95a733618be7d972f96d04e2c781d8557f1990aeb37b3fb33e68888926c3a7a2dd00cd5de7e7a82e465a5f7c6dd1dc130b6185e3ce6ca88392ee49d0053c03bf88c6f938133bcb392f8bc9717beeb0798e4fb06b05817e49a6a8a761f99b575e77481820cf36f9c44222f21b2be81b0326355b0fb064d9f16de59332f0364900b422d2e8c9106064e6d815e80e7ac0e0b947b51441fb288c601267cb2c76c11cf9e5c3dd6b718527558381e159374142e5b137deeec1b5ad3b3d3481222734b268486b4fb2efc7787ba7fae011611bf825c7d7aeee37839222ab9e8a021b7b01311c134d8813eeec5ad378dce288312582a53bd6b6cb64e7b984ffe03562c28c11047848c3840699105c24ac196b71768472d2f2b20808a26768bc11bc7c17409163f304ddab1146f66d013fede3c4ec81b8b160158bb8412bd0df35c3efb74c4f8e3bc1336f08d5f4ed8ff5634dff9d11c20b221f0491e6c9a11f234c4db586c410aafa4bf83ea54f221c40de5a6ccf7db2cb32f211dda1dd1d8d29172b6b8bc39749b90721e310304246a512c196aa99f4587c3d1a5f2a3f4741eaed9d4e19bb4f506c8079076f581dc42cf147fc48d9f13bb3f036bc7304bef06e6811e973c21ee669e7a101d5400ccb4dce0e973255fe963f1fe6c6804834f5a571d0874b71991501a8cb4f181dbf5db217a904f69718f390c02245fd960b438e421e2914a98edc610328eb3e91ef9c09f6226ce3d9138d9e102238aaeb36d9ba13ee21e458efc6cef5a6e87ff2496d11c8e5c9050f78b6bee96efaf940b07e7663420ea27d44b87670ba1754555074f57889b7984b0b43c8eb377afe88c6ed8b43007e9abbfdeb73a39bec2b1cfd7741a56b2f25752b9426df3f19bff017deaa3cf0d41796eec80c1fadd48b58684760879238c214cf31328d891dd88e88ec87e58c72ada40ee0e841d239c835635244f8ad5a977157b121d7a0ea9e6d2549018d87860824d0a08fbde3e6cff1c088901b1392500516aeb66aace154da57fa844013513800d592145e4a8bd5f9797a8a2dc0ffd4f151bb569ed3205bf1b848845cb35ec1a0e8300aa03a73ee53c0bf1ad4d02a92a534732cc8e036d514df95ab22864dc0c25056139dfc7a752c40a22ccc3a80a94821cbef04ab64885bebdb3429ac504ed8910588d39c25239bdf20eea9ee233a4352a00d78a30b37c297954e85e01b608b8efe648dd961c45577d32856f88db33f5ccd725f79d371b07ab714726cd77b1f18443bc741eefcdb5d7837eccfbfc09ce63914d595fb1c327a1f2347a3a506a72f6526b1f744000eb384aa42f5eb079d28489a994dc24daaa95d2c42fd78bff9f510cf895c499b39661b5d1223dc06ab75f7fdd8670fd099fe232c630436e5f6f8ad4f49a2fad27448a9f3310a8589e0497838f3d0ca6892090007db7170566b6f06b526ace9e7cec7892723a474f376b1ff0fd1946dc5e7ef5c2581d945bcc3f374514f23f2353a4d79cc1c0a5ae192aef56e22fb5010e244313da5b38bdb83b06a9407565022f67d2b661ff42bf1d571b862e37e1983454e098738f458d19fe680b8c72e35090929a0552f2bb8c9cf81eea175964825ee572aa92c5411621f96a8bccc6148255823a6c1657793f06e190e557c57b7b61f073765428d220827e1e7af0ed1607031e67ad01b9bc79953cbe8f325f3fcccb29e95e39d875e9237cc58251670d5e8ccdadd4e7082ed2c80223b7dcc97e20fb87441b8796696055c377070578a51d0a09f35898c4c4c96694d8490167d91bc934cfb2407f253d95a250a9928321672a5914cfbfc1d3bc550c1ab5cfff81cd14cbeb5060a25f84bf91d463b34bd8eb71b472ae6f94a5b31af13d859c4e7458e156320ee997c9f2c7cf17907650473e17a1f9ac28feefb33c3d357a785a348fa03eb4e7ec6289b194b1459d78c37d45b891740633bfa1a87f1654690d2ca0d64d17fd24bd77088d9a3d2f05a73aec8e21d6c73ffcceda7e58704fa0fa3c503853b10a2e64d5c9fe48c8960c2d8eff6f033ab3d0df0cb76d1b27a62c9ddea1f3ecbedfeef77d4de0a3e6ab5afb6b3defcdb8288a4eabc9dde5033ac091dcf2ac36a66fccf9ebe0487824c81bda8003a48ef6f33a9ad1c8196085808b80ac0e6b45e3080bf50edb3ae62f764b08bf2faee015dfe9a33ff6b0dacf9800fdb30d87ccd9d68bce6d6b32b4b69902d3d0c4855d0b3e8ff54cc4880ce8629ec0ba0cf58da1500b264c2795b38311cd57858dcf509cb150f8601dc6a82e4eef674b1eed4f1f29fb27f07d1f9de912efd4970db8c3462162a8fdc909816480273c9c3b1b884b03458ab1e6008573f3def574813b5df24dceb1fcbc4fdcf72ad605d7adb1fb99c818ff17a4d985fbdf24af502413e904b4d6415f519b341f04a42945df2d35b3accedd9adb22ec32d33bbd584cc8b7389ffcb39c7b4ff20324342cf3ffff0d1f319c97b45785b8c68f85c95fbd31c8bea82f8275e7c76ca31fed40913bbc79205b598ad024e08122f7fc07f8e7eb1afe423450aae7a177528f3a91782b00a0ab2f200fae9c87794726e2f2ef0b49c720e95df45d662bbd7fa46d995968c349ea5ee8ab7398f5f9b168381db5f52cb43041b2ffeddfcccda4cf11877dd74ad79f7721c29b5865bcdc2d28394be89bf744b6d69b49ba7c7448271708134527fe83b01a5a121c5a2b5856c880a5b83cd5dd67703cc63a02d45ad8233321205988c76c03fc50383c719018afc7e1ff2a073f119e25235b9f3bd4d2d396ff88ad412faaaf059be3d99b8d3c868e1bda3a81f7a331a84fb96f3658b85847472e0cdb7e0140e7ad4d80e8112532bdf3c59461adf17e2052a758cc740b335c4ac8abcd011d0fa7083f85f423dcdf0a1a27f2160fc5702f2dfe11982c20e5b323ea02d2c96c4908a7e1cc3789082a2df2b27bc207f927ad0e2767d7a6a0885138419189ceded9be43d37aea2b11d301bb5d96a3fa36ad06b59a13adadf8fdb1a982399e2d25532c9d42ed888d28aaa354283ee7bf17b865148cfab0d03fca13e645305f135924cebdcc202324f6d42109a1da342979adccc7b4b4055977c2738531114b767a8d160058c7f77e7c12dc8dec248af433676be7124b96371ad2341b0a01ca0d4eaa4be1e3803d755820c7648756b0961c907d445950ae5c4d87b065e5fa0a4714f416cd960d0d2319d56aa2f8cff0b604a7fc9acd505b0573cf208f046f977115fbd89bdc14fe9c3bb2913c44423cc86e0a163b03cb5fd53a74e1d97f18343d78b13f57388f5f9df88fc6f7121978f91322f69a39faaa1c7d5b7b74425b1b48c907dd53336d04c1237715d26b13334ca9e79c048d07d448ef90d2418e3872715f436b98034a7ea774463996e3c4371df92b0bd01895d7049b0bc3e415849aa88422e088d8516859c9b1b8f22eece7242825b4f293d3a8b0d293d1a426248a74eb3f7d06df7b02af4930437cf73226216ddd00930a636acea32fea4dabbfc0422659d53f58e7b8b92cd42c4c8f60fc307d52968b9779765346842e30dbdb0996bbd465bbcf60fcd7e7861f27145cb5e2a20549e582526e1b42a6b60d074b9919c33683eefe707d9f281d0b29bddb1d11c52a7c327ba929e82947c9b4d5796b516966efd319c8ae858333fe7458c589c6b759379ef687ffc1be81473ffe0aef70661813826c52c6821ce0b5c8af450e5bd3c3f701f61efde7330c31808e7ede66d751ab6cad5298ead99f8faa3f04b2da65c192f0b1fff1f580eef71600c7b9dc5bdba9ac7e24288db799146afbaac17764ca5f803c2bc1b8b7b1234dafb4082c62a62fdbe28676672aa5e20875904d0c88dfdf2a91f9da175858a662373e1744b8160e839a8b48f03631b52eac40f11e7e3d252be76b3cede998f4548a6a9801bb798eeb7a65d9fb908cd817292991e70ff545829014398a804072f182571352ed435c00946b668029c3e73a168ccc2fb88213ea00f57cbe4bc56e57bd01ae1538925d439e01d2d89c4b17757da20fa463acc95b4b51bd9e00a50a561846ebbfeb93f7dad10167a41719aa06e903cff5b7a3af6efed02722bdd93a867758a5e65e524912641caeebb19dead4b6a2064d68e8d705795cb7d1bbe17e4e26924dd1a1d7d75dac3d84e86f29480e8f3bd4091a1859129ee6dd532fbb962aea9995060b0fae3614934e8c9df9058265b17e84407a0f207069b90a048e60db20d3925e4268966b62de2160e9ec1378a249661a2cbec6a9806edf0f2cb03a66fb3aca64901778378140beb7a09f8560ef7db8c32090d8e986653cf6d42c20bcdd9421f077a057a2dfc945702dc9037784a6e078064117f1573f37bfef16ef61526cc14482841544fbfcd65d5c184906458fa2840ddee4e754a5279e1e2614b482af91a334452f87689f77965a09dd6d96ea5251c4ce8bd4f1ed6caa7f07a10d82efcdb84294acdbbf4283602a783bdf4bfcda293e6ce251d7eee7aa9973be1424a757cb4142eccdf8c3dbedb0148cbe17182fbc9c329641f21f0f33d852c416693452ed42e4ac4407cfe0858400593dbc8424769a188e90ce26421947f5d6379c7c5035fcb0d1a37e89f8f6bfcb46bed60f046c34aad9a31a984424051788fec84c2cf4b67352c7fc87188cd2d19a0ae16b18b1a1f76a2e84f70ea79818af32ffe1bb53587c1aba524acf6c9b96ca2d93a5e60c003a0a413e7c6a9c2aa992b5c25af7751f61af32651ecfe8f5a90eee2821578de816ec463531bcdc63556197c17b13c817a3763666082416a7e827315116ae6e67f3ebd4ef979d59322cb8ee0e7bb6401c60b387c55054cade1c8b7763879856a5d711799950604083995df3679861705249fed9974246d0f201ac24b5a71cae8eda71c51d2f476395f0720c4126b3971666062f3ca475a0a53ef996acd73f9d4f1ca70f4773024335a2aef76919c978a9e0979a29a3e89c14b88c13eafd8fb0ace3801c9136961bc15cc5609e770f5a5915343b637f4d287d483fdaf85df9a7b4859791df1860cb3f7ca9521616f05b9b417adf10060323cf5876a732d4242ee00aa07ae24e63625827fe65828d3b30bd89279e7c1bd6b959f7a7aed1558891193d27323a1c9602ef645dbccdc027475c2253ae25ee1d2a8ca4f716eda58bbc1e73fddc8adc46d2b8f764d691e9ea767e71c6b5fb0de792ae164812b973e78661e7c3f8dd36aa56027be2daa8d4d1bac00e2006c0f9ff158be9e7dd689f88f285e79d31550e09edbe8880d9e62e08acb3c35d2333f48e47d558e28cd0fb4898e9eca34f7bc2b8f86d7dc3646fa448b53170daf4cae3fd08aa05a1c1d0649c2cf593b5c78ccefb933b4be3769781c614da455112b8a829b4e99e35eddb9ae6cd18d630cc206330565b7ebb4d5e87428472e4875490e91bf9e5ae39f4704058ccc0274a895cdfeb561661cc26636a66d849ee5e4336eb2767733e88eced95207e6e70b1563b8b5540601f18b2afa1ce020d7f3885a704f6567ca0bff4431b6c6f04735d25cd038d3fe02a7b8b60025a1fb7867402e8f934ed0f9e92bdcb9673853f830495d991f80af8ee0f8133cec6aca0479d30cfd80b4815652ce2dd18292eefd92448d758475cd31d493d13d87c664ec127","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

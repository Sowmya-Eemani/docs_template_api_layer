<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6698cbfb8049311b97450e06ecdfe4463e16bad756381f32a3e97d8a9e5cc68c00186be49f210ad7f29e15cf343f8cb2e4646f559f25fa52f5af65e9a2e3bb7346c7d6adf0c55a1c7d141507cdaa9b62eb88fbb919fff5ade63e9a956f64dceb31e4cf4a403c7f2b56ddbc6ffe9c53403de4bb06dcb54fb2e44a506d8b80d58af56b5ba51f042e993f4b67ef6e4ab35e644340fef8549a6bd58e8daeac927e53ddbea44ee262c35aeabcd64c3318ed569de9d7800d2f83f623d285dbe43a691917ce02a1b4e5196946770792ed465ac29d10a35c0740fb470fd3d08522de08b3cec8589114ab1549f69dbba83d6cf199809371be84efb30fb97e777b4128cd0927eaa1ba7ab8d14722cb4a5222f678c9dbb248cb06185f77aeb489e4c363d4fa7ecf828d4f2425ffd234b7b09b19480355e1ea55e9d8c04c9f27aa61c3005276871164194ab377ab472cff1447e90c13ba70012ec84bd12d1feb9272309bd58d0492fdd7d9fbb1b004bc6c9be67743dc091f4977a738ac1239a0cde0427d515e31298ec66754de60943d1919b8f7097888f619d7cfb26ea29a34a09e2717925b26dd12b3968424c400c1ad026cb771c0459cfd7dc40fd2efecf3538aea9dacc4d31dfb08cdebbea042f1e70d2e979edfaa4afdfedf50aded739dd14d92acaa97a7edd6fd786f6d509b093d5b8a955ae3e32ed84f2d583c9b67c82cff0e45283da15d4c8bc0bddce160a8e21e3b69f3d7a6b560b2f1591e60b52f52ddcd271587b89833883398bee1422ac59d31e8e308436340e466e5de61779f577008f3e7211370c94a46f57467e38c0dc073be035eb8101aa383755d1d2621ad3a3f759b9ca244ae56889fb54757e4526c5abbf87d84510cb00f7572ae583dba45696f75a137216d2a6a25f4226be7cac7a0f358f441d780db610b39b0e2ca9de884434cba491bcd33b7975198118ebdb496856a73f5231fac5e8ae96d2931c992a6548fef896b50f04d8401b5b525f1a8d71cf7637dbad76c29963aa38cc8de5e4ea5a183aa1de14cbe8db2d3f88c1ac5ed6eccbef634d8706b6a6170210bf35c9d18bd289be92231654bc1187726bd184d7496d60d56592387cc5037f3ba290236d20281887a4ff7a54fbe1e6c392f9f99207c0948d3c56136ece459b13d4b66602cfaa23432f8ed89058cbf0805829f11e1601add797205174984f0b3b6a2a15658e09dd83df65d57e0f0d0e40c8255bd4fe3ea098382c094f1f0640d61758f44f7bdf843a8ce8808f6283e0dfcb85c371a9571ef82c44ca0674dfe3d992ec7e65b46aef5107b55c0c95e5aa3ec5e9a46059948c92cc54891f44d1c5fb2bfd9dc3b2d7bbf3bd70ed65a404dd106574c3b07d8aaba54f28fffefe1dd1211e74226090ede5768f5aa4c11c756b938567a6bd638309923ad66080906d4171d0089fb6bd3e4f40d955b5375d1d9354a707ea67d2f1c84e90a9fa3431325663ea946a41e2bbe7bf0305523ac91cdfbdd4bc85df49b5beb0c24e26ee4d8620ab6f47ff49d781ea37e292d86e8e0f76258f7c9898963eb7e6313acc5196b0952858dab36a5c77f4f2160205a5e8b908da0ee4d447d3c399d0cd1dfe2531ddc6f9438e4224c46e2f7d5081881488df7bcc33e0c7307cc962018ec1da313880862d888b960ce1feae4ab337d84f9ce8c657d0f799de15925df50b78c73541e1cc049616dbaf41258a80dc2ac84ba721e011f93f533ba3522ac3a94237a843b3ea26216e7b98b8d4ed9b3ff3e035530024f9c7a17dbc63b43a9bf90698fff33162306aa308267d86d91276118b1606742a56c2b7f30f2c93f9777a1043d43b8829771ee7280fda227ac40fc9e6ff942938bacd68e5a42a3652ee02c9f273db69bac2d0a05d1cf7802dbacd4e744f7080e79bb41bb95b7bf2cf7e763824eaba0ef239cfacdc9394f49f40330381134138d0d7c22e12db8f2b059dbbb41c798624feaccc4b5f38f131b01e465c89708f9650089e1593b452c3d1e8f03d6b512e176984e0d9a13093aeb97c9857336e96b1f03b679167a8924e9fb7efefc9d2ba3db4e1a7efbf7a2482ce77be59ecc0d7b1823cb09db10399481174ccb8c654fbae1ae623b2b837712d1004b6f5c817059c904a7313c1a640f8864c2583d8cf2542adbeadf1215d7f232ff6169f057c880d9260dc16c9068b16bdcbb3c9d4e56493679ff9d0830c965118850d143e0f8d57b055bff7a34aaf7b9ad96e674c4935e628505b58ea156060fbbd3637e91faac4713421ca94309a392ab7f9755e8ac675bc0fa031809c3c6d647e27e57722d1926ead677d51c67cbcc257b0d52b0446f41f2bde31df45da04ba836f6fa38fde0d99bc707994e98cc630f9220b5d2a0c47887518f36119065d51caf0cebfdfe43f7a732f59d9260f989b8c146c8abaf2783789dd2244a5973b530ddd504d4592382352329e24191aa080daf93b1cb3225ce212a07f6578833440f736518a32897fe7ce9f73e7150d7d73530b76ddec31bdf44dade3784d325f177ac9976b7625e4c62de0c13f9770477027f85079242f2b0b08b6db2f65f8450060380ac5c0bc3e23b3b5c2d8cdd4643960e3dcbae24bd0bd8f8c97c550545577d6450a7f564c17137b142d7dc172869d06e7c6f489677392ed438e0e904a149b7ce5bc53d6ce1fcd2ae856da03347cab6cfac0e69b0f721a5cb9792037ba99d4a6660a93e8d573a27a3e304888bf6aabbbe3d83e44065bcd1f46466b1c211c0ef7af0032c6262d324f6ac6792eb0989584fa7876aa9604566e467317decf765f02bfcb144d9249155b715ebbb3cba97c621159ab8c8a88bee097af704e9da27319e9947d134448056eca908076268bf0525a4cbd1fb21c3adf7ef1670c2003bf4a53a5662728a747de92a09ac4b7038bbf91a7212ce951bc6fa8ba9129ad4e88101d8d5779c064a45725ffcb55cff75b47e7cc4159d3a48e82ce8258b23c6cd438021b5cbdb5ae752eb8eb6fb7a926ad27ef420ff4484ee66be1e9afbbeae03d675774decc1a3c52bd3017054d1c27c2ffdfdb656a887d0cb8373336556e259113029fcaabf651546c572312e838daa7e322786f07336e4f1c4ef4a0e6571204fb51fedf82de972942c9fa018f26b9193a55c7cd615c0fc575f9edff088823b2065aa393d8cecbaff5645e7ef3976b60f58d54ca1324579779d1cb7ffa50d01621ae7df85c3ef52f3fa6a18ed3c83c6a85058132b6c847f365d0a32d956a919f072f4fc750403f21d07c19e314474d78ddf952586e5ae21fd8eb0d75549600267e03fc0ba1fa0d90b64818661338eac457bc6f8f73f315a11a9d44213809d89e116d87a2e3705a3032d422c674f5595c61efeb66dbb692dc96ff04aa4b1bec3d789054612a54edb4bfa3cbd3b92cb2dac18bd42c9f5d3d28b7446a62cc2dc1773d1f7a82579623ad8b0b29c51684a93005046be5e6b69328c5bc25a967ee259dd24963f197e3dc6cc9c0c38b4552dc3c91ce1c0542040592ac70ddb16305824002322b9e8c2e744a97693835f878cc234acae14af668fc27f64b1e70f804440748286524028ff7f2dc6b5a9a80d38a98b663bb34e31d294cf11e2ab4035a4ee7caab084dfa8a003b6229be7907f2c05d5ab90082ef9f32a53d8460e5ce4552a1a0fb04c91c7c8b155ee2c0cb7c9b95eb7c9653e918e9eb3e68ccf6d6748c8527687f75acc9f156ee55433892136d25d9b0f82bcf6aae4465f45d6955cce1aea5c2c93dd4eeb48c3d08401f934c3b543f5ff0d8a9f2cab1cc18d4d05a4fe5a3cf0846ceb2942668c2cd0c0faf1c8f3aa984d7a589ecce39f280183bdb9c6b9e1bf47a2b3450188a80a185585f5299915de393741f451f0af80f040f0a754085497b0a8cebe8378c798704982734a2f6b01568e9774619a646a1134678e952e7d32f8167d1ba858d8a7e51b56dffc7fc5bf61e9761e7510143dd283164958296063f25e0040bcfc5c7f3010e04a0c11188c055340dcd0942cd571fadbf59cd0cc462939d18ecc8cb91c18aa4f0d1c03e6c25e3c3773e3d57463c8f38183d1e3f4e51d41b2d800f072d2e7e8afbe48cac4fc938941f7006cf7cfea816d6eff1480b003eb6068cdf664a2687a6f14538ab9037b797cc0091e34b0dfe19257d0d697efc114cfee673244f9428221358b53ac08e5a9edd2757a831c4c5e56f579a3793280ef70a17e79be3ff0c10ce748f2a58314bcf5e62e21b5b4b771b221110403e42b219f8c0c8cc632fb6e443483e7bf79bb1b49585b7f63059c3814be671994091b27c932795d34dd13a215744744b01a3c7af55408a48dac89c340614f34056d22fbe2f796b88d97b264315a0f04d90ea4eca669fd083fb06acf9facf8d88ccb7432010c7d0c5ffe83f124ff2e4bd9ce9e4daa0b3593a231fc63b9b41bc6a4fe7b53e50156eda296afa8246ad7ff31cc467678442596398dbafc5ba932ba20b6892f0db7f7b109f3259f3aac033a2d843d3ce57131c9aeeacff17fff0da85958429e3e46c18757c86a52b0e00e00f71cf8426670fb137c6eaf851afd24d15d336532ef211f5c9206a43ed2bb6978386dcf46e2ae1681d8bb1c1751abb40ac0b1efdbd0a61736901fb1b820c572ee4a9ad1870bede98b80e40f67ef62249fcc7ded61209dfe571ea258e9ec144becfab1216e8b8b533d8393a26506a59d210a1137486bc9f5fd0d283e1137067df25a777584f56acc5123fcc55569cacb96fe6363e1651379e555215abf90fb18b22d877a1eb0e2fa66baf9bdc8dc709fdb187437b0298a9d84f70b8f48886a752bc21f81ee8cfb3d9b781ad847cebf1e1775cdc3f6cf0369080c75968119f2d7886a6b904d041666f501ee262101788f5f3f891db864a9770d21d7a48010244914e1947c9fc208752d724e658b76e6a43b404f7230fe39e37f9ea46eedda10111df246231471f13e436fd9058c5f8422915b725c0827c12f7fecdcc43cb11117351008375fb7ab360e03204105db1b66c36ff2f347f2a8b8d9d8849d9e15806ccb8136700870c4e40850587f989e58012d5230b11b328e222ae0d650516dc54d26b82a0361eedf045db6111c8097afde0c3273c3cee74ededb7a214646debf383368f4fb348f0d19be476f26ee3345690dc8ee79ec2326b73d3a5ac8f8d02e7752cee863312a3060fbb2252785d21407cb26572982246bfbaa1bb681dc5ec5a9ce1995406021c6a5d67c7b27a45a6c96b7ca91efc81a934880dd524d1a1dabcb726d4e760a83f8cf2c0d2b150d2c2a8262ccc74b82223ef978459bb9f3d54226fdb025ea86e243e348107303f1390d8a34f5420066321bc8b678453c61dbbbc40583027e82cd9475144bef0ac38caf4edd6a47965bf8887e686a5ed95d4ddaa249b84296992deccd4b76b6de6efcf156976c32e1e1b2a3f1e53b7b58e2e5f4e5ca50e4dcd31b3eab73e9b8fa29f40e98521ac0627c21603631bde4675e6bd794e46defc8bc34df0b1b5e19ba3ee44bde2187dec47466cf9e8bbdb4ad34dbdb12edc9a75f2f8400223e8426525976f4ccad5b32c59d8eb4356f6db63b59d1577fb89ccd09d5b319418128125c44bceafee85876dabf93345ecf706639efe53f40c83ce7b70f1f00d539654ee8b6544bac8ca83517ffb90de5091e158737858666df3034c6be1570c20c63dfa3488bf44476495b94f51e2660478124fd78bec52b085b1920544eaedbb2253e090ad56b0237fdaa52bd5390fc148d60179a6c28f1e696fa860539c15dd84d198d5db046187dbbacc0645c29ee627b2315223f4d83e4b41df9b87a0a105a4ffd47401b576b61014df75b75e0671049a188d8ad19a329a88ae9ab7b3da5edf043528518770b742a460589286a3eb28eeb1bdf538eae009e22145abc47e450c6f8bb8a592806997623d57803e736fb6548ed47bc511168eb4a80371a2ec2a47eefdb0a9c00a2404465b5b94a3100f3318ad3490f896dc32e54d90df027efb5dfa823c79bd2f6b3b1a8052bfc1bfbbefd3f7a34cecf6286cef83f2742027c49d7d6d148f3b45958632ac97c28655b2960b9fa1d9e576236af424bee301fa9f880c0d585f010d6f8dc728ec2897a8822625c3be509b88b6e7465899a79950e22fab9b0b5e0e756e671010f6710c9371cb8c6e2c6334ecdc4b71243dc928e43f1e93c12025e03c2299db358861d6b8ea81a86ba14ee286a26e6d51f7fd1979d3e63ff0f9363d22623365da82bcabcbae6112be2d85f1dbcbbfd66f40e4cb7f805a43f221b2ba0b81807116eabd99add44792aa5f1d6f748fccfa0624189064392e137044269fe9b36c7de8eee3517595b8dbc40698208219e9d06b6bfe67633a396f3f20b95938f095aa8516273598413847a1a345218259fd74b101e7f3c6bcbe00c219c223032c642104cdb64020358872f9298be4bdf813bdd9d6d56c167a7feb391033dfaeffa50177b35256807fcf4290378545856f41b2203562f0156c9f04a2dbd66d5910ab4bae59ec8b4d6ca8ed8d1f8db22b7e74ba39b61fea48d700ea6764272df31b63cf25d0b44967321d5cf52fdc3f4fb3d77f9c4ea7a7b22975cbeb47406227771e7f013422b79e4ea2fa700aecf3dec68fd8425eff91a101206eb902e6714795118c9e9cb3a89d080dc6cd0c2b29009b0a49a58812a68aa60b7cb9c785a5d446a01fa6ce03b2a8d08ec550bc6266cf720e2ee4f8ddd5baec8eff55ede525764249ee3c9ee65b8e63d81fafa3b0ead15dc028210f5103543b45c73f16ca4c41bfdc1879f32a27c719735b3bc58f346f6c0cc4097cb32ccb7d9bb897a38822070a027d934fc615d46a161e3c6633797e0ae16d0eb91fbc5015126a8db337a0644c1182fcf733025900e4d79a7a006c38792d92cf266103d9b3aaa4d118a9b9256fd9b5e268c345c59cb0616d4c3235ed169b1f8ca38ae40223fc343a0d836bfa76dfc86bcdcdeec349494e6bd3c990223f89098b3cb3b15922f6bb7674d2706cc3e7c98a1946935d5ced00c669b87453c16d4d3adb43d49d3c3d548de89fc5595601a93094c6ef26f377f34c848ee303143542f52c11d8f578ce04df191fae7c2e035cd33406fb4ed9f07a9cbbeb710869e79abb91a88a52d459870225b603373cf3c23b95d6d9d5dea700d4844d608ae4d6750d89e7f2d9c0676bf1182be6999f5b2717d236b0cb79feb2e2f0159339a9c38c8d876353173960b9fd15b0010341f6fcc2b6cd043af3b5381a576d15e9303926c6acb88a0658c31906f9fafb779f2a4155819bf3c4e28a5a8ad88fe4237c0352f9ed482c6dbeade550e68ec9162986ce98067b5dd23b6cc4335bda7bb172349349ae5e0454d2367e18983df13d8ba994e1176e33e0fcb10996e3550214d8f8c5773c6ec11e518aac694c636acaa9f170db75b799c761ff98ca9be349ba49c9e2ba5a81c42f59b5d862805c5d81c48400fcd2baa614bcf8e0cddac4d4208554a85cbf1ebc85814c9460bd98e2034d4d0a5568323c83888dea9d9caee355ffa88f8f346f06481f8e1c906cf31b8f7f52cc736443ec2845de95502d949ffe257b02488ed4d70b4b9a338d7c0cca8c1f9950e724e25492da27aded6dc8118e8db11bc1c29d3125aed5cb1b5bb8c3f84d8f746926422a9ea27d7432ff574e1784591d8f54c0270bf8f87143ada2c8fccaa36b4578a0b369ab222a881da744cbd951ffc7abba8c88b47a6dcd8aba329f8ba994d18519a39e20e97a12c6afccd2aea7809884cca2568b4a28dd331b98a5fa6f8cfaae965a32c3f707f7c4ca6765b3229d896f1b1e47af0cd6e905e175600c2decedc66ed5cf7367fe5a17748b930b06319a1d4d65950befda5192e4f57f2a1e4dfa3844067052320cbc0ceb608b7006862e29edf6dec9d72ab9d3effae82c3b83affb70c0c7b4c922cbe1ed4bf43aeb418243a04bfcc19f5e0ed064ee35a35d7856639abb0b7621081a4af2d5bc931fcf2b63cb2e5619d56be2ab7821e6118a1ee4f68bf7cfd845e31906640a63a5ef10c208ef5cf722f7feb0c9d5c899ab066d6de44c2cd58da627a6c6851fd44614e71f0089e412670a16a2d7c6fa4f2fc55accfb482b3ddf2e882587072af7e22a160494fa1a26c289c29090a6cbcdea8f5fb6a373a24cf661465a01e6cca1dad71d0ad7e33c4066627755b96f031b21731bd3663ee975169faa6463abee6eb1fbd0e3e14e939c14418b5ae01861943b945c99448cb9b077b723cd743578236c3e8ba3fad78e1bf31f562df63129424913fd825911621b82e60e0ae9372c43e2b41037ae85e357012139bf55381193b330df26fed18d04016bccc6a8d85398324f75db58a8f3d4395733233bf5e754e85ea3661ccfceace9b4db012c58e79d3f781ba8b3b4622c2a1421b44b6875a085b815e5b7e69c0be1abf4792258ea5f8c1177fe15606a1ad23e8117f8ab7912b9ea9bd47f53567bc01be7d23bc9b089af78117c8757ba73ec331d3cdc6ff915198273ed3709b4f1bc9bd09dff0990a8ea8c1552e79b6fab52c2d85f1d4b58dbe4ddedaff454846820ca79ecbf2a77360f8b6be8e5963e8ddae2b7809916ff2c7f722cb0fa9e0d643f43852a3b4a4ca9dca39b845f344b56bdff927c5fdde884e80dbbcc77db00057f64f5769cfd18942fb5240c18377259c39951759ddcaeae24f5999f1704107adc3791944ae3a3ebd63199a78e48ea256896fe801ed71817fa046e2a04ca2b32c8bf30874602431bb810a0322811971ceeffb46df5eb590689da16c67375b7171c4ce0d396344be0381f888aec812de373c71f11ac257251406d02cff53bf07036862f6f6a59d55d3a6adaa9d70a72a322bef758f9a3b3bbd76482d6f714c71a1bb2bedd0abefd6748c6d5bbaa106cc556e60d274c83dd06d4bcf76465f58dfafec087fff4dd93a93437c88499cafd9593d41ccb2a136fc6af9158e77392757c729a3e779c03a998814bfca9ca1244613b38d2c2022fa3a54de14ef7110c3d7b2cb0e343b6957c5a3e413b5a15bd7a92eca0e7c7ecf6d19d2bae7c09d6618e6bb9d6a4246a414f7b8a40c1ef021c3afa571c0bcc78f8df521149aab5adf17b01d58b1c2147e793efbdf91a04866cd56daf5ce0e28fa59b68ab381bbcea2e03c072e78cffdfa0b903f85880f36583807b0bf973ac23ed25f7aa16d24b893de09b0a7f5a7e29901b6e46deeebe53fb9e1cfdb7c6ccb84cdecf31c844851e614a972439d7d0d02218217bb94c67421aeca97776d12450da67ea3c2f200d24bfbe2607da53830a55e598e7b8bda4a2893b381c932110883a36b71e1bcbaa0823229397e9a54cc52cc8beb1e66a32a72ba1e5e46d7727f0eafe9393ffa9a32ce33baf8afb0c791dcdbd252f5e9d81aa9e2efce892edc446ddbba2db8da248909c69d7d41b6908b747346c72b2591904e329194e265fd76c211560fcf8f76d350be9ae05c5708311af8ed92416c68b98817b4a2a498d89fcc05125847b58ee79b5e91f9eea1efecb19bc9bcf3715beb7f2239dd07c078d28d94624d3e9397ad851f7b9a11440779fd4891ac851015005957e79a3155af316821dfcac9018a6f53ba2226a1359b41632bfcc623550aa93283175862f70259d379a703f81ffe4dfd422fe08ae632d89118f357ab4c60b83f3b6c48191d1c6037880539951600b42928a2ee33eacf048f02477e5e991d327bd2b1d8fbf62db004c57b41a13fb2e4816e87287c9c94dc6b70ad3ec25ce16c0d32024cc90f98e9a9ad3d743ae1bcb8c0ca24d05d2fe56ede87f070d51ef66452511a9aff05362f005ca699a44680279251768d47db096f10f7983138473e8fdcb85ac118b7949bc3e4ccaa417efa13c39a30861d677b16fa7a3d1ffb29eaa42b631b557af60cf488e0f64eeabe2723dc7b98793423cac13595a5c06cf2009e2225ac0891e5e2dcfa0e1b2ccd61ec05b3b46487a42884e937a088216a86d1ef29a666b6206b6738e6b165e01285f79ff3bcd703de955ad7619f3e1d07955fe0967018754c69d9884b7bbd22dd4132aa0a45e47a425f747a2d48954e15fadcbc35788c821ea469642339a309fc7977e11995c74632ef2a1a782c33cf37064f48d6aa7a3431ac0027579a2a33edafe5aa0b292bc1694bdac48043ca7298761f05967d6ce18b96af820a726bf5b84be62d06f32aa4a91294d80cf3b995b5968848abd4c49948d76a59e1241d9d071f57971c7bf5336a00f7c2bfb692b99b99c4ed37074c49656026751a7ab75e5f313e4dcef22539059203edf646ab967311e2e8c30f29b632f9460593fbc1c5a6cf6627fe3b2361fe3a02ff923e46275aed632eb0afb375b8c56448ac20ff8a3350644cdbcc3b00ca483fbca908dd4135b88888bb7e4bfe9ae598bf9eed665c2b42227e3cbb50552d879861d19714f80663e1f2451f1b04849db0979e0da52bfbd79249952cc8abe8f7e461e7271e71ab5c2ab617b4e8935eb4adc0db927260291b4985fce31e8599ba5616339f5f89a41c0250eef4cc1618cd59b091b41ce62b8351ecd402ccec430242815a3c61dd90eff35ab14bf2aef985ec1ac4027640c4e5d412c7be40feed4dabd4dabaf766ea789e76191f599effa10925334f00fed9ac26a0710d52ac6e1eecdf5417e35749a561b8d1f904b7ba602e94555c3011c5dd6038b4255a6ed3f806e26b7e8582dd1a5532e85b3e0e18fd99559e1adf99d57b26754d3ac02cba9fc47c907d78f3d17ba623545333d92d6e5ff98998cbf47929b6541bd2603a1259b059d883c5c4a8c6c3ba55cc711d8d2af896c70e5e383a375384b90c49be4866ffe1bd7382bfcc3f1eda7b88a3c335d9c5ae14f05ad4d04e442b2d725f75a17901feda86d6eb5f952fc35437a0ecfa62849465d01b72e1cf72c554caac65ef3a854dc8ea60eac65bcb02e06d273e43e657b749f69c8a6541a766c50fcb5e6a310377c5a11ea924d399dc30da6dd0fb6019f4ab652493e3b8c50ea6a2d7fc8e60afa8353d4b7a3ce226f3256363a82aa173a861bfd09f25cacbc797ed163d2817968d698832b820ab1abc02fa2f8489eb11720c7e132ae56943db181d2c4a4719c96d047a063b146bcf560f2149bebe09b232e8cefdc8b173dcde4628d07987f468551ba9bc88adc063b855cc49e72aa9feb497357c80158becf653515920ab69e707520e18f69969239fdce5198d05be0d83aa294fc2cdedb07170e2e8f14254abc39fde5b0b868c877aa1b1b30fba9cbda0235c7293aa1ea989b4c3a8feae19b193099ce92c723a6c666fbbd15439288284eda5005c44e9a79784340f118e0112d72b930a4d0c7c0f0f0953fa2dede538edf6de6067110468d77ba4d3c68555653f31736424d7befdbdcbe4e95f13526fccefeb34af03bf1186e32f79e2b85c5b0f127e23e044516becd838313d70b559a3ae856fd951083952b0bedb578805b3710ab4360c12fb2824ee80ea5fcce6960a2ad1467dc1f88f5179b8f2c694e7633190146625cb986c58434abf8acfe68bc09e355b112a675394363dd21268c2e5938b0f29f195d55988799469d7851eba2a687ea0215e32b0917571abab724907f69d116c9714400cfaa9d14287c6b63643637be5528e62577a91004dac9196153f8bc152107f1a0aa15d56d35f062565d756438c1eeb171fab5ff1792ba1c4ccad3b8b3c1802155c36553e649ef231d9da5fef35294a50d23c568cef8f03b3316d10c27d38fcd0ff3920991b0e9bd5ec2b250e1db86320bfbe18ea4b4fecbb0858b506564940673d2e725013e52b7feef3e7caae155fe4cbe92de007d79750321badb3358151fa03547c09f1a8e46d4a15faf2225462fc3fcbd81765edc51883155fbb489896ac356a1820d4b1091c189694d108db2d9886840a034685cd2b7640a77719e16a0d836042c56e7763d09f431487b304e7e638e025882e70bf08cfaf1d551556b1083cd6feaf4ee735d3d979ef1ef45d19b384f9a179394a98eccf270b008c4718816259d5afeb1d846b47b690c0fe1bd9ebf5ccc07ca82499e535397025f88e39afb253ed47689fc1663a2991d3c2b85da71bfdb4ffb34dc5e32ae3871fbfa414a7c1dcb0c74f7316b833c40ea1ed257f66143c3776eb17bb980c49002c357b62f9e9fd149b891400a14be01c88f55313c0c4f13e1bee85e0daabca7e14252dd824d5c884fde545946e145c877eee3a83f464e801b01f62ddcac3b1c8f78b24f31f4a51547177646345c65d5e9615814ee3c13d029337faf649588b43e1772020896857c2cd9710ea0a28fb65c7f537f3e48dbe3f8fbbe6e7633786888717c2c0921ab5f4821b4638158facd226af6a3f3b0648daefc15fb2eb957bc405cbe2adc228022d17f653345e936c7bb0e2eb1965c70a7e1727fa9c05e583982b7f77c539d97a51e5b83c7679f7ae8de09839d9908b0b33c2c7dc3b670776ae826363fc88d0e3c0627ec27e42a27a03836654df52acf9932b8c5a51d75b643973fee2da47ae49e3163c55d1afd47bf7a3e1026ab454043dfb606250297b470eafc4f7e7a4c9e9dae7ee4ce0eb1a0ceffc4012e1fff89cc4706a86fb67402bbfe4296c33981a5fd8e3958c03d19f4781621613e44fa243d52d659b63f8d48aebf7eb90f55f62a3b0c360345bd9d6839524c7129749009692e9bc9ba488c5179b7dba37f3fec61c9574f066302a58f6564cf95bb16c10962d2868f91f4e44fd3e14ed1db0db799c3c23630bc336573fab570cc2593aa59b3f24a106aa3f43af0deaba99eea139e4c22046ecbc52926341f0be4f6ab36764a6fd88cc6ab1c839a38d9f2bb7c758df63ff890e8f1653352ca6907650289967b74a10327705ab6a1edbbf5464d3b03131febcdc4d261c2c7b356d7c04537a75e64a974435b0733c0e891c1db09b3e12aa06f012a1728c3146e99e1f4cb3f894abb27e3321f379ebecd60f35f2aaf7b598e4201868f1ced21cf1375c43ca5cc977c372e720a826f1d7c05aec327fdc4c399efd305d1bf5c73113747ad1ba04831b6f95b5b17039632ed7ea0b31baf47416b143bdae7ffd1bcf5b22c92ef14b878f6c6d08d89c79d6d2ada258bde73826305f2792ac8a635bf1de328e59896927adeebf109bb6498342989cd8d05c63f573b58021a0e08e5751b0d48cf15e3f08b473077a959e4d9e7fe09ec94dde5731d9a74eb354dbb8fc860ae8335343472a994e9ecb552d710cb9797a69cb2e9ba07821294699d486c0df5125e4268c0c11064d2fc8925901f41d920aab5ed9b1c3dee24e0564e152b54891b454f32c088922dc9bfb49f51d222adc3f1be699b4a015814ba975daaa3344f84c52328766a117b6f1a017274e77ae41f93059fc86332eae2559ef89fc9cddfc31fa824b2a0ab19420664b4b6b8c78aa016fdd03cf90d7ace85b2ad66b6421f63bcfcb18e6a21e43a7392b542bff909937c13a55dbded9bdcc5b28aacca78cf63e7eb98afcfa7ab2dc004fdeed689d75ced5beff6fc0a6fa01b0982a3ebd65fecce247f84247ebe3c92e08f0fd04649a03478a44cae0404778bc5c46893d2de26f6a24092b41dba02591f12375274b06a0e1ce203f3eed2592c7c24ebac0bbb41c2ef43fb65085cddceafa60b5df94da8c5b272206cd1199fe52fbe06a14a45fb74509b92a9a422c4d3594938c49c1c9d52dcbb5c3f47d068b8695ad70797e67a32a7059a3430591149f1481f9178dfe7cfddcf45f708358ef4380faca105f82d6890bd23e767e8e4c2a24d4162342dab322b8c0f1f47c11ae56a1236999f73f6de0b448c342ab996e913c27396e968ad1d9205ee717f258564fc1bb2e11f7949b5c9afc26f3442a1f88183b37fc2bf1d271c1abf6ee873d17c751cdfecb727358801b9d31fa8c7712ef92374bb7b8cf693f9ab1ccad59c5aa703f11b4f047b3a079f1d1c339e36302fc4096d3c76b549e9f75f78b8a7c94cc43cb15dc6c566cbc141ec03d8d10a6a64bd0acb063ae3a1b9f205a27ae9b30ce5435d3c9009258c942f7cfc080fe22b3ee00cc79abbe44a967c29ceead4600f1065f89b4fef4494304a65b59b516ac6e92af5e479c54ab04b62e6456132ef2eaec0c4a86a16d455df814a6f11141ed703ea36706d53122191da523963c18a140ba18a0ef256f3669d45f42dc0691ac04e6d2227c17c56617fd46c5703dc436a96e682cc55dcd3ae7f1f7c2165c4228981876e448267a8f2a7168004c3953304392518d1b7680d2fac18cf8155995d3849dc2138d8302463570ec9c7fc7e3109d94443b3a5c07b100faeb42a0ef7fb349658af4b2de9a57719a9fd3df4c0782cbd050fc6cd128b3718c9f4125be9472d083d3624f0fd32651860cc5286d0990b3c8cabacb7d96ce54a88ab9bca0834a5f35714c1aca7ad6086ccdb4fce953fa7d608e7ec42ffd437be7b404a2332e8b1c832d7151a943cb8f303e53","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

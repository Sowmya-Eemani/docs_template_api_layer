<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f5f9b9c49380e4568d022ede35a99c42ca5855ee408ae5f818c8085e36a356b491b9d7171d40915702eeee73b0c5dc7d0fbec8a7e8feb2f93f48717ef70bea61048c9732362c19fed02a3d0a65e7497d21e3415ce8c5cefc994881e1fa1f26a8f0f203855af65494217b2a7b84e36947ec26342cdb714442b0f1241ec2e56145d37cdbfe02ef160105b77093fd4c33b9327cc1f66425b7b78a8fccc3fbf1c95db66b77a1f5e44d896dee95e9921a690168e70340ecd15d04844a0fa41a84a5bb8949da688c9dda3e64b13c422a459a400eb2457edb562051b1be70505c3e0887f3ddfa77189ff3cda49ce3927e0fff6970ebf3f30e16c354ca95d6029136f9c05da1b10c8b4d53ecc845b643d9de94a52a6c194dc4db081783d9931429713cd299f5dfdfb4d42e2c13c2e0801e8dd64015c1d54fa594c1647390c7be12ab0636bbdf302e118cd74db67016779ca156cb7b510517f184faf90fbf5b97fc89f3f837b7a9994c574760e8585e331db1c4422ccb49305df8f53867ca74e183d566f59db51d15f3cec83a995a99fac7a7c87dd59b55a16b06a0e614089cb99c0bf21ba0a3aae7c932fadbc8a9a2f7c1f7ba10ef3c16e9b2aa7521347ee277949e1ec52ce23c3edc5c78d0ff4f296d72fc1eeca9db01fa9063fa167d65ab8e28e484aa14b645d927ab57160a1843c6e9b3f946afcc838db39092769cf0ce319036524a7a177c0bbdff0f4d49e14c8a731eb6d763883d3a1b763b5957f41f85e65bbca6e9602faa66c727f0e489466d6e0f2bf886598dbcaf2df88c68ec13c12121ffa00d8ea36a0c6c04b4bbcd18c2354ff4f5ca45cee84206f9987cfcbaa21fbe69c199067785a4429a0e9b4c7dd64907dc7cf8349028248e75b1516d3cc1420eacfb0a503701db472d72187f9dc093fc0ce8212ba1607f6f8d1714d723c20b8bf6d0830db3f15a23241f8ec3f5d128a0c96207266db7df8f2739709583c28cf55b1f8ca52fabf8db34dd6e079d4c16fc88fb1bcec062ac097a1972c4d56e9d5d1446e6b53894aecf0ba9670bd053ef18c97c5be348585198e4970dd88bf52f81d62e1c166f33debf72584ec10ae60f6a1969c01acdafad3c2ba0b616ee626e555669a0affe32799082883ee0d16be2f77a9ea1def53e70e8c21354926cc289d8ed17b1dd4bf9b85b1bbf3ec23e556d5bb679ee6d6e1220833797040fab5613e344ba5f8898dce42dc0981f568623337d8e52cbba976811816af3ab465cfc31bb7285b9216e6df68a90976ae06f1aea8e17a248edd64433c6454e5893e19a853137141423ed0b788af051533ffb89901216e32b42f164afacd1ec630cc52351db5a3d311f8071d174f812453c4daee66085139d0d2d87ac58a1a62d3b7ee6a33fbc226d3c05798199aa0657e5b188ea355add70617088fdd73dbf0c410506f732729e1b46abc3272a97da58c51d0353c63e764a7e96fe3bdb9b8274673d009bb722e747743ef87cea802a804d3e7eceabd8262802a24ccbfbd94909ffeb0cdd468886006dbd9cb04fdd172e89b78b21796ddc0fe6066ab3103b4ae5976a7c2ecab06f6f616e6e42b761f16fd645776bc70003fb3da5435cae14f475653d0dd8735356ff2899310999802dcd447b9a5847cc7f9b1df1967c0d02ef97f9d83f14c4db61902ed11ac5f9dc615dd477c200ab73b57e819b43e791077b76b0128a666a9c164935602bbdf3a73858b5c7cb3213b97e46abf17d555ac94804b16e36a3b5d9b0637066c58911f3f40dfa01314c5055c3d0ba5f569ba60ecdbd629e282f914c928419e08931291aa2b1976e7373763a7ffe5f45b4f8c079c462c8002abdd342bfe5a0e315a36fcf7869a744dfd28e47da00c1fddf10909c2ef457f541fc28c0fe9f5f87392aaf23ece5a4ec755baab48c9f46ab49a0826e48ca58432c3d129a17da31001568ae1bf5fdb63cc624c1a0c7636b85e4687662eab63a8d1fbf99e00cd18dc92fdbe16a2c0d2db417e474fc7d366f8f901ac642a2d65b9d576e83dd0693aca7e23d3049b4300e61202aa325242aa592fe8ff228fe7f2d0ac16ef9f522ee7da5349e78200f8226c047a4701cf6fc4e88200c97a7c91a16c7c5c9d83d010810c1b5f15a364fc85d1ccd59f3832847cffe67bff1e8349791c6d585fe6050725588fd89754c5176f51df5b7078958b18cb37bbd3e40436fc33a32f2a599b92f87deef69c5f0afa09bf261bfde9cc42370cfd993a23efba1c990313793fb1fad2157a4e303d221a1803fc1ed8dec6b62f50345134f93a984d1425fffa6a4603503dead4fd09b3e18a22970db927e0b1b7ecb3ca2c7a66880112ff34b797e35b5d924f169a8ce599e874ae289ab5d0e6ad7b3bb6c62d14e18fee8d26b7c450dec475ca66ee95667c0521ed8bca27119896c0f8670f7b1dd82e13e4441673db3809602c79d4b44e6e02f3120395a2b96391dd5acd9f56308c2d70ef36434e6f8e612859c75b45eb62a94fab1488902994217e9e1f1127d42714372153b7dc0e857ffcfd1fb5a178cde774616796eb3aebffa93faf4015a9532dd04917692f00a60b4a921f2bce62eed3339a74b7eae5e5ee12ce51d721bf32af8d4f3a4ac1dadaa4fbfece7a0dad7a7385fc8cbf2ac43ff7975170a47b05ab7d0655de5e2217f00018f7cdb8e18d938d5b821591157b036e5d0ddbeb275b94ccb31da0fb66ad329db6a6e4b402bf976ea3dfdceb49f83ee40760e7127e4f74be41c87adb641834f3cab976c6c1415c2912b8b7d267f557455569179f5e07353b06efda3d207c940e8d6377c57f07c488891590720c145a582172de8c0f834791d9555e4a994f1c43a223da78a68d345edca9acbab7e8cef726d99f735137bb84923f9887242ead52fbf325e10279a343e2fe81b23c4fddae81524ea03b694df9562dcfa3d7e3b582813788c0ed534d19dc6d9d64da712393ba209ec1e5b4f346dc171d02af1e5f23e8b9713d66bbb2867db1560d49bc373f8bd7490ac8c1395750409b9218cdd634c7d2c16a91fcc8cfd81a7da8b8e3fa1ce9cf7c502421a1369cf6cf66f61a649402055f13d6dd3f9cd289006e9c868a0ac787c82d0c1234968fd9f18b4617246a86826d38ad1cea78f5039aa0ce37646d9d777dba5af51ddd7a59afe093875cdc21e67fb5589c18a08b0bda4bc28b731ee47fee5fc4b78eeadf31f5bb850deb6334bebe18f5297c3186f7d7a21a645b215dfa9c9f6790eb4cbc996308211e157f866031e0992d0604d4970a83bb1ed5f15c8b547b1892f7bc8271109bd38604c91fd73c357b684b3097f18c453ea916c1a0e20a8b7884b8ffcb7364e254588c51c4a296a01918b41ac8f8dd8a0263f12af65a3a23104d308ebae776e3471d82e5393ef083d352eccbc3a2bb31f217534175fad1ff5fc88f5617a48a9800d6122e513418597a4750e60421f1acce5292fd4283172ab581924a1bb3ba24850e39af3ecda81856ec125e8bd42c63b2242a676105687d4101cb007e1f7c875c2d1e586f447d82fbdb463a71a653dd18768e7af564de0b895f380fb36e5f9186459d954dae6f7562c5b63efe8584a74e00c1e51fec2f108d6c2ea7c6ce95694b3aec9f5e8cd5ff41a6d04282b3069b0756d525424d18cd09950a50acd3109964723fef698420a3ad02aeda2e3b4dc1d09a8705046b2d853bb89517dd0f311d3615a1f583e50d0a5e2c94cc55a2d0bf41beee15cadcad91b1fff36d7c79bf1bd18345c56b95f07aec853e1378ae56f924b171e680ebbc1198424215ea2331b9cd7f1d2f19d7dd20096733344d5c9e7af3624defc26c655c66c0ece81f9bcb920392fc97c28a14017a143d5ad591c2f83307743c520c249cdb720ffddd127bd49671def18f1adbbb99239ef4a80c2fc0128bc9f06c1320988929780c7c801ef7d529b2f0703a6969491fd801143de86f15033e2d3ff56b6348c17716f0d769751fb4e758cc682cc992d7f9af3d575694f85de038be8c38b0a97f2832a2c5d63b9bf05d1c886896a76901b3eb78412f380e059ffb0293ef287704592dc26aba0879a5419f4d1343de8057129dd98e21e7d8c1ae37ace3499d6ea6d5556c843f593d63f3e08d990081ff30052c492d373b79cfe279fa125dc2de6a67b2f2e76ea77e3d2b6056d375cfd96d0ae622d20218ccfe819e5d88378989b147347a0621bfe0b7de3c52234c8418216a4839a08b8293992da7a4574154c059c716e3a7b4dc9205b29297e5f058f273df4601007ab9ef5a3f9ba198141853926ecb5ee378899cd0bb5873377ee988870a1928f98b8d004f80aae66ea3827c5cacfd28af3cbe69b38e8138236c14b4ecba8eba59e93120e8682965d01321db6208d853fcce923d9f6dc638604233ddf270cc02aa4d6361d2bcd84269e8053d32f23ee46f84808aa858f3da2655e88ae19679d70164a899653385537231b73c2a843013a003b94fc0bf35427c6349c3140a771a2b0b147c74bf6166bc564c808034990477199e1cfaa0e298d561a4ed59adb5e2d7b615f14431a37d250dc5e7bdfd46c2262ffa41bb3f89565f73aa2b93d3dc488eb74b5433abc43e418583a2770ce84e1047c46a93a682de9234207b993d6b0b96b8ed908c725c078e9bd4ca70ace032843bc11e8169e59fdfb6f2c9456721666da5ff4423b98e2b7a763417cdc387cd403ef0782c284de74fd1f89f298a316c6806ee89219634dea3eef8dcf1b21253801532f7d1d8c30a877c9c913e84295cb1729477e7519304eb096528a242037c79dae99c62677e8ed521b9194a89fe0c495da40a1ab056a61c625a9a11f4fdcf0a9b3046efcce4ee7a50c6accad9fcdb620786b1099c44ec39297e1d4ba30abbd82c51d53771711d84dc3c299d18e2cb0a5d2d5e9f108b3b75144ebaf0de198aad64ad086cf308dc29c8fd5cb3e6abefe3ee1ba8b6a6e779eae45db93371189e5388cd3bf1a27c3e95adad8268c5b23353069f268fb7aa003484ca0992991392b0712f81f3dbb4627d49caaf833218bb418e1b13e9c9f28f8face6d2c1a4625c00e20fdf2039b777d03de0a44050270de07dfe3d04cbd6f7fc9508c07a68934a10e69e59fad51c010c56f868c11c2d02a743573d8368e26124e7894b150b26b5a9b596fd14d1461a2aeb222edbd0603b1052c9a264e65f61ac118608837f2c71351d7162792ce0a7c2090583f3993e22844eaa9e76af3f47487f0d4beb4d5d6a05450db657c5a156f0d329821484cd367b9bbfe0735ed0545dbf399d7afd0ab56b3c5a8919a614fc15239b93608045ed1f51246000618e9c25e3fb33d6b0493f4ca284a60933108777f936654d89401c214be12157f6f89439bf143692d0131d0072665e591437e98e25535df9f29460b88950ce100d264d69a12b32471b412de4fee6b5c076da15a569a3a35914e0f834bb8fb633f4cfe434c7ec6f875b4de48435b5e7f0a9f4136500411724b5043f1165726d35c32decc36ccdf23bea1b823d18f59db89c0cb67838ea20ce05d3010734382827d9aa79d2a45f8c6072a4071662840db25649b0f59618aa5fc572908d96ce304c5f1852567fd8f3f0ceb4a385089e838e05f7045023a264d49faade3257fc42e17ca9ee7671450582f09be9717363f4f34215311608f9cfd2c0b21d25f4517a7dc8319eea833528b62a4ce710766b66fa46ed892dcb29768e6cdf8b208d3ecec4ba383446991f403fd3a9528a83774b4cdf4335b2a5b4ef9fa27587e40c45c7feea85af52508bf28c3878141a7c7579a0f80c2217692843842e60b56e295ee2029480f896e67771b2a4b5ab956b4cb8139c3cf9060a6f74ad3c580af30b4b8ee6c692d07c4cc8a25b1f386c3437db1ac69e0325a8904827ed0ec380a40a8bfcbf9b8de3492049872c12a58a82513651e1d9618a044db28d4fb31371a8319f50e2a8fc7ce5ae3a45ea79193fe7f92a13d571b85befa4824b6cbea3a2c8369fcde9cfd25956e1a9780e0c1571a9b1cf03568202bc2f8753cb38c4e8db15f78905f5e4b1d839f24112fd54fc6ce1472e6792b2419bd211bf052c3e28fd507c900ab5e521a75c53ad58fb1e304937c077042ea8c05626294c63b0623166e3492226caabc76f9708fef273b98e919432d1d44d537c2188014fcdf321034dfa86730498beb3d4d5dd10d156e2d72345c8bb56f10e04cfea1c4be51f605249466e7a5f47463ba8082ed01d3ac8c32e5949cfef5a22ab92712f6a0761f9f51da2d3077af80ee985a36728c10468dd9528a3501adfe7817cca15db2dfa4aa0d6335e9a73fda3b6c4862dbe9c949197c2b1df6e288658dac8d8c762c384c29401a169381b20608c3770cea6ac2755941b5c8635ca1148bc366a5a91a46f80567bfdfc647ddbb37e2cfe710e3e7eed7e08a4708a30697823df3a3bc62458faff6b7ff3a7cc427f53b4f6c94c49504eee68757714a8514a24d901e383e8237ea1be826868fc4139c997c147698dd5330c26978ca54f6e737f5e4cbd31fdfc63e3875844df11080aedce35398bfa3cec789a703f7aca3f7e7ba7653f518721b9fb8c761ebc3e869b4005f5d36e51a0da4f1f067f6cf67771db1b4f0e4587f528179901547060376e640e9a7d3c75e87655a7c7bd7e89045c076c287f95bd4f3b1d59e441c3465942363681420c200be9cbc68370a540e5b7b826b0710441286f7b0d13e7b6c478784347c1951450e3eccd0daca3b9a47fece906196fb667214d417ee64a7e99929148c211f88c7c95a1dbf803995f26c5128a2ff6487a674f9f947c9f80b4e5e1ead8a6ac0a2ad4ec65ae4fa4940644490671d81f4b2ad3056ce6fd88efe495e777f883017afb9facbb616feca0528b1c62ee1108d72d797e0d02f641012c42cb724e76817e6f06b3692a05413597a5d1f90bdab9c94d8185022513e4f4ecd59701254f4e2a989753ed62a95b3c8613e9c9f436e6c6736a17eb7c3f37e3e9a8b5ff5e4672e62dbef0664b22df64b9af8abb909c94aa44eae5299849117effbc59cc110dec1f8b20c3f6131a090f7b0ef16c5e78aa73ec6e0f199358b65176e36ae6efd171905ab3fa2a575f3ebaf3331d854d518d76a7d9b01445ce7b09f0e97c8cb9694025e991497c0813eb2dca1ca954c43031b28c4a0d7a5bb0accf1f88d85f3b2b6456d16623828165ba214bc03a9d83dac365a876ea1192e2830c7dc592a66db839add0f5683202364f874b66b543da25b7bd824eb714c0f49d90ee4e69f5bac262b3f760eebf19529eed02c7045b3f47ec8bf0d0641a16cb3c0f01bb8bbedb22a7f5463e29f5b35c32a17e31869562a40b9157ca1cd6dc28925e4f4034e6d78927f0da9239cf96bcf58db0ce9b662ad97aee13a81c120cbe9da9799e8416bc5ad031bf46a50666c5c232dbab5d70c5aec46ca1c299f463fc15aef7e716d8432874140e34429074c046a779e75dfa9104fa1ea0641698b02b42dc6505eb9bcecf80159f52d0a10cdb683cc0c99c4997e036a348ba04c6ecadf9e421ca07c9497c148a877f7c0aa1678e7bc65369dc3a99df8d2ed61d9b1476e3548376be284490ab6f7a7ac503dfc8ddecb9fd4b9b4cd39275866a2a64d960e51825b6970654c86e53fc5628f8c3f28be1f6256dc125d0eeb640a463604bc278839db24c5a51fe8bb37306d156c574b267d318625682557624cb76ad27e9858e2d82db18c95fe48bb9a0de4c58a91c2ed4b8aae9e64017730cf2007aa24b4600567fba15984b9a01481a3d350f38fb8c47f387d980516ebf1474a232d0e809e5f5209ec17464a505ffe5d448c5d9399243157fae2aeb21152d3a439968e03b3280da7a761c8b41a135bfd54ea54313f144c55976b76d10319cefabc8f9c87fdfa5c02852be39ba57107190a16ad84de1fb841d6125694a97707d58f3952fed826022197f7ca1bda18efb213f60ce124d9a4434066ada6fb170d676378d17fa886a78a696ca42c5284facf99318d52b64b6eefff58d3062bd24fdbe99434a181af9d8a84d5e8b466d852522c58007fef80cf447db9f67b9049e096cf91f70d7c326c3e4c8d03cb658d72bc7490e77dc6ebb23dcffc0b411abe09b99b481819824d0222e14472c16c35d52cfafb99aca4f88cae996628ffaf36db69999a01ae31842a40810be45fb2f61c124d451215589d5586af82959f41feac445ddb4800f2a94cd6ae8829cd02f21460bab32b1e971ea02df6406aa03c8c51861bf6ca66520ec4f2bdf14ef991afb060cc9a7077c5e4b4708d5f60253fc41ec69b3256c37c878f0e69d0d188ac4e753008dee9f0f46765ceb84a919bf4fcb40d2a0aaf56cf57f23ba9f91109b723ce81f93c552a4c0e5e2189eee421e127225fef61b9a607cf972dbc86a6a42a8c126aa9a0ba32b9ba938074a198c2504d701cef166c940d77a099756f60ef07b59f524130aa53d6434b16641bed4d3237cbd48a1db4815359bcb58ddc9aa28cdf46e307dd54baa13d93ac043a101088f3c6c4a51f325b68586b87ff0e48a597206012c9f96da02f1f281367babcda7b577fd0bd20c33d77d124c8ceb44f68cdc3e896faef920bcea94984398882fbd3268ed514303673e0448b3e6f52c4ed77d243399b6910ecafbb10eb4343c58a2ab2dc080de31aa450deef5b789bd57753f2880df92fea457cd072eb720263543ecee46e3ada8ddf1db704b3ba9c7030310d6b6278bb12f4177e2079aeabc8e6ea6d3bb16544ca9e9197c4ac643372c4da02c6828e8a0a65d1f00f760f8f44d92b2157f427aab0a751c309bb3e10e5b54f6d69e06c5440f0254fd69a35cd35e66240fbd549c7dcce737615627ff9eb3e0b987a7a97fba73126e557fa00936faab32e8ea26b70dfde44286970de3a5041a45fb19bea8e66980f3164df373008b2538c5e27068b289e86e0d500c7681b7b709fa4ba3b6095f8bd1729fa65613cc6556882abc55a8278017460db2fea0ddd4c646125cb1c5f6cb451b2e644e4558dc825b4b51e007d93bd946b48c2ec905aba85b7156ecfee8d2a566665d7c6c9e6bba11475a652c5276fe5c2b22f1296ed1848108b0fc4475ec31a085beeb245e695b13274c29b820a3f6d63c3b8ebaf7bdd2cd69fa712b180bfe65a5b7077d0ab5dab359ddfe8dd8e8732b68458e0bdafc18930a9eeefc27aa85d541f864ff5b9b708649cef7c51148f9c67d087ecaeb25107453073c0445d3684980180d2ba23e473d46af44e03c714e73efd3de2206425276c114256f5ff993ccbbb4450e3b07e3cf7fc2f28d887e956bae14e65ae9f13202a8b1c835cb4ec8d33570c3499c6911484797c9e65f96163dac767db7a25b6aa89dc66939f16da3e84ed161604f26253b5119175387530621ca6beec3cccd44cf0e40eb3a1013a78ffda0730f7d2254c95b9cfe763e3dab37e9535e6f409cc22dfacced9299189d0311f6ac16d9411869e743e47add2e21f30ee984ab773c0197905fad9ebd69e90ea03e60b284af12533043cf5be2a8a5989aca42cb5a52a315ddd60c43450370d9519179c88fd5997ccf60c5857cbcbe0686041bec41315bb6b4d5161d920e2d5f859bf57943042ef32b3e38bc574d15839f6b2e9f2d5d2f0fe7fe7deb76f53cb051eb7ee86de031a07a26adb8f8b73ff1bea00a29d8d5a7e36c5f644609ecf79b604b1f4f8c095184f4b87060a8f27efed07a0e243e247ce6d5c7b7a870b97a44dc27a791186edc447a0949cd51188095a96d56f3871805e2021985973c49d6b694d607232e60d83de011ba515394213b8ed47baca203c2e66c1f1167c65ef6c9a96413437841eb456e99496fd2f99dd929d012585de89530873233d8c3a3f5a8b650a135e864271a88ba1c872b2159b05464bd989280f31cb293ad6b779e349a14354ab36d50d448eea7d58c1b72b6fa959c30a021256663c83ae985b1741146f9c98a53bdf64819b330dc15bccbc5eb166867627a99a2220325663d5917563cc8202ea157f6022cb30ac380931dbea3305767c1ef5796744956172cf0daf44e8a30c90affb86abc693e38af73682079e9342b626d9202bec5293015ebf7fd5a8c72ab3f7faa59168055597068125584806e694d3feba3fe78b0846cc7ac335403efe4ca3c6f4f8c42fbe86070f76acad86cd2e5cc5cb34d246807863e530b585170a50565d538cf12c347ae5d79b5ab3ce959ac69bb25d6b98df65385388087f5a817d9cff36c7fd04806c3eb19f63b6fb25e39e327e099eb8682c3deb617f1e2ccbcf4da4a519f705cbbd17f275cf4e0db4dfdd7ddddd3618e505873ab0e0bafa9f9f474c8a2a6b1da21f995f7225a886c5126cfe5ed82d3b0ed5a393f0a52aac182248ff4046c24a239794f81ec3b0dc8c60552325c78b5d87c9f87ebab1da4b147b05a6edb17c2cf4780d17bb62489164c8894ffdfdab3bccc04237752a8d22f319e8a024895cb82a836412559ccc90e16b1d055388175fb19af06bde7633a8ba53e5315c3f0ca0e45f4e0db8d1eae522c9104d768771b883ddfd922f52271359f43ceacfaa4d277757f663b137b8972175b9820b584e9e13e844738876f7c47f3a70b2ada4b318ac22dd73dcad54e02063766dd34a4139a3bab6729286041673f1a4af3ed80348dded53cf929f8a1a5b69aab2e8d908da35c35b06dd3958b34ac6ef7795dd559ac7d450f7c44ac62df60e651f8f86449b1da95a7cbd3f959ce0c8795eee899747e883e0716946309b909a95dd4e2c259312c188ad108c076fde09eef53c00c3ab8194ef087b71c156274792289901b412c075997e9a7e2a899c4df3d78f835bf8579e7d8fe343ccd1632a821811f1f126a2a299eb9c9133b751d7aa4633157f44eb613d192be92188c7a5dbdfde3161a6d64cc6b437b21448962fbddf38d12803c80a4a0bd80ce59a6f84d8f8846dbed18db72faca9fec7fd423d0c5a61f75f57db6cf1f546769f5cd17a0d7dc8a5d80ebc0bf0f3188520c1262c0e73959c7355b3b19a21e13229d3b6c381f19e27044c2b0dddfbef688571ef4b46b6b54e35d83a7452b5bfc450913f77631ffebd17e35312e60e2d60d752d687cc29b5324dfcc1531c610e50cccae5b4852fa2b3e21b3b48963c14530fad6ddc1b42dfff2c58e823295a3d960dfe54ceabd2706ab72e4d72315b95761fe2af7eebea6413f0147222d3078babe751c1186d18180812ae6ce337eda29b7f619133c9b89eaa53e54f8888c8b8f131806eb30a417b1fc75efa784a4866bed4972bc60eb547cdb7685e695bedb866996772221d8d2416967d5840c0f90b1fff650bebe59f93ad0af11ff2c5130b5691d9b97968bb27d6750bbee992eba2b7f1d7abaa9e108ccbd45d053228ade8055e39e30c259a882a65e620279405e1dcbc94809a10413bec8619330eded07a3450479a04986382a97262a5267c664360ca60b93f45fca1c4ab8467df2cd19ac224ef9c88fb0463aa191f8e030a3cc1202b6dfaf4753fbab4a8ca60911baf70945678451f23ad6ca09853235ccc0a50219779d20414da9cefe72309ba46b452077e746cff2becc75a967bf37602f6735dc48a4d7137bfd7db4500841140c666ea68290eb7e445e297fe641ded493fea3d6cdb6ad63e15f8f3b4220163c6b71c166a4cdc680ecdac8ab845267871d805fc139ca51593e0e6d059ccc0c75f61fe85d22ea44d5ca21e6de5088efd887c675c319704f6120db6e6b69893955ec39bbec1ddd68015335baaafa379e2f2992de4c204a7ce9a59abfad742b37525cfe7b85e4161c274f2207ee9d02d977eccaef6dcada02ec46dd3d723d1a518b2de1be2c5f10e63f07abdcfe0fe9b859352a31a666bee822e978f2a901d409dac14f32de515bbbb974677a13aa6f77be1ad9db84d9ad9a6de1ce5f4142a9608ea0fc9aecf1d48a8ea68ce28489787296beff00b223e23e841b16bd6ebac80e2356b906df135a9cfa70994a9f67c267ae3c13b5992d6aeeac37bbd294d3d266248bd2891707db573fadee60a93d56d01b1560f9a4dfd639f5d14720013d75b55ef66da265be19f24f1463c42cd795f56674c23a84c50148ee4356ddab74318d306a616e1c282b903ebf4cb52dfeaa1e6d473098fe061c6409a6ea299562e35b559a4224ef8c3c4d97e0be75006174482ea37e1d479893d6bb58c91675ac4741ff87cd8a827b86443155df2dbf4f0f9b66efd582e721ad68807730cba1820defe9143e13d3a4fa4b9dca00c5031c371791fcb40394a52e629b3a526f6f01820a64f7a0a567e262891bc934e128d0d0919639fc76fafb339fdff7215fa8eb1ce2f0dbe199a5ba750a5febf3cf35304cc831db0670690183bb8e89be9c615b30841d0c18e21e08a6f1f6bfdc6503011ed516aa4d60f196531a9cfefa41cefbdd245ba066bada1f110de7a70f52c73f8b29db720df41650f03a5fc68a5157307773888a3facf12e1815f8ebe4ce7024919d1963eaa3302d64d071eadf5032e7e0860fcd575e4c476c9dc005e80fe07a168e1076d8971716cbc986d8eb0e5eceb5ce57d0f13ad9408572791b9860ec1fa89d62b52235fe7c84198ed141be75cfe7e0d59dab00209acbc463edcd7fc5089243845870689f4de939527279199bb4319fa7d670f021458bbdb576273025f8269427263bc7f10040871e483d557685c88046e6458665e571f8e950351cf205d28b5552e948c0658453fdd7a7e78f711402e0beca7f8738c4d73b8dd1e2d7208d1eceff304e219fd7b1bf314bf74b99b029a6bdd67201b75381108961ad2fe5e7edb4c085d695f7a033e585cec203cea12e44f66fb995916e500adc39a0701f2ff89905caadd250bcccd840e08bdc6e1e7ab776654e53401ea8a0903a85b53a9621a244f6b7e8ab69d7a0ac7a86799a1c878ba99ce768df9ca336055582d2dfa91cf11424af9738646ca1db0408a594f29a607eb3d49575156cd19bd287344500bdf4ffc7ffc0a81fad5cc611b2c579a4e8418df6881b9b3d400c6c325d25672ed6da8e89339c3a3b5bb65686ffd5aac26eaf4c01609ce7b7922778b56b30c7d7ec33bc1df15bfda2e4855f3ebaefd2b3bec7d9386910dadbcdc3c0bf19954b88ae6a56083d27a59508164f4e7cec86a5cda789a735b5b2d2afab894da6d81fb4fa874cf9eec779286d7443d1dd6b83b74137e5fa16cbe2ba7244b9b491ecdc1fc74c58e8ed1c7eb5bf6491b56724e0d7356dd0d8cce2a9d4718f4e09a0752fc3843ee80d2a9b131b065d147835a082e383825a999383613f2dc5f51926c165575304394d00196fecb1ae7b111af6cdd9f1294f24b0ecf4da681b35e9e5d5d66e1fa2c5bae187a5e89f48bfd6e9646877a3b6b18951a70c43a838b7e69670626172f4f38f5121b92c034015a001e4961165d76c8da11f14b08e839edcccc67704c1091036e7784b06240e57e4e32f67a57ad67191e5e9914f9e5f25c148fdcd4ae18dcd57a28e96856d1f9792d7778a7f180a9020a5a0b5d9b07702e15ad0cc006b7b988eac8856abc7c5f1f9756ca9e82b8b019af3baa34d9a0ca86db308b1cbe5f4e921dfb5baa386260b43fd9349e06b4f85defcdc0157da18760e2e50e9018af4a1536f87cb35f41383874aafd13ad87b0fd99350729c8197b9427ae4da11505c5fea42da79d08a7df0c7f2a3c99be7f13f315a1c38f3482ad9db16926a2b4699fd4f5acdefb67e1965bd520db960a94d38b15c701bb3924ff4db9066f57c8a43ac1d7467f53ee442849a7cd0631584747f57aa9b56c58bbbc3083456cd36e7c06e7ec1cc57b0d01ed0bf4a3c1f9f6d28adde434e7f9518b5705b5f021a0608a59c3ef19a3e6b2771df35f39ffe1ac66794154d897c03432287c18a1b83efae6a062789899750194848d012a72b14858a77b93a98327a55c57c50bf7b3b06cd2ec05f0cfe31d19d71c2036545cba3abbb7484e37b863bdbdcc6c9ab3255f699a20e70d87aeb6e6b2441edb0df87b1aabd1d80202f873f7af722fd4af19077f2f93fc3c4984b99287a2469e128a8d117d7e766e84f069111aa569e0b9c8d0f75dd995672cc22a75fd868aaae630cd8da2032667c66a2fd218c59fca0f9815d24056bc9027fda1838e3b1cc605c5445612dea3eff8e81ca71896c2db1462a1523465bb3bb33cc0d4e5a83adfaa72eaa1a8374b56cd6afdde9e481920dc88971cfc65933321e277c19d03aea230240303557cf5f2a614f5b4eb09830c158bed77d73ac527a6551ed2209ffe7c6c35ba24e4b9544429199f3efe14f93ef7807b40b5a8beb51658dda4e4925eb4f557ad13f08c8f371b654e31acfb912c5a454b35c6f4911737a7e746dec5c1a16d3767ae2790eb8ed83913d9f5ca1a490bf7bc68b9031942b5a000700bf3f09fbf6ac2b2807b5f8dc594f2ca32a0f058f6fd9dcebb74004286d103bcab9aa6fbe61a62dc72fa96c48ef0a59389","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"64484cc66a083ac703b068c55d9f831279e1e30498eba4e3a33e2bd9ade6856f266cb5007f7d56022f1efdbd326d39adc66b12a0f3a5f0cbd6a64987bd108499334b985246cf8ceed216159af96b68a33d07ce4108c8081d52317b8ae7260bdb3d9c05b41092c803ad85fab7b302bbbef82cb4ac42a8c117f0829bf7ca3c0424c479fb7afa911f0d49ca3c0ba3acc4cb87c7b8d6388371a37ebca037f83b92be7c9cf419928932cf0d3d4b7d4121cc17681459e2dcaf0ea2fd5096d2f9adefc775cad4b8399f8770ad42a49609f3f98a04c6319389d2f8804ca1367df69627c88a8ab41b45c582d58eb7e07fdb8c7d71612989c74d6cf28cde2f16a5500bd3717cf45f5d969fbc7da288a65ef5c2e2974b05c0908b8f2a774b4525e0f1526d5195c7a230d557895de31aceebc09dbee4d1900b5acfa0e3a7ab8e7d5c5213602cf6992b20011ab27b6d2786d479b5f8527b4b62a6f893d44740350c8aaa3c096d645386f8fbd98b42a92ce1e1a9f1a23d4425e3df98706e22808a726af8dd76d1631ca7ae304f5db8ae7d53947e919a3887bbbc01a599dbe3be5bb991327cd0f0448a07f4b70ca926afb25d8780fe7c3ebdf4b1d9556f1f8252945ce47cc0c317e7499eb35bfef567abde5051a5f3026c28025ba0f6e1434e3092426dd8353284793a644e1a565a7f5ef89f03707575244de086bdff9dcb3bb28e32125fa6cde2e2d360d8487d262bbb91376e67b67d41b1f1500869783c976e2af6628ebc0d32c81f7e24c6a746f8a4201e4422884dd52b14e0cdafa007156f9547fc6a1fcebf73daf2db2de10ffc0812915d2af1764324dd2a3ec17d1bf19e08c3662aaf444ddbccddab04f2eb7d1f90156f6534deae0da61c216502d8fc62881e78f512db9d7ffd33fc8cd9094942ae519c0a267d5f156654ef2e3365e725a317136d2ddc2384d16f34b5e9a1b3084328e2eb37864dd4d1ff1efe962c901ae0a2568d0992e241a7dec5d08335c247810154b80df1d6fea4569f27b6111271292ae5cf30bb55d8493b2ec5759038c437ebb24a0fb129404361720a9a4e24b514da963ddb8b93b5272bd0b1cce1aa0384f7624f74b20d6763ef4bb61781908f1318b0569e77fc3a73ac6921cc23b85d64e8690dce4fd2daa988d50e9af8e6531198bef99d777b07e437771364d4ad10cf5bacda65af32e7c1a629f997904ad7425c74811843c00cd47d463fba0f917d92b3aa49f39e66ffe031541bfd14e98309ee45a3319bdb16eca968149df2e744001350e94f21d8bd68fc13d57f94168fd998b2a9cc8cd2ebcb45e063992a6741ba1b1785cc8b509abf6b00c5f245cac108c14657662700f73d40f4b7b54bd2ba65049782da03bf5a9922ebf4431fa0e6745c0c117fd04b81b4acdfb8c6ef3373ae20c5863b300208db2833753a037fc7a660a3f46ac3ff82a195e2ac5423bf9191c62076b203e1cd00e1cb06cb7a002f3b8f207bbfcd1b93fba9326b33b1fed01fe6d7a4c920ea8f219cc9f949f168a59777fd61d02a7c88de6de5ac7fb5878dfcf3389fff7d175868e80ec349fba15caa1ca45762389e9fa1b05018cbf06485b4bb8f1b9f6555e458d3022de9aceff9ac014f0e374e4ae38178e3e42f371628858ee422e39907e43d73ff0ca04527fe981a473d4fd910bac30ef77a67c43755b43480b47cabce7bcb6ebbe02624354ad4a51a59c10788788278d81e8164a176ff49105264ac0de5ad5dbe78bdaa3016d6e27263dec630d114d1245866470b19ff6024e8a7fff9f9ebbf496bf0a9ee908b8bc17e3576ee47648fb9368164812333075585f67b6c5fed53024fac653567fbc581e2decf03972ff2a2e7cc3c4fb850da60843b70304eb2f2624374146287179c1ece87af91608c1ff686e75a4f631fddd40eac57a61d2fd2462e75ccffc8e11dce1b5dca9adfe64a678848291d4acc205315c42e255c3a0661c87fd3298b386636454f64ce30ddc3cd83ae2c58f83c4a73faa8ff3324f36c4516e8a9d8a0876afc10f2bd5e2001ee2a7525853ef3a844752353822c60522fadbf59f500f17970cebe265928f7ba1ede6bf3a2266c8309799e4e4e55c9313bade19dcbe3701a6690b1c293bc50fa6c637a713d2d790bcfd573671cbbf7e1c91a2dcd006eaa5b5132866b389264f12c69e7ff5d4f923a08f41ae8982534921c26f4a205e9b5c0e7614d7ed1a5aef66e769a68e492e7a374fba5e49909e2ce7769700c335ca63a53bfec89f2e3e968f339ad88b4a2c2f86412c34536933db264dd390c3116326b539f676bc6ab432c00f42408d9ffb09ff0a245f86244a61b1d13fd44b84655c22247ea99bb76412b62257d6be71e32f9929979e64fa14cc88444304900d92bc8404c3a1e87f40bd8cf9786cbccc28cc125270965eebba45742347a7b47c66ca998cecfcb364fcb41b0336ad6c959209e0e0039e6fa89712f6ff2c80430b58a0eeb236486e2c0893d5f634723588c0bb6344934996be7e2813f7f85af4229e49b9d5af0411587514a5d71def4f61b1a2581ad521515973784dfd1231e6d71728522ff5067b681512c0b1bebecfc3d86433f151db01903c9c5e03ad5760dea3e0c13bd9dffce66dc41cb84104ae9df400d44669849121714582994933693e4768eddeb95730d760d66dd759c27c1e1888dcbeb3a5973ada8286f301de0fcfca3b14555a49fa8d6b581722847d9f87aa2d40e575c988a890b161ab05565e7da01cc373fbc2424d6f7c6483bd3c0cb7afc73383447bd02ac1e912e958326cbb45bb6619c6d857b56fec29b9d46e6925af6b3b53a5da02a3f430afd8607562e3a8c1eb1915ff97b878ff4ec50c5fc70e2859d53a2b48820f9a276c1308b147ade31516a1fc49a515f6787f7aabce8a9a8f961340f71b75edcb172a07adb20aac2962c45d8b03b76ef29d54f54106bed928458172c1b1592819fe917c2476b28b161d5d051448f039b789dbb2eaf23c855c0dff2e2102aa04524d6e59d502a2900730667b7cd7da125978d3015e6cfd26164ca006d325f5a52ddaf81d6fc67db4077532b6bee90e294d26ff4bb6488c17999993b2ff528d31e73396e5d6809c3eab9eec217033bc91f56c868986df4170c28a6a80992eb4da6f526239b3981ffe7c0572436631980a3da02917f1455a6760458f23ce174b56da80d69012b8a961d294f02897946f89895242cfff85f546a070faf123f3392388a9fcb49bb32e1f330f55ed351c01636aae289b70c8957cdf105deeb71db1f13fbc4c39a27eef84486c31241bfef241b15ed40fb20709fb4e9a19311f1495d1a8afa15b08bf53ed657fa2ed9dc80597c855ec8be7d1d9b068d98b170b996ecffe5e73625f540677f5395ae781980a13ef8622117fb94c749068c88a1f24d9c9e9137fd9ce92c6d6ebdb48a088bcc74b101132e789b8d29ce5851b1823b1d52d4ca104455dcd09e7326304a841459cac7e9194e130336be49dbb37a8060bf94fe681eee00bb26b599a43fd0484b91fc5e204bed6d49a49f56e1d092ca072442757c77d59f18ccc8f03fd3a8a3c0b2bc09a9ca3e0dcfc53f02db068876807fbaff877502b4c527765a3717883e1d901c87cc8a2635bec0553b8bc9ed1e4b3ef59311f1020b983b9fadfb631368633bf8c64e253e999dc779bc5009ed9428e3ff40f96fa59a589412c68e63d5f6f4a12533f7947ad506e75af8ddfea81a9e6635530137676dc965cbcd0b92f286a1c0323137371be08b785f3d02a244b593dd602541d8b23e8cdc2920c53cc640e8c9be89b54a1575f4981ec8b3917a09f49dd8f1e5d25e9ac3980f7e2872f1d49c580b5247f87d790e0b1e8abe70b8a8e8193f4eed9ac62c9ac5103202492554d380cf390622d8346d35f4d56dbc72ebe7fac896c792153d38f5948c57b69dd1b6f96617be34e7d023a2fa1324851808f6a43cb73f674027f42eb7dd2a605040572136bb32f707aa796eaf5ee277fd8fb21dd5acdcad6ad44f9311fbb930cfd498fa66c86b6dc7c062b137bbab2a9ddd56e3bf61f7d563caa7bd72a9c8b1951cd9ffc8c0f70a6fac4297911e0c7a52702c3a3b0d2b8b77726097f7ddbd2ee3dbbba777feaba3b5c44af010e21dd2e9c23536de7a9cb784cb34eee52e981d1cf4c8d640305e9040977b18afeab919d0ebe382310b6db29f3599d722d5d361b1f29a2d6f3ba5ba7a4296c13e75f8307fd721d48f09f2da3d5f9253c487d155ca2e3f80d29feb4164250d0ccd2c4274f58a1ae2da39e5b654bb55a258421771218109d2694d8712c02fb18d8c04458d3c449dd98524dd476966ccdc9d602f5200c5cdb5d9844d03a4fc86a86f148853017925e8bacad794de0dffb1656ee6915373721c581fad19d275ca23e2192ac4977dce9bb4ca4b29d6d3a9a11e4b3a6cb3f61b5cd6d61f4ff705a078215e61c7e04ccc51906db07ff7bc1016efa6cc1a6cdd4cdc6c0b89c3cfc871d524cebf9b7ffa8b6440264a42d7b8ce1102e5370433d36fee628636427133c4d2d097dc6f14911254868d03ae926862dbd4c34a276a2b8030def58244dd722ffba5d25978f76e2a096bac4d764812cb39bb332f63c7aa1a22f0b7d88eed197b19034f12d7189b54a18d5b030985861216c8294949e51593889cc76723a44c0d8034582d77da5c30274f08438ecf27c38121130e6ce7ada7d9052f200c75ec47d7cc1f1c301aad639cbf9640512a4da7271478115138c28bdb73317299e7dc5ce3eebc740d857561ca05c4493af454ffbdf86606da6019b66e6c51a4c62e428e71125506ab619435c17d02606aaa6c6548ea0bb1186519fb2e030ed66d7563b6f1a4b81c331da9e49cb19daa06f212a1dcfbb5502c8223c6a83199ccd8fb5a2420e6a2bc0eb3f3107a2eaa56084c480f486f935f9225ea7b9ef6b888dc73b339ba06ab1865792620f4359c26758726ef3c1c729faf6523488cb95c2b071dfd87616d20f9b55ef65fa4155e910a8381c32f9773ff74b8d5e8b92eebc4aea933392153e322abf0a8a76ef45927ee091b372843562dba5566615c205535efb90b1b5dfd4d9580ba9ae1141b19e196fe0769a93bc614bd6357a82ae4a2cedeb666da41b240f3c1a33af48a42589ce483cbf8c98caf328ea344b2e2a6e00096b59fb32e301ea65a2ab84e45b9bfdc23918ccf1315a1e414bc0929b8647ddc1e811f26a0dde84d96e1bf6d1eccd9bc5c45b31d5286e58e4e50ba511a44846ee0ddaaf4b7254d2bffb52193a756d18747571d5e9955415463923375409411945c39196c04044c359e6723b8c09f1ce78bcadbccfff77c6ed72638594f6963b4ed2660fe2b71b0a3a2ead2ef946a5bf9b68e3dec0a718e74c0c5913343a0d48ec9ffa0817844a9d5d40cb2b7ed5223c0bca82efb42c42a5bd658ce693b0b79d44fe80cf7c970540c41b4aebd870933a3ee8c33ff93f9a7bab1403d21493e8ad8c6dd7e0ae251d5da7bb3031f5930680d25645df2297e6873bcf1b2b557dadf037d5196f83028fe594b0a8ba65e6e88b75f6cd10ff777e4f64770084b90529ac3a11f41de307c62afc4e0e31457e76b179053ed28ebe4adb4f508f266047e09a23f22b57f0d9ad359f26904bac597bd778fe736e90933f1768c36dcc69d728952c6f62947f8555b13e88d9b6bcf6cee5872e4feb0bfe815ab63fbc3828ba623370e121c02f87525035c69029b46a4cf1296cac1c6831e3573d907752588307de2fc855c5a628a59690bc8ccc808f8e9c86fa9c980ef14c3af5f35bae30eea0b692da7688efed551af28d77868d2628df7095940a0e02e27e038ab55a59892db6923d00cab45cada53d3ed47c348f9e38900ac72c6900ace96b237d6af8409e1755f3083285bf0f6e9ec726cb76f7da9e941649ecf59bd7b816992cbaef32ce0093a52b6b7c4d6493847af65917ffe3cc6ca9285b62b1fc618303026381c77e9b1cf6aa378c0cd3015d78367a57294ae5458df0abed7583e3bce1e2bcf49c19eefff0e9cb9e3fac93647122e7db0598ba91e15a8b830a129329e039c90b74c892acf0e9f0cb0893af307cedbd53715e8f9145b20f3ea71272f85d9afc0190e3f005b7d6b75b5fa85ee92176307426193809076d275038be2a71a8c9c7147dc28234ca887b0d28efaf2046cc15a7a7b5be93b5fdd59477d577ccc442eb5c117de706bfb1e453a94ef870231f5cb50da0a8e9d22c0454be2b0ddff604c7a9bfea2a1a8620e04438137b84d2684e2ceb5c1f9d2230dc2bf01dfdd2a1fbd5fb9f22ff8498f05162bd222802c14854e583deb444426d0b8eea94960613e2a4bba6a515738140c8bfd2997cd370f550e750b60d2dbaff36a62ec6781d533110b96e2272f9445d2d36e4e5c932cea9157fe641a4ff9d6c0ea389618c3a592c0329ee31ba8717eea5b87a15c89b75c88bb263d83a8c9a585f82fe1b5c2bf9edf1a00b2f8299899296cc8171e622fd041acc173a9be4453aa5147aec286e9a4f9622f9807e75ac588fb32c0b2e8d09a9256f3b9723ee84e93190a897b5a41b151b49cf31bca4fd079fb8c704d02ad6c98548e8456f006f629c06c3bb453ef8b5282c9ad92e9bdd4caef7f7261532d5d40dab263424a601a1d765dc17986914b37b8e07f57779b27b37f55c32491b94caff04a4eec345d0dd66af560fd821e193d15068d648edfff3081d1a7df04f31ca1f599a9658e6828aebccd31e1de665a385de7392322a3bdba6158c0efe3dcc6218bf6bcdb45e57443d2a83926359e0e9d008d768cf20fb81cf083acde0836a41e046abb13566367e4fc29bb53ed67e363fa37f5eebc81cd16240206b426a99498e4e89b29845b0aa48a2094e02296cfd9018ab39ceb81f79adc34cb9547929bda0d78ba948c9f13c55b32ed3cde5c021d704907e1e00bdf9b0941d9fcc703b753b6d99b2c25bb2629c068596febfc675776b84648d0c965588e82123ae755bad9bc7d756540e7e157fd8557201f38fa58ab9e75f7caf880b6434647f8a126c9fdf44da6711406c45ab85991367b18f43c1e121f38a1e028ff6c8c7f04931b5a023d9769a5b2f23f0c981b8d6f3777c5bb56181932f2d4fd12c5e76bb1236991cffad43e8e90cc0d40e954ce34b50cff85a64ed225437737fe3e2f97e5c471e4d62497e5f4fed41dcdeb6a0765df138fd43aeda9f0b04c2ceb5a1a4e006edfccba36d65dd50dd6088c9c6bc753c34e72e4a311359ef2ebdf70ddebf0ec4b886ce385833b1b07d4a7c5fc3fc9d3a50851dd2ec4e829ec98d03658bc9615e826e5b96ad7266feb626c60627e71efd2bcbf38149420ce5a659d11610d9bda8fd4396b3d70a4ff0fa892b3076e1c8caedd83734c95537b0b8eb635ea338e187208ef2756c4c8f155b919a50d6ab616784e3fcc39e673fc64b8824ec3a045f3ea222baa741fae7a9d7acfcd42e809a1c640ec401b620c7ffeb4ac1b2070046c78ba7c13c1a88ef81aa70a300db5d9a003060e10ccc344af311447c4a2e019e70b26869c0490d02325ef9abbcc49c95c69e5214d6cf4addb5fee2a8495fc8096f362c047db12f498ac9bfa8b8457942083522f105a36c78e6d2be9e9fc5349540ac9415e6d655a255da2350a49915a81087a3de44fb4580d5e1d0a70cc680839fb53e68d9181cf3dc913a7e522f6587bc5d0c599d65216bd2a6fc7ddd6b7152b71c97a915d31ec85a9f90f34c3ab5b884299aacc89722496c0103c393ca105c56cfafecb8470d447a5562d637c44d3debc01bde4023101b709d486ba6493f8071744434a605f81be7f24a629a854933c8d504260952f186870760b49d4f6cc3d4f10d0e5d5d2c8dc395b315e95d2e58d56668086f3ff99a38ef5e14d471f9fdff0a0d18b02576356cff0ddca0e081691e44b51e0576cc0ea5248dd0b701ed73fd173d869ffa41be8d77ed100de423eaa87421aa529e6dfcef0eeb9011601d683014cb80e7d4eaf2da8e2b452438d123f085381e2882193db8bb0ce4eded28726af5b5d8466f5a3046f59d2fd92679c0ffa167ad814b5696cce0d2511d9cc5e20362e4d2a895ed58a114edd6430df2be855d4e7444663aa2e666f963384bb28b15eab8e634b743b7d1ae53b1f1f7bba059708fe6d17c5d4a5279af902e87214cc81e65be5fde37b4e20e21c5a0dfbe77ec73529466ce10d5444a9cbb3e6ba255a97774c7c09141cd3440efd2a5998925462b6690923926aa49212fe8759679c436f509fae0091806e1fd6ebae282466cec666201bea54c2a399e7721ab91bedef291f7f46b77ec0038ee395e36457317257b87bfffd53344ed4fba425261f059c9af6daa9ffcaed9952fafd8def8be6d6af5862ea8c7ae9e6a805986686f70a93c58911416a7073b28788d5429195e55767b3d11141fe9b757775dd8887fa4302930d8923d97dab46515d900b52f001bf323443d82e9c2f68313a16f7117d0b106d77bae8041256d76fadd154000dd33345954bc70ecc98030bb3ba789d2c3481ddbfa5fbd5d60426552c54c05ae9399c7ec842282a1fc383fa68d8e622fd19baf8f39c1f3045a9e215923770a8bfca19886bc46bccb20cbf0d4cc1b0aef3c238f24529a0fd7930cdf05740da2a396d4633dc84e8da02cc2ac952d48fe82ac3a85a92d847fdbe694b2832fd2dcd65ac56a55f3b17267e5f56412567fb9e7f64c6d00b14f3b37d451bce9f8af3b2e368592cc87e5c11bededd41b784174892896c1dc4c5c96ffad01d75e287348e3a0fecbbdd019013d0cf11a7c003b82d367dd37c6d0586a75c43bdb5b6cd652e78c4f2e430d6efbb029ab75a80c8450505aaceeeefe2e1baa887d060a764584ce33e75acd70a826eacf9251a96d402273bf79be7727dcca0c1cfd7486439b774024442511e71dee7c6b549c52861425fdbb352224f0a4da9ef066c561c5924ed2bccf477b2fd28b4a9a2c32bfce06515938327b9c37535e5953061bb5e521002a8dd3203c97c4a67748f6f041bdaa887ca3ae742be70c09242f08a0da02515715d5206f47b045f18d311c07e4ac420d4b04d955e39d34a47927a9956a40c86ed2041606849a488aa740af936348c3b9136ed508b6e316fed2d286ad5815a04366ba7f857ad050736f08ad035409e36719ef815bf46d1b36bcc6a69ac31295f03f338048c7b0a7601040098c49a9cecdcaae771412e6bff375f17c410c41c5fa895144b73fd59c06a4dd87b859363bc08308b3f26abb27fb7b21847b8ba4d6f40cf413fbe9ffb8749ea1cd025470b1125c4d0655ab0b4d7e9fd30505f6ee4c5b801a452752d1b85ca4df042c7c2391f74005a381ef69993abb2dbee1fa476da84436cf16e31b498f3f0c28ed29c27cbe2a253028b4530a1c5de8c45d3091929476759750e5f0e8f06fb2d1c192313ef4269daf76b1b97335baf59cba45a4dc046646c1013bc5bb2dc3ffbdaa5aea31d6e9e13b8deb75297ea6d7040081594aa4d6e9789a924a64921b8a7e8c9d77e033ba1264481959255ea41b58f283ff95267caa526a307938ac43287be2bb7bba1def80ac079ce1cddff1cbfec60bdbb99485ce1941628f6fd57b34deb663982ba81ac69e1d1f5a975a1b751b68c6ba75c98f5407048875031dbdfcae18a5a7e8346a62d0b2d67c4df4e4c37f2a7ac8f9dddd87f1e32915adcc4262f586a77c1ba32746fd800dccf1dd768dbd1ea0210aa1255f4dfa117f236917dcca0f518b07e887d1b1f0fe823e910ece7c83069c01c7f93e6023f237a5591efaef24c860bba74f244a6b0bab9f50ee2ca45d60b3904e42c39460ada6b0713b0c14dc51959c26975014deb0582fc56574afd6bb6b5a72e916f46483504842baad15306c4c23fd5f9fe2e915d7f4b21f52632e3bb111e0be3e5ade4a94bfd0d7812a9a8c21dd246a0de80798124c0e5420a6fed8155e2db2cca505a25173a18b23609634273ef2df64dbe02771f8dc600b9632612ab6600a2e2263653fc0563b49a97cd19f1fc02c7d3a3baa78b8804c8e70f0b2a36284d4c52e805a31bcbf64b6bf91defdf0766939012a85790c449bec16f228636cddf0f099bff509eb09fe80741ce57f8c23edc9cdb767a998bdc7b1f0b6fd20cd96bdd8cb2fe7c101bd622f85c78bc8ea8dab36ce6876b4e3eed685bf1a67ae96c0be7e81f22bb0febeebcf6b151f7deb93ca94a0a0b68177f5d6e6211b0ff2e567925fe38e4c1fc4473c5ce155d8b3123ff358ca4e70c70d7beb193d8c012e79a840c17ba678fbbb2e296b8915adec2975137dfe9db7053bd4e0aed748f0f1c77086c20a0d1d395fd5187461777e6849822581aa2633e15de859df0362c8a8fe1b1a244c84eea978bf9c843ec82c9a8fadbde9dec2623f05b85c08d4d5625cf2e61219c21f92bf831a502bd0de8656905d5b5d01db0f935b455d54a95f48052fae3a92003f74565cfe6ba077b5af474ec48c52ffc8ce2692de4bcbc4eea5606e7afd50c3d85cdbf08b76895f8d1ce763ca825ec1c1487f714cf5e3365b0d8cf6c468d88c7f290286dfc945d1d3be85f9a989daed675af1547f68714ee0839814b6918bac8a0a817e55cec8ea4465c2d05c336bd308a6c776815479abcc1fd03bfc136640c22cee1e97281584887829aa7f26c3688ca67b4faf18ea714e63c538eb0934de6ec3e1ead071d85f57d8e1cf39e79aa95619d0b1b91a2f35b3f54b09adf0048c726445f346eba6aa5c6db1c03cc7c53f7948bcbcb0aec12457b3b72539502867ec7d61ad676fbe804ed4738ed5a1369920396e14a5a1ce266c42f6c2bcbb814be9a8c1021c85d4e34c2c525a4cd2d62577ec13fb06f6a96dd5314bd0735b7787f93e8610aaa87ed24c2f94370d0d001d0ebf2d37fb1dc94efa460453086fa72c53aab2bdeb0335f843d76fda531ec667a17e0a8151bf049c09f054dc1b0923ec584c3d6c541a4550bdfa8a6ea19c18a97684bd94786fab7ca29ad813303f837bbec0aba4207a7fc5bc89ea14feca8c58616f33d222286ba1099068bdd87f427da1a2e88e4b39e7d1670b7ffa42a05f0f6b164f0d157db3b8849b339cf8e40ce74f6471d98fb604d70910964844f44b88fc9473656a7ac7e2bc5eba567f6dee1d32b743c322a0fee8695a377346b01e2ec7ac454baae23dad3729be6a12359c6dfa5e8f09692210177d20f20f5f64037579ecad0018124e46819fb9c57ab9360f2da8b5301a90e11cfc10abe621dbf1517b0e68714fbed3673e8a9e83944c9c038250c4e987cd7e866e9759a37fb911ff23b56684abcd6c06b09f88439f38b22d99f3742b053e3140de85ec8f3eaca520a08f85eb2c4869492c543cf8aac0ee87ef1df7e4812235d359cba53df60c464e19804f0ec67a957146eca5b5f02d90517add988753f4598ab3eab201aac932c730ca9418ca460b2cfe5d7929853c33ff3da4be0dc9009818765f0b4c1828b7fa3fd742bc9bb7d4c0d2e8545c674f811dc04002e66add9c7690c1a84c2e3d43e5790c0459faf22d1635d60e669878e42fc2b308f02e394a252263ee175ec816c407de39c4726f7e05d70e744c89e5dc023dfd18a8b9bd345df96c01b735504ee1d3b822bed3e6b00392ba7ca5f8db65e187f85956bdd6c2c1c5f71aa312ff716e73deb306e9e5e6632f3d9202e0f5fb2ba15dc523f2e1db6ab829bef046d548295b30a30f5575257f29e940ebb6c0a8da7b9a5cba4f6732dbd76d3211d3eaec7d709f941a3cc78cc67b719e0a2c3008f3fd4e50af0b37e33678e8008510f8efdd68a84cc3dc5becb64aa578692ba322a1c1880676b85447b8f8995431d552e76524d2bcc0e8de3d19925310de8cde2e74aa8eefc2f958f0cb1bf0ad7e19713796383023b4c85376652d95c8aff0e4afc64b319601fd6520cd3bbdf349745f095a0c9671c60ba3d85dcf0425c06a3d053db3ec542e2c7cfe56af330d44c7c8e909535c5ac15b9f0a11f02dc7bbaa1c20b642b01fef75eb485e09e639a67d326ea65ed80a538439416d2814e96d30b16582882e9c2fae33779d309c1c6a017ec212196e88aa43bd7f5ee1bea8629569a92afb1cfc80ed5d450e07236385b4497a5a0f93730fd363e1ad23e099b4b70b03a37a8d41876cb57f28c59261cc0700c8d318426cbc163a42398aed089d94de8f5e44eb65148a56713f1fdd2f2b342eaa5993d34b7625cf440884d80b000ce16a034b077fb234d96980f79f1b76926085ea8cddc26c93071d68b061e7f4f2aaa42eae6ff2b42d5c3aee7f81beaee054d25144719b928b1a286539db2c59ba9080d63b40e9b49fbdea8c3b28495ba4558cfbff0c88b3995adce7e0fa9f432ee3ed8794aca3980b0b3fefd357d37bd67ca5bdd8da98d4f3a7aac033e3096be6a8dccfe82ce3f43d1164627292fed0c604fc8dc3230151a5e8a346f911c4de29925528ade350129bc465631c3d2743bd5b86796aeabf0478b2cfe24b4668aead37e0b6da7d1e13f59e810376d37e549e4831858688df1e81fd942e06feaa3837bd5585db2b8e71ef2a9b8a8cdc721f6426a5323066bfa19f7b3abb8c28f2eff348324ad471af6ae6a626e08dd98923b0ea36c6f1469344bb252809d5aefaff8b97ea25d8f96d13e13948f1639bd22d7840391ba14112b75b7a4364eb526658fa1e26adc7872c568ab4a4e0a2759fd06c0ac4460cf11bf30f299ddec8c7cd6aeae0866c207dbbb5f5007b3032f0cc77aac80d88419512a777126795f0d52479223f0e7322d1352ec1790f370ba74df4cc6fb81a9215a3ec4f62c4a26beda772f92cc5f40f64b708d4cdd15f733c7720cd02ac1caef491f167d1efd7ffe3a7a80797cee2838f195b5522fd8f035af2ad6d230175327d993c26988253878e7e8f4d5e81df4b74b22ab68326299a109408aa7193d4e6392fd305f6efea2d08618bcfa529dcd0ed72e13ee12319d510f56b398957c2201beffb6bbad22f7fd2ee6f12bab8aff47c67b47523227a60aff6167fd8c014e8cd9f9036a90bab3e181df5cc44d523ffa6a090998917df154a1f53f2d64773710296274755bd944b2871a0f3701a027f3b0a914721658c751f61f749dfe9de8f29457b70e735aeff576f47b915288f02dfad7ddc0b478f12dac6d4481a2a2421720ea3498835ae8c3c38d44f3854dad31334b7d84758bf0eb067fa42e2761dad61c428f43fd364b918b2fe74c114edb6ea9b8f63b80d232980ae8dc1ba487f90d72ac67a741fd997c39c5fb629faaa4f967ff369f8a0f4193138120f4b9cae594145d4c3ebf7fc204a6d63c543c221d0a3d594d28d8fe4ec1398a4b2901f07b3b26ee4016be4d395adf2dbe02515a9324b1496bdf19ca4e869e3b4a5a187fb9f4f0d16805259a6fbb6015e88e1cb47905ee8ccc97ee19c8942c2e9d09b90139056d0a643711ab5e8f4ecc9541bcd05d565dbdd99ea48bf5d366fced72105939572b0196bf1877af1e96a82de57f46a81a4fb6d4daee2bc5a35e66aa0faef8685c726f1173dfedab8081b40b019c7acd27cbf89c870d84a8f73606c6bc6cc80bdef088644fe5ca43492c36c1bb677fd76fbbf70e07c871d579245f5332882860b5a89a97175d41da83a1d6e4bf4094c381a7cff1121579da6135dc821fe9029144abf16a6f0327502730038b6051150316e253b19eba4e1138cd2454feeef741fe1163dbeac4929c96cb014e50da9f764578974087e807363daf204e1cd87437d4e0fc1d4150d8b7accf0c37d2df97c1103e62e9e24e733127fe866d28742e165ab4f7c3f12bcf4f505fcfc62bbf68828a33e2f9064ee8b27fb6b2cca1a7cc5a2c34fe80b86964b45f0c72e68b8e55f59b1a09b8d9b3f691c68e075d34eb9576081d7caa878c424626cd9cc15d99acec170c44b3b152e54740632090e76189e7e075be90fcc57ad809fef96120dc92fff6ee6420d367e1372a2a4c3b7f10d82daf575dbff9a29edbee556acd831ed1fce88b8d6f7e912b0837adf52447d6c92ffdbe757e86cce3424fef6d760c405a04bdf6e6c4e48fcff6dca41bf122e2abfc3e49e4110bbd81da69a2a1f73d057c1fd4c55fa764c661cd7f836563e95b8d41b2bb215d4f912ae82cc5b792e4c9d2d4a9146678478d4c9877387f6253d889a74afbd3e071613a8e1848dd7c38332b6670b856f6e273bfecd190121a5c7116a9db8045f2f99bad0c78b3b50d5204f0b398d8933286dfe9aa2b768e4f3c26c99b89aa528f4eb39f74401ff44fecca8d0420f1e10ab64b537765d9bb0fe2114c3dabf4ada8e84152eaffd1495347478736dd2f6aff8f147b6f7cd6b3349f9003d4d369af54cad6e1b363964c10575ae7dbf6d9dfd44f0b660d547729f5eafd5ba3b88a2f58a7a285aed4d0389e04162924e17912fbdfc8bac3509de91791a1699756214c23c42bb818964deeff7f68ae6921598e4cdb377c2ee5d30554fc0b78294df799c84646d916","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bcf375a9a33023f2cc71e0f2d6dfca18efef5a77531ddb33b42e323ab56faee712376d42c30cf73322a3f62276cd377652d8210d20d94c6f1ad6796ddb9f7423cb842ff7025029677f5261f1dc1fb81ba3eb6df7bf690ce9aab04aabe17cd705fbb38628eee511675b19343bca5273de5d9d70fa707de787415610af87692a41f14f1ae906897e22c17e1883ca4e5001a964e84735612db33ebd4884c9ac373318766ef9ec47afc7a63d58c173f871c95ac1212d5f001c77841e54189e6de637d060ade2d53726f2d891720d1dc9f15a712db78789557eb99aa05b4415cf1d052b30b3f7ddd492a7fe2d0c466bab7904f1fd779fb74251638fe79f6d65a2f2c4699bfcfca2827aedf5bf292e2686aaa4f6a678f1717fae89cb5a4c08091e6439d601f0f2ba3e5db15c37329d2daad626881542585321bf338eb47ff75e2cbe21617dc09a8fa739c5442628be5bab4b54661a2d04141bc764f5f20219c731c0e99fb4228cd39ee8350c5a25c794c1e57d9e3a1ae56b7c34f2ef84b214f40fa7fd6589545be313975c560044970d891e2b988b067a3eee6808b6c2ba6f72b9c33ed0424ec192a39fc9508100ae9e5b7ba296c34a0bf6f526228bedf5593bfce74ba7dd1724123bd806c3dc8267abe78b79ddcb6ca00457f544c64d1390d9f9bbff15311a6cb099ad3316ddbd8de656d0b849d8205763f766b89c33350c5c4ad10b6b436b1ccb829c6d26f8393faa6892b4056bec91bfab5a9fd0460f03c65fbb3c0d6465d80a157ef6b19871291739dee93a3aa62694a5b711ee1df63454f91b7937e1fd48920c4c4d7de30625c229464d549c5bc21b6eedf00a3d247c84a24ddfaa04e992b0a7674f27538c7cbf95c50499b8e000bc934337c6f5c191b5c4e8f7d49d2281d3e71b558610198ed337b8057b989656ea8e6b421a91ed971f27be0e8a2698a20f7a68c19682db0bd94d8423d3274dabf4eefcb41445c0e8f46b9140e265f3f65198a29124b1dd0b5fa41e888f281a09313769a063acf3f9c2828119b445d651bf3125d425138202e98fbfacac69d2b9973e8e7524ffe8c1fcd13d3381dfdd85aec3d1ab6b7fe505009544193b04ce9a4a03d42bb7bbc86c79c295716033eb944620a8dd29acdf4c5a5ff5a92e028dbbaf876fd733a3d34fbe643bef6175750bff5d545e02a2b0696aef94aa6092a45a5d88737aae26d308ce8d5b7488dab11226c103e9f6ada5471b1864055ee22aa46a4426f17457e3f93ff75f59aa6bf10d5d0e2520ce42f7cf69f8123a612f2f2076fafdc90d7249c4b9badfee4520a1ce704966afc6b830a353b78bf292f740bcf59313ba028abbe8b0f25d35ba9834d76f63d25213f92cbecf865c957d97112de4d1b1aef248e69d1b2b1084fae69047d14798af6357c61cd8d1769bb5ac7c364be13fdb90e78a316f90e0a9036afb562adc811b6c73c748c698dcd8012540cd940d1fdf8e36a13c1026501d39d81418bba9032847b3c351bd66b18b644f0c3b26c28311a97c8b6721e5481ca6327862fe1f33cb67e561c35de532c7970de418753e3b1c7deca40669eab2eb8fd09eb223f52601191e4824f65c82a4b19db2e6234b730e185b74c906c14d899aa536e74c54377367a2bfd5d80e56a785cb0f28355a46c5716c0e8e15dbb81d28618b64b71d56275046b9204fde09ce7134eb231266f12824b748da591d28f64451a6446a86f040995a68e81f5f16f4053072e117d02e8897226db600571aa98841ba9bff77a65f0e972fedac1c8165315fef9e88bd68ef82d67bf79d20bf19c471a8b559291cfe42adcf0d970d2eae1c6bb1e1807cb604d9dfa5ea2018068b56fccdae0358f03c7512b4af9135c7e8fd1fffcb3237e08f5be948503028a9b351413bbfa810e7a68ec4e1057127e703ee150975cbc864f8875f777896d959dea61a356d6bd665e00f7cb84e614fccd7ed419158962fb0ffc59a24c91c2b09277663883abcd89f6bcbedde6eb94411bc2ffa62da684ba6298a36182b7b1fdd6abf5074ff3acfadac125bf27734cbc4cac6ac80d0e57c7099d0e1ac41a571bf5cd6097e7d041c2eb2b5399cf040dd1eeea437f6b9f6da0c06cac8b44a29b2626eaf22b515227ab9ef1c4c24cc4c0fa0a2dc7473a26559cdb331649f7dca14c3f6c387105f40ab2046b1ca02e9d62ea43a6dc7260f22155788dcd3bbd18b86b28bad9cd90af08086db608c6c8d8ee6499e52401e593bb6b3e3aa80e4dfe5ff3f9e5694ed7ac56071f2305106ef8a97aad2ae18248b3d33842f3c5acc78d3dff06c1efefa9512e99a97ff69cbc6180993d2f108ce8d6ba5e9d5f3dd85afffa4a8bebc6eb8b6438ae449a6de085c4a6a65f33d2336461f6edf1109adb30a354f6d1594de74a5f8dfb2add59597cb61bc65455393f58c4c2de67c73c75535eae010c50d08ce96f7534e40bf7c0270da0beb38006317967f13a9e5df386235260c6807e4b83f2aaa1b49de397dfc985c92621809dea701e0c863f4744b1a3961a5673eb65402a30a3b63fb1bf2440a189c58a45123efe537f4250a4b488c37abde479e58bec1dc9eb11bebee9a5e55987d6414c666e1c70c0d1751417acf27a9bac067eb8308df9c8a04be226ada95dc658c1acd5568a3636f66ccf9235bf7d77af7c62890886a897b4bbc8e53684be4258e070d8b99774287f2dba5956702c7ecbe0df564eb4fab12fff752b25e9c20ba3fcd577cc676b4bbdc818fa27bfb49087b811f0aef9ff01b3b7a01213a4f7f1f78ab40385fe4f7788e6efc58c4d19d48c66af9c0340482762d73d828dcd2ee73d3fca80ebf809125051c2f8fbf591d68053d21883d4c73119984a3ed6906710b90be192344910b7b319b8811644b88093d55d0dc340dd8b8e08b86423b23f24baac672927886e841470e9ef903016e952c9b8126acd1aba3bd1fc9728010675f829e585f0ea9cf9ed6681d097fb3fd33ed9fa63e47ed2dc9bdaac2ec0f7808943225539e9b3078e43ed815f69531b370078b50476e9557d1e62b898fbcf473237e397b378698d26d0aa7379d00e72dfaf0016d11a5eda255fa5784e26f419256a53ebc9b63efcfaab4e68a8531bde4c349cab187fda76d8d564702bd57f4738edc22459d2b6f7a89e3d6cb553596159b42ac8bd351c979ce93c107f24c275b42bd32793396f03fd8d07a545df6c8e7da5e8602f1ea28f7eabedeb3da0861872aa25bff1ac1c81d84012afd77800d48d26d1e39c221de9ded0285487004cb009f95f05142955930fc85009640fd7e02c3f0c0f0ca8d70507cf090d28c158d355be17861574cc6df96a4605171770e7a4d26b46d4ba3407f5d7cd2445a25007359e6877051054f1130a308043e0e18a2dc8d5746fbd2f182b8d190c705b5fe70e2851f7e22b9b0c2c41702aafc49f04ad427bd6b3a830766e81a1b191133cf4a770dc9c4404e398307a243da8d6aa55c6020edd42e92603e219e6818050937d36c5bc362b670830dfa5d278e47f9cba435f0243ab947f1b9065d2e87288885560f3f1dd29734a7a105ffd76540854fe713dc07e7e7d2526b0a6df5f0c89ccc84a24dfcec361494e36bd6f3d0e240ed6fa7ca5d6671c05e53e565f5aed70693f4e98c8783d0ea8b5f06bab55281f301fedae7a7e6efd882eeceada1f6c99f324e67f84356eec179e6e5509649fae2a48ae8db3ac87f55d7ed90d2604d878bf93ec3ed88c1e87a420372175edd264f0086a786dd761fdfc603276b2ed5862b9943af95f87dad4c9cbd2ef583d9afd247c78cd4551af3849942f9034ae7ae8a85349ef8865c9a5c9cb6991e308917cefb817a46a5f2123f602318860d161a26d06e93a252c5679537f253d17b87c41df2e2d839ce2efcd78765d179a74cdbc788e854dd560594e9ea8760de1fcac14461ddaa071f30d3854f29671b27951914205fc321e8da5734c657de0c59bcbcadd47788225f2c10b4e0d5e00d53bec80c6b9f2043cabce05622da5f2179fe18f54eb535671d8f30c7e7313b7c314a45601a0750a0e972c6b2351c1269300fa05f60a9d56db01640310494bacbd3d9c441c0116b050a5b021ef7f08c0ddb62387d4295832dcc5cbc77bf63010290cb2fb83e09eef518bd6b9c3770d39c259c04cd0b8df97d52f60fcb641b4339271ec484d7e5bc6b76e3e4168aad3f80e0e608143ea38805ff42d2ea8edf20aa3c29f67524899511fdd87c650ace03778760bf789a817127935f067ab68a6380bcb4af72d471db5a3c6d14757619bda37bb3759456cab20c841f14f376d72904518dd0eff1f4f0d2db17a77e6f7e3d6fbcc8e996f33c434dadfe2c5a4cde4ae267d8ccd41f5ab54ab8d5fc11439d74f3091d678ebe596c39b39f45052c2f29020129168367d9950ae9cdae8e225668458a1014d0b0249e3b25f3eb5fb31f2c88ec5b561e29fbeb1e5c6e14321a24a35438140eed0b70a44de1db57c4b5928b651a0c88c5830ba95ec25cf5e58c6dbadda2fbf7dfdaacd8734844cab2a2f4721b91f7de94bd41c114e4a45467518f78da15917c3dff42ef19d7f0ff96e3f767eafb55ab5ab77f4552150c7085f7ce612867a52732589276e2419085c46ac57da3bb316e322f04d9858334116ffd15289adbfe51cef98fe11bcbe2c96aba98a393ce532580563346cfaadd59a7ed0e4c3b6ca06bbfa9207820cf79ce3312432ebf5cad4b6c9183adfbcc3b16d419fcaca2b5550047a6d71c09ec4856851d2e7ad44e16b6116cef2e09b920cfe2ce7268179c75f8522a7a3c6d387b7ff5b6b885bbf15368977246d9505ea910bbbf092a555418798406eaef4c7db0b0595d94ab23ea1af487c4e8bedfe5dbdc819328820dead89160f6f67b48e3c79af209850aab70fabc14ec1f08f1e46db6609836380fb2af6f1b08058cccb65f0beafe4db88bbb46b1413987c9a31be1d9d9b1787b9c7bb8d7b37df03f46141446f263d846bd34053f6d091bfac0c3ece9ab64dd91db0d6c86e3c3fc5b49ab9ab60c8e9a37355645f112ae967c287cf22798b71d3601bc60d760a5d992cc566534146eb1a47147457867ec7fa9d868c19275731523a8d0272cadcd628269d17628ee646faee0aed54b242bd6c1aa95ac983dbaf6c414d5987a3b4267f3e5abe8890bcc21cdb51b04d156650acd31d1bb0aab5c47784f261732701681efc0722f4c2f9a76e04310cd637e807bfe6105304db037d8665bb875755b9d11085d897230baae5cbfab1dda43620de1411fd4f6aa91cf8db08a8d2e3a88b770abc0ed14e2c7287ca023a178a720bf404312e89e6025d1910caf5beca57e8d4f44d735e3d8c7f4f569f96687b5e6d0e0722ad9bd1ecef0fcdca59efced4292b9e86784fb498851565ac245ab64b27020700ab2776f98a49ef454f26b3d2fbbc4841ac3da8213a2e27dc5f0bd3563f0eeba398fc4d6a8ef479b5cccfe5d6c3640cb9de1ca2f917d3a3b13cbc461e28a515fc5705fe70e14fd9b46616fb525ab5cb5f51a7175b048c0ca29245f3a475820cc49ef05c38f1d26988a5141553ae433522015f13ec34d8ef91b82337a9ef370bcb534b63a326dc9f8c5faaddf5ead05750a507d219d93afc1cabf1a8ce4391aedc48d802e35dfe447e31e2a42706d349edc7471195c42ea4eac995d46bde1c51e8ac98e4471396af96be83f7ce0822f682ef333b763d20f2dcc7ea4ac64353e4594b7964d959de259ee6007786cae4befcb7964e0970489d90017eee2aea29711616498e56f1c2dcd79a0f3a0824c8252f40f40be8aeb25b53eb39984991ec5b98f1c30c0e6baaebf885e90ae24b0648cf7196b07d34be0912141e7191003f9ee9ef6100c36318df9a17617889216abb6e2dbd325c73a77c1619772dc2a08071211189d4f77370205333d6975572cf059f0723dcb9ddc81ee11ae14da3ba169fbfe788428c2809d7cac69cac84dae3d3b6a00e71ae3764546d5f98227baaae1a0aa3878dad060f86e62099a42c432f11fa2e747f237a33c3546d402602d09de8994a8367dcb78eea408575fe4ccf075222673ff6205a9fc978d450eedacff8476f91cc4ecfd7921c8bd2208bda85488a886c8426517faf5d62d6ba74c5efc4f3d492096f13073718967a2450e60723735f45c8efcdff754a4a58e64a24ae030cfa45fd5f097fff6bc9f5f0b633bcfd5c317d3506648dd35c062ae07c82fa70e354d99cf523e1e7f6f4dfc77384447406cec29f8cc29f7fe1920b7ebca85cf6c178aaa7bde346c3fd051600cc1bc66e7fc767c44348da8541af42fce49a927d38af2255e23011242173829a6480219e47100cf4cdee6894fc9fe6f097dbe059e4bf3cef8831912f089fd14745e20d44a1ae1d1544b5b7348a298bb9fe9420b23caf1a2d3cf91735580b43800006585ba186492b806092d10e89af565c0974c5ebb6b324b65a33f3bb046849a915efc2178f30512e0e2cbace8c629df8b8014e68b447642848e7b2374dbd50b04adcb406eb486802e981129f8ed8f571f2f1680492d3a9bf043faee5f5d98b16e41857693a09514edc48859f6a8352039e4006914967e4afbb0a55d8e197e75cc63a91a6dd59c5539035582b3cb9ff4a28c6b0290ed90908a634fffa8335420bd6027112595e504049ff997620e5402ded9df606968ca8f6a50b6abf111e4b0bc36f01561f28635ecb34507455b1a99b6bfd74229559f5ef1d907998373fb6d89e5db46b9d1d78819d89aa48b3232a49e2fd561723d9871a1aa671f939149f63c9bb4924248030e9e7c02210bfea15beae4c0c5a964aa359fbf94298941dc0a1447c44ad8fb27a1597bcc13ca1b2bb11fd390bc43b811bdccae971c52edcdd927910161c4562a7a4ed91a877864e56d56053e138bb516bf6405da0262fe3c4ac55a73b71791915e576a454058dd482ddb9b06856a813060242ced5c0a4a2efe093dc3f46d856c446c547801e8975d8aa24e3cbb49bb828364e3b21d3eacfbce6cc8b8752609b02837a97af654eae1779a8663df9386cc9c92187b99be2b5b7d5d2b0563d5de372a3ed105891bbc3be9cde514d7f25bbfc833e05c0fbc1feec5ed6a0bd14c9f3fddedc57ad4963ab1ae4e68df75fa114ec4a2d8a13c681693304dbd54fd4dcf9466e2f4d795309a961c271df3a5695e05d9a642c165851442645765716cb8d0cc5c2996110f8c481fa2d0c120fb4c27020bf9e32a74d403f55f2543707ac33561f51d82a8d92d4b46ce5fe61df79cb012d0e38e50f794af048d011c6234dea788b1662e64a0c67f34bb9c5db274d7f9e91e86e946516ddb71677ee685d7f85a8db4d0f5dad7983d438f7a64919085b656af05ebef9560f7402ce1ab16cf06165e5c7a5608fb8c2122cdaab978d08f1622fb81e3a8df20fd41d89c66c93df5091d10efa7c5142f606ee18afc1135d9c772920f71d335f3a7b334d70ca75e2928f3553ad6a78eaf4e8739ad6ab9990de02a2af545d771116d4c1822ee97320ce192bcf97a606c9f38234b95722ab910a83c8018b75ded8bf6459329797dd2f0e5a4101ca84b4fb5b72c6b2a4a2dc97b33af47203d97c1b79572754d463ca396687bdb19cb564d8e1300f3571bbbdadfb014098c16e34a95bf1380402dd52dd78cb8629a7d0ea2cd62a119d725acf754154da7e3a287dc09d9869d1a7461bfcf95baf5d9147e9b55dc6cfda045e5348ebaf7cde11effe06d65aafc0fae58f722e3eb5eab08c88f64014ffac8a756e0ab31a77bb654dce69d2df61d1e057734280ced382eb75ccd6a779af044dcce32bc0bca87fe8e8ea54201e1483e19fdb00596dd94995d5c67b9b8da681f6eeceaa9067d8028c9d7636a275160fc0ee6e57baca26ac0692546c2fceb13594f0863b5bde0997a7021759c34e3575e7435deee560d77a5c4c237e2f98345cb365541b0e6de4f889e17a3bab87dcd0eedb89dbd0a3911fb5c13ac136d6040d2eef4b3b1d7591a9fc36133a87afd9c9fcb3723e6c73c138e2083ac42b5ab4ad107492feb1536f00bd77cdd2479ca0477ae48888ddaebbaef6c2b14f6311c119f549a79f9dedd3581bbb1a8d49c1bda5ce1d996995352dbfe1acf9ad6b4504a42a9616de93873830e69c21cc705dd660b78a1ff42579e1d4837c51bac9253eea9a5e5a57568af99232e494d600c41f1612a7f1e10e04e4d82063af366b48db78f6325c244f8987bc96cda6a7099ca5f01b9f55a1cb20422bad81f37413a50058487108a8a6646a4914c2728ccf640bfddd3d00e8e846bc152640f4969ece210f4a59f9881000e46e7169505f7068e253397ec0b02669e7656988296ca7328d80ddc30c0820101f14b5aa524878098c3b455ddab536dfeb0df1e19b904b59f6345a7968e4815fad76dfbf30d252abf7aadaf4e03fe4ceae67c7998d7a31079443bdd5c69aa7294e303295e1cec40ab8dd8084a0c64357ddfacb913bfa8df870e18989134aa45bd897c20c86098f230ca4eaad8df0a9bb1b52b9518ac40dd95ba8eb1e8deefaf469146ad6cf56cfe4404020a33bda670955e3e725a34a88b18f12b08b1ba6d51f28e5b87e8e5f9d70812f3a25bb90c38d9df44c50b80258c32c2b4ec6ee8875c1d3b66a2efc842e8126f6a8dd2b2f7865d90e3faa9e0b23bb86948dc634b56b522e52c57e766cc2234de883375fdc0ef761d5780d122d343b42b82b142334b3248576fdd154f02851df79d41863081b4d996f1c9508a2470ebaaf37ae962e07d00ffa8ae10942c422d4b24d0a179e16343effa7d0b148edfa2112e56a70fd98c3f30238e08e8c714cdb2da8665ba39b3aaa5e0c4c6d1c208b29e1943a3828b8e3c1842b234c1c4265bcd8a1483f69f564dcaed5513caa3f63596552ba8579cd577e93cd69fc5564874f36dc23ed1f29253aea73ed7eb6c1ac28e212f65cbd6070e1eb480eb614c3ac30860013d1ab183908cd387a5321328bd1596eb706e4622d04821730151629ad887f1f2bfbad5021f065ad8d42f536d6d0054905c162947bdbc1ce68cd2840b3cac084a10f4b53769b8c95e97693a3bac7a287663136265bed90135e7958de354dc8df08e9ecc58e4b11fecc7edd2e09a672accc4415e245cd1d800d3f8cb984f2124a961954bfac81fc7aa3bc2dcc102b54b432642850c0635c8a739cc83489d68cba35743c8d542990d230a4ea4415126ec409bc4c4848b01784299bd457b2f429cc7342ceb8a58ec7cc409aab3198e12152e6f598abd5ff5a021ae77fdbf8978b535f3f053b689df8cb79f6445d030cf669f496cea57005de94c87c7ec60f4c06ce8d902c8dc7143ae71d74a33575db7a1e6915daaaee8426ef1967b33203f1e78499790288e23ab43c097131455cd88c535516a9d2e1c17005bedc1c7dc1cf73839f4b52d2f22faa32502d0caf017f0204a514790fabbfe9d61d31e80c609295854d7bc63c4c4786bd8a442e3c125fffc35608ea49e0004dfe96724592e3854a43065f4a778c2e2108802605ae329e6f25aa358a49ab86a0a69ea24ddf81134c0fa1b8ae8c77edd39d5854cdb2c10c9e934a587514b2cea6fb0dfc8b2941193992cf7c407b6cb5eb54ebad6cc3efc111c536f66a68141b82413bef2899489b3bed47664e077b0f494bd0f0e025a7e1408bf4a28d545409676fd7776d1888b5d9e3db492927c2e7b3cd63cc06a715419f38e95c37101408dbb24679c9181795149c763d776b518f105b2f3cbe90937ce1d33592433cfd40b35170b2ee34550d7c5bebe1933bf56f25043269f61154b76010212f453f939140a7df8ccd9dac2f0b3e8acba4abb5908a9d525c9a1c1c4b6cf2779572274da1793d673a26d501c375926731349b087d2c280b90f10c4fa8fac7850f07ebc73b3a910ee28adffab707d1c1f93fb7ef71f7de0f81c01eac78be3ff54e58620f4ccfb9e7f1d66671ce02dd5304e5a1dd9ea508aec916bb8e2d11fbdf473c4c24c86ce0ba4d81be25a922ea62f6782bc33b4b6acc7d5b5edba845eb071f842932b5115428c7f1742767bdb539dff6dd18f7a5ba0ea1cc1c2b442014ee8dc0456c67d283d6890b05b042e032065101addc8a82e5cddaadbbc7b4f33589cede301db15210ce1902b44862acdd77f5ec92c2e04d04c8f30b3fd34b307258c562df8109f39d9900f5d8e462b35f407c3046f54d01ac16e924c962bdef9c0dab63ad43240030444a4039bc2a5229ed35d3426af864a8c5a001c69dc1ab7376bbfc4f1c0f3deebe27e12ca5f5c844de453a6a9333e29629a875ed67f34b72648cc9707819a2aa961546d173a0feb07127f81d0f5630531ee53b33ee3dd09457451c5714e08be1cf2d71a8b2000a40a50ecd43c6bec1cf00006a69a8765f9f410438788ce100299af2440ab963006ef7f85688dcb68549670d98536aa5b2c154e8278ecf6960adb9e44415012192974e825a33fa6092c66130516bcd7f802386edb05367718bfaf63a6746dda367e442128deb09569facb073d28509c6b2909d08ddab4ec63ae80d0da1bef6c2b59124e094c77d3093aa4039e9398d4575989a84800c160a7f6e457258c6b81e8cfefe6f3614d3a217acd9f3422a5b98d15a1d3b708a11a841cd443fca7cb597cacfb35904d511bf091eab195e99f021db880016ed240c82df9a52d113004c57537d76fb096f0254bd59e12de32599bb76b09491995319e5aa6ef4da5518b156f8b3f63267c31f29f15d88510109780ba10dd7a45801d352cd323aaac792ef5c54457af5dcbc3e8b9186cfa0a7a12067790b443e90c356981b805d15de66df1d9f03fa477a0852530ec0670672d4ae110c2a55885313feaa1e09db3a8a71d819ce87a3b27ad654fde86e9a76aa30796d74412bdafe8dd3d84ee0e0e4893faa2d7190d2c4e31c6b8b555b50f0788d10bcfa3b86fe635b9f5b21c9fa92139e89dfb2bb7f7cac0a1e827469cbaa43ffb24cc6efeed14fdbf84c31ca560693e34d83a6afb3ad0f3443cad9d6739173d91895f9a50798d1b30730301d9f543edc8cfe33805223aeae615343e973f3720f51d6fdb1df9ce649e5c449b312ca182985843ef65332ef42992747fb1ff36937f3e6a12b02623dc3bdf154aa770d19a16b490bde3a452bb0bef7c96341b35aee5936a41e556d4fc1d292a72d46352be585abc0df1c8a5452e0b539654547f9bb7576584f04f7722973886ef6162dba3d0a68065bf3df87a568f4f8de336f082658f7f1c2325517cf82129be079dd3bffa5c5e333a7860d0479c78f2ad15e884b44d16f99c4aa01a6d8ee3c6b72a64ef456e7ccf7add7579276126fdb20a1a746ecc232ddab2b119bd3f64370f5f1fab2413cf2553b71f009e355fd3bc3cae913729056b4c3275ec58fb6388d78b09525cc4ebb880e2a4edb2961af9d27b0c20314352c942108438ce8cce7f54d39b507de6409b9a7719eb6657bcefd77dc27979a53b66a5cdcd39664e3f8d8f394845e8212f07a57d6f451a9f997ac51d1a3f9d82d5b23fb7520f2e9c9ce626b91acca04d80de49bc9b2b0192c9b12ab5a977fd309b4ed451c685c65113cd22503aab42cf93d0ab3c156e949315e52e71c0c8af58f75e54d74d8238b0b86d0500f88e9247a4a1d42d5f93b2a735612a664a46abb7f773dba73470bacfdf4e18b03f85cd96403073797c8c11a3fc6207fa39f4daa476555612013c9be299e55d7b735cb74df73d7f6be42812ab9e05efd0b1f6d9e3796c95e21a6986708ed9d86140b1abec75d4367e6aa93a570b59146cdba43de3f5f8046f82307137731fb35cf3433cb8cb4c4e55fe401c0eef4d7a7bb188a820ac5d87343685fd2823385c8b1a08292e864fa6c65b8bee27b105f0842fcce346885d9653292ba1e7364baf757cb3e7e09676f629a7ee25aeb8a390ad346e6c091ee16f2f9feeff2d666d0cc7814147768db758ff0a20f3d10332f1759230250d1b673f409ac3066e4cf5c6c6ac4989f32a9f5ba0003504ab4c5a7de3213a9f9ad321d09b8f6f15ca87fd5b1935e8b25050098682d34b481bc7e977445a0e7b217fd4d9f99299e11ec7f7b48c0c22516d951c8f290da397d5762fd58989356c127bea59edd07696334f340aa02ff8beff9410d9a22c672d8591fcb8248cf7d55fce82dc6705932bf6096a04848619b23f34e60b7b27afd816ebe8b2b2b970499c64ea6b43ef03ed785535830a7ee8019fa3e95563dfd3a91ea9d424eb7e609ccf1ce622558dff596a8104f70e74a90dc7f30f1db778928ab2006df6112040c9c4ce8feca63c1f556a2cdbf76ad46c34121d7894f66b4d31b08e1626101593c834b388b8c0c63706a79f2419cf3d83f77bdbf1299e7b9bb6a6c16d8904514793ecd745e03c6234bc7a718502df5dd2a99decf008541a89b881cde93ac8e85df973bc5d48355b1b0aabd8fbe6e093291741bc573584bf2109cdc5bbf5f93c23919134ba1b711f5d6d3087bfa814693f2ea0f052476ebb035f89d77d18b57ba3c51cf2b61bdf3285179f99e5e130a45134c7fe5b06f0a0ca96be56d33d6631dd1c3d0d1f4d91a4be35a50e5f36a8a53fd3ae33a567d0a114101d66a7d56533844e0ecebc156e096d05a78b5b5f913e87fa188f5fd559735d9c4b6314340af7376fc05c5ca14882320ddff4e2c505efbcad0edcc01479abfc3a3bc511387776d52b9c990064e85cbc109e0d8f66553b7a7cc0d51c5a2f7c41251fc2558f986c6b313a2876c2044a8a6c4c4646c9feeb4b77d4d30697e8096153dc584e4c6acbfab9b8e17415f4643e5bc87070c767fe350054aa748d288969e2f82dadc9182a67819b496aa243da79e7dc2cffcd801663cb1885c1fdbf67c87f54aa166dd3b54f9f6cdd040ca1d3ff876c688af0e975522aae47c2f950d247d3d724235985648f9a998223e05d614fbb2ee80787b8c2be8c72dfc15506945b125e35aa3f5dce9a4945feb7f6d95576ccb8e168773e8ca0ca5bc0f4eeaff18031b0670d35debe68dced084521983bbc0068bb89a597430c27980e428c6010732ba51b440252a64c29d971d7422bcbcacd51cd96b2d767d1a77a9c07b6a65cd28f437e67fcb7f3a4432dad8e5165c4969e8359f32cb79fdb50c2a0ff7d8dbfdf27ed0d854dbbf9720f6b3406dd4ed93dd0a4b839c075ebcec4484774f93799378bb153936462b64e720753fcae11c45deb9518fc7f7d9c70d13f3e6f9c6cef81bb322b0386a238b33ba69b73dd896e688807451f09f614cd3494b722c6b1904ac0f1fea6950e72acae3d3e2c50185316946a75319133f34bfc0b8acfa77f5e2339d6c0fc94e51609246ac5f5efb7db53a7884f82eb2874095cdaf2c870f04df6599b06985a3b62e1f4008534791496af7844079f5de511923ea85ecf744aa92ecbfb8235fe99ab84079245642ac42adf62cb026d79f5898bf4dadcc96284e4fe26a8c432c1dec231f3fbfc9b7c13bc19862337e312f0b6a395832ab9947cd908a8a356d269089df54317c799edb8382a8b72e3aa64f20920ddd81e5c45d5bf02b59a89b0411c2a41ab50d3dc936296e793de39afe174d556af7d9edfb66728dd511a977f82b774e51083cf4586b4228f47b83e10fd50e3feaa75e3e22cbc82ce749bf7b3f3ecc0155035680339098a3a147f8064351b45e7dad6ecffc7962007e8c98f6fd13ec26ca9fce6014ecab03da2a25958ea19e04fa3881e1ac1f999eba1f7a1a4fef4db6d01ddcbd98131467e7653c1b7be02b71042d5ef2a90161128433bae835f671fb5762c70cf3c8f67939838ec1add8bf502ae63bf7cb870d7a24ecfeacbc437df040ecfca0a5490fe30294080459b05b8326ff5206ec22d67638e3232170adb2f823a484c202c16689c8460680aa90d834ef5876a25f06bddeea48a01cea4c6a97a3cd33f52d16e6125b796c02f8ace894e4624f202bd13a556cea0ce0b40dadb484d4fe46d67e26b465e9fbcad4961a463adc7c48a7b6b7a9df7d703e7c72b64b78db1421862bd443c66762b6d89b4d205401d3a1b7a427b8579d0cb6961336473914cc6b114ed304910f571917acd3ded7c7f9e82696ca55d5dfa519245425875fba9ef2a516874c6497a7a02fdb384c7e4798ff851c9842fdad5d9debc1b8a2eff6030f5ed7b6185e72fc8435f19622f318e5d2592154bb0bf4805ee6659e3288ef4fd9e1dbe9b2d68ff348cf0fe2d4128a8a6f0d2a27ad3ba878552baef0edb34f7183e4cdfc4cd45ea172a91e501b99d3a738bdf49a24bd811a986ba4c6a2891865c3f10e6bf439a4051d1dba578d3c2f2ba02dfdc24cc1c657da75edc0782d1fb3f3b1b1ca47db765983421b01c1d07a1d6082a15bcca1fe23cef8cb732fdc6b167a8d065699033c64784950f7e23ae8e8e5e5664677455a4fd0f748def53f6af9b28b17f54a40f2a5d5954b1c44e3f3756f2ef54f76bc96805e9817926fee1ea9037005fb469d2c98b85d88811703fee781d5cb70f110a4db7a9c68712ad33b3c97f1188e22141f131b76ef0b94ddb83bf06ccdec1cdc442ec31a3f31e30d57b241dae83994aefb1d7c14c367c3336e9915fb523e5985a38a0dd681da7a0f1a2d318aa762a32f3bd6a2747a8f8152902b75198da9004e76f4dc4e42b66892fd65926ba027a5fff8b5a4fb90abfdbd02b605ed8dc0fc9f28084998d71c1be466a2cc2b00f1206fd68e725413793731d610b20c809842aaac354e3dfbaa4a86e7ba71f4f5add487c9a8f729e997515d01559cefea9274959ac7ff9ac7a48433746a41d126422ab67ddf802b123c356e44b31d16185268a1e1e901c7bdd7e0442e7a9965ee14c146867d455d9391df83cb0daca0ee849925e3376a28a3ca821c0907796869503a241eea07db939318621a79e6a2cab91cd594f901eaa8a7e16d4b30a25971edbbb5ef34148c37a5db7e240af179ff1258a04765b8152356f9f18f5e09d6b1f5739483ac226702265d0a3ab23a8587a7eb75b39c82f8a13b8ab927e94ac4c1735d26132d02572ca1f9a39497f57d82a6225649721430150775ff90fe83527fe045cb71580fff0a6750432187579a3b31a9c7323031cde7db1e73ce9a9e76cbb0916887d33221a6223ff90afdf3e0bf51670453466a1c62bd360bd4dd64c88d42070b17a505fb80c8cc67c4cd76cad1a7f41fe4fc0166462023da7c392fe0b9112ef17c583aaf48efb58edeb85fee510b93cefbcb17188d8c29f18e756a95ad62badb4612346d28ad95ccc5fab094f2a8762d1fa234db538423902950fc30c68b725b85a8f211f72ba6ab4b95b6df5d55535c51ea299463488ddc4980a4e84c2b53fa16421af03c77a4ddb685243a4658f2b0c4fb17badf871ab2ba80f89130fdd0a820854a9286f2a2221106fbeb3910e126d47356c5570de083c1dc997d3152b0e4e7fd82841c4bb43af4bad100f9ac5ad3eb355c692fa581ab9fbb86f782ef668657428b3de4bdd0966f31fe84afdc3f3ba6dba6bb200975b4f334bef0abe57e3be6727aac7b679715062af8fd76095a7ecbffa6e3c9eb927ff3d803f8c8a86910234bbfdc62ae2353c55d1c3e487f0e9cb52","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7743c2bef3e0e7cf5ce7f284f47f8cca2839ce4c8bfa7277cb70ee7fe0eaba9407dd66dcd8550a1f1c2941a103c796f9ff58116f7e73a8dbddb6909ed790c882f13e033ad57df5031ab59b88161889bd6110ee0c067663accb90a15f70e4d51d495e3a4c7e5ef89b71af3c9665f315c44462b78c3987948940671131ba30b90a0836bda6c9877735f003953fba02553f229dcb1c5c3752086e7393737d7deaec4a44e9b2dab715c582dec99afcf014777e1379c5a0b07d4800612057c23ddbad635b94bc8f281c6f0d566213b15f6804dacbc2e71d8d759a6efe43d2451d306c51965524df36a010c9cc2e5260d1935e8800869c224ece8bf74b8298f24253355e6044b9f88f99fb89ac7e6d5824bb86eadb286d83936d7da948e67ca44d351e559640fe92d84a7e73a6fa1cc9866af707e3d550a0700dfbc000febfbbf90c8ef07ebab177e35101f69baa3a2575c5d34f6882f5bc901cff8e90b2bb89a3fb15e2e945c08f9cff61461f2e673a1ff24e6b7063b5074fa95c5a93ce8cf46d53f11b2331cdadc50d34d34a8b92f51f6cb0b4a04b13b5adba6fc892fd96f1529c04459ee61a324dde6e5b346b4614a19e8476fdcb16b6ad1f63575332854c05a981835603b25275b6667e1faa8959f94fc10a0e4a313acb4f2612e8d697fbe45bdd5868259572ab511fc70b21fadad6dbc6289f8b0903f480c9351232216f7197c68a3b7ebfe32aa5baf3d019929738fb7aad09b529ceec7aaf0ab38fddf98a52adc9cb7f1b96644fbdba3b26d615591bbf84d63231aeab4900d723ed934aeb70855c3a5286aa2f21cf12b9d43b5918340d86c4fddc670e34bba716177d1683b38f18af1a26763fcee68a466f13ded8ae0175d7bea74a004b49dab5a3e8a3714b3b1a364258f46e7946efcd99f0e023ef4d50f05df0e1a8290f50d33600d49dc0cdd90a6dbbfcb87d8043a3a99a1824edc54e2b89292858d49590ee6703aeeefb4898536a3a4bb1dda7d41fad222eb56a23737975b9fc5c7a86fe69e1847e88c65862b519d9e64298672d0df88e8052cc73c4f98de6277d02a3c158589ccd0d7fd6b1954affacff6faa115dcfd3e96d74586216a90d115df683846bb3aed9e41ee9dc29d967c81df953f86424dfd27c3d0153b9ab48bd281952f17a41a871e09b4ca9181074ed95ecede5bfa3b15f53e1984c55e9f0144467893fe1e2e2570211eefb7bac4118b31bdfec2a5454cfc8a5aaea977205f52dbfe4dc4a1b5df12a838fc5846d2179c26c62081e11ec62cb488507f3d03c1ea7a1a53e7350246f02a4ebc5e4bf2d1e2016612b2b534cdc3544b5ddda0680e0452b1d13322881c44b8f3adbc959690576ed2f9015d75d11ae5f0b4d0305148c4da8c4df7d995019153b298670777a9151771c56054c29e0dc26efb1238e6fd3983e09340affd640a2208939d50fdec80db2d5f1d9edc16a827f6bcb0386fe484597fb0e7cdf7e761183afe70dba27b823055e6b210f4299279afbcf89892c165af7a622046dc5ba4b2eae646641891d45c5ebc2ed302aabdc16f53521a5621330132c85adb39872f862e4832542e68c3b6f856dd85a670aa1314c078674cba1c082ab7e2937bb94eb215e1138ae28761798f0caba2dce69430eba0aa29381e0967f8f491010514b6b85b7ace73fe40d9dd259911f45cf81d9210ec4849bcbd36420aaa8edde44a08a54ec7041763af33ebe3f65711a8a64e7264038df35b5a18274a5d9c8df9ffbb34bd86af722d4c6499e090e7348fbe1727b92d2e8daa67c4d5a0cf573402f6fd7465fe195378fd61fac9c2c7fc2e2bf96af223a0a4430282e9783c0864e370bb0823cd1daa67d1884cd374d05981cc8ee0e448973954a7ede8a00d223d7a083a522d26b5ffb7e4c1a7b3f8d5080f7511285371d3a2f01872576e978c4990aadaaebf32be7a849f07b026019050f963ee2848e298f1c0b88ba0a89eaa57106a3da6c5102ade50e9fad8a6538a93c99e00854513a91ffad38c5d0b731a09d06e2d4e3157a220ba7df99c24e73eb6e27e668c115d438f341760bb79af95a9d69484710f5e5399b6f82e7125c7520045c019f9112fa153728032f3b8da007ab26009c4d542f98a67a72a78a8d19dcff91d49c1ec1b9ca40a73030d9f22681ff978603cecdf029a889cff6f7b8095f85e9bf078cdb9a4da4447160dfbb819f3a5e3b5dd8827817de3bc122e78859344626049002549d546d9ba339a2efb5afe640b63ca8b9a5b756248c2da0b0791569e02a479cbd5e26fc4341cd3717e73ecd4d87742dafd8305922e1735cda4516c279137b7bf038ffdbbbe092eea2dc5c3000e649e8bcaba9f3f576b6644c01d198e817056a5a1f684403313cd26ab384adc3773b58b50d151f8cc3aa0d782bc1450d203053af9e7c39d3f9cdbf122776c1eff665144e7b0faeff3302ac8049bf0bdabd3013f5fdf7ba792c5d6301e94c02703c35f411960f4b4ce60395929a548f84f80e85ce295027cde873390d6f4dc9be721476aeb7dd1798f3168d7a776fd28119a10b92629c73e5b2d48420611553bf3c89c85c2d855640a5ed89e414552d5050ef0beb7939d3a4ea25240819f61dc30bd832b726cde54d1686e4f50223bcebbcaccc0c387b25385a5acca39fe7c3c7a95cd9e7d39fa95ff3ad07ade5a12f71a4317630dee83a9d0a2f400c0bfee9925ec695f2147891744063be9e6977a10e40195ec2d7d77553a4bfc064aa42c44ff924ecd0197368efabd5b8620c1932dd0cd59ca42eb92d3e76ea5b96d649f56abf737c40fc7295be3b0adcd034afc026ab07a1ecf9366e65e4bc9747d7e6a3855d453dd9a821290abb746019aba36df78051898aca7f57a020e488900cc65f4dd8231e0e2c0875953913111393f359a0a9a06217af25eae14e2bedabdef33f413473e05f262071a87222c08e6b1f83a7328a17d8ff8394a06076fa0f1d72f4cebe2e34718592a48cbe1b3f2557c14d416ffa5c2b306343a378d57b65edb01a3a304c59d804856b3845de320664ff62bef95cdd6f46635e9a5ed185b70c5d692aba2062035da97a72ee0b8299167b5edc472b77a88404e9de90108778d863966857c23990a0babf9bb6397da0efb9c21da8520a894bb8163bbde4d72b0b736634caae926dbd7f3fd6fc7c05c62471a45c5a45331cb871ba2846e55a4f3c7e350f0124a5bac0016ec7b05e20ec3693034916962db632985433093f26a65868bd5f1e5790adf055dc87110eb11d907316a0b73bedbc2a8549df678915b10497f55044f2d23f2ee31bb539a263fdb4cc28354a894bc07e1c1a1efda3da226834ff8b8bf52550e058125b22fc696de64d3bf68ff7ea3a119db0ff9963d524089298e5f60d0003202592d722057d7dae3ce72224aff9fecaccd3d9810f4e0a4fe9849f136e3eafebd7b7e6462b8b1151c96f2cc7d73d13d06225a031bc2b5361d3b11830d8e7dca7ed3b92ff93d2c911c225228b50310884391f78bd60c6981b46adc52b8bbbfb288ca0006bcfffb548cbd4ce22531fce5cf588ab46153b35a9f12f1d854284301e1e990caaf1258bd14527f5064582f018e3bfc94395f28f7279301d367835037503b32429f457667555a182444ead21581747dfa0bea0a15a85b17c3824524a4a0dc038872b2b5fd79e0333eab1b67c6e1c61a9e7715b14c53ed8033de385fbf682acf08cbad005eda65b3b004ea9149202abbcf050e9fe67b2406e4370b444dad504864114849b04e29ad1c879f02e4932d6d7ce55187e729ebdda1231db5deadd779749afba2a5054974ee9192b87ea24358c72c6314bb28edec5f469655bac8bbef0d0e900dcf48b1779a00de0db643779fa65f25ef19e37c01e21df461afd6395288afe71c88d98ec36d170b230ef784949a71e1bf149fd2f156776844f0646f39264722b566e223747f13e7fef14cfbbdda73db1cfba3a4cef7944ea6d9c430f26f94bce5fd1d046b3fcd0c7d6cb22d4f6b8402a7c12e3b75356ddab718d2d224a16521c1ee519b35253c96caaef501ebd6268f2a3ae725a371bb6c4f0135e8e93938b1aa732a5a4162962e4b1d847dd863243298e59d0a9f76db33b09dd56b90beff3b8ece140fc5e2302d3cc00d3aa2b28a7c9cfc78af212d689e93a30c78e9709b82d8c8eaa30a98326fa7a11ab9890f39e20d6df5953d8b96628a219521081db55348b40282d56c1b734d77638aa581b127df42638655d0aa0a573a43382cf76eb7b13014c1bb0378867e7f93240a8dc606511c6b4fc02247a77b1d3120f4d4dfdb7bbbf87d2a064c0546fbcff39d967ab3d4c10e7d77fa0d817c9773193dff7014889e1b3beade6c5450ea3e32e99fc16c165ce7c50f96ce2c6ba3c1419241247fbe2a7aae99c993ee3dd3e9e645eeecc8d14885589faddfb5f3ce5d1ab7b8f2a1841d25cba5d425749f1399f7fa8d7b31b03b7000c4475b87f53b59f929f4847ac00a686b309be704107a3a0e45c903c59f4b91697097c2352db3bfdf9f2ef7cc15c85a5aa220ba1e47a1c6c6680d9e4b0179263629cdd331be6628b67e4a07da615e21d6f64ad8d011ddd6fb888632675232454b39cd7bd4b15ce73514eb23a779aca3d3ae15e834b8bd5866bd1afe9cac6a95194d27b5f56bc4b41a835ec167cd5acf7086e187cdefa3f4ec34fb12b39dd0b8af8d69f181c3a91f5f505eb07c12d5678e9474d0fe95a408ba5bf1a575afe0fe9bc44560ae94c039a5cea38a4495977cd935f85e4bf3a3ea1f7f33f1a4f55ecffe7a6fcfca569d1368cb354fec4f1e2d5fb0d025092f646e7a14b55d1256933462e3c6b0cdaa8d28eec295d2b2422a14e8b5dc87d0fa1fe6d87a8d4290170205c40d4c3bf6bcc8001303d7e679e92fe5443ac20d203a448f8e1b3fed71554d5de7ea5c45da3fc571ad30155392411f62398d56d233b188738147f714ccf9790548684e280ad4ec840b66e6e1f58396b2c00bb3b75463a19346ee5e0910552d45544601570664a113f363704e0fea66be18b3546e8ca1d5ee56c5e0a7fdedce148364b4f24fbfdd671be15b671e1269cadd00d55f90119876c6cd475fa4c27c5659786f9664042291a576c5dc3786e6be1b2c44cdd4ba069002ea5d657593c9bf6e941b196ed3f762a0c0fb1283129054e3f7d02a60bb83ba84c4eceffbed053ef74607a7a1825a8ded4c8266a86d1379def8dea602df9388b9bab22a5350f203f1be6c6a7d6cb2fe94e9b905ba3aa90172e65abb497f2691ef1856bcf55b9452eac19c81275379e224cf14f2109b8a288f7ec8ef56dc3e7bef37cfcbdd21eba60d0b5a7b001bdd3b0933875cca0ee49295e8beea344305b0a32357a2f95d49f502fd827f35b170d411d0b421e295d5f59f74e1d703c11bc97b8c1b4fbcc0b13f45777930f3328756f6de139c8a8d963621f8e72964e175deb940e15df8934da0752ee1ede0c63c97ba6a5d340cf63946b800a8b07102780d740855bb580a6872c1cf1b7bedf2692b648ba31074a90e14843726cf62dfd25d4285e137a34f0f779a94d439c9a190769d310a5f656c8b5da85886b3c5526f07ad41364afba219899db6e2a706b8f77283ca367e15e6cdcb5b5d4338aa7e6d1aea19636fd29d5527fbab075bd46d84804b4dd9b156349ef67dfedbc21032368f6455ad38dd40b70fec3b13596435ad52765a534a927b3fd92706d51ac9101d3a1eaa0c4859e49ec70f97413a91083e0dd05b2eda34c6eef6d4e93ae3eb0cdc9732671b4976622e865e565e37172aec7ae2da8fad6b3d66ac15c4043d7b2c5a5e34e4c14500d2f62c48078f36417e74c91eb2939463bb103346af0072ebc60cd19cc344ad840d9b0ffbbf9e21206a7e48082346ac838f12dc565bc3e47545970689f6a3f98d87cb5679b0022e4bba8f1ec2bae293d84392ecc404f21a39227cd0278fb2e3503a23712f86a78b2efeb6c3beaaac56b82c5d96686e67ade226205deec34b8afdab2b4de905c636300922ae641122033249cbeaf0bb0060a6f98c0a0a6e87eb8ae329468bf61b1fb54dad4143125ba75fda78d640a337c9da3424fa2b30d2a9b5f789589814f42fd5693198e17fde6fd08c480bef021d282c3e1673389556cb2d8206a6917667f9f410083df50fdcb4b3a4553987b888aba93a91a2ad1c84b9a7afc1943ed38a350c7c67eab0cab57300f00506181665e5432255995245cc17b3e19fe57ac0277508c95be695dd877d09e4f4fc3c54068f5d3f96942c3272873bc7635a594eeaf4d08b401ab2bc3940ef97e436dd1ac4b7c99867671cd82b5104772668bcddc4eaa010af21e51e2a6e5c471b8fd8107fdbf404cca26118273eb52273afdbb1d1976c2b0515e80860e4c8104e95ad7aae3be30c6ca7bbb5f3ee75f93b4feca2b9e63090e739f18aa03c878f339488ec34c62495534700ecdd8c5e86f37823c6049a8a24f3564cd1e1a949d5924b7dcd561bfcb8783c35c3bccb0ca1b3ebf21c9a77c7150c9e1e489d9d68bd48f112094ed933cc587cc4a7291f5e41736869ada1f019b768599eb480b0bf7049cfba5f8c000f364d360397eab086655c992098286adfdf7b933f93200c49a517156db01b261de15829aa818351f9cf115510abeab6431aeb69bf264c0757e4e045f6b36ee8f71cd80419aeae8e7a84e559c9d60ad01afaefc726dcb66bfe70a19f0387d76611c29bae5d36f270592231d55579c7cb884fbd42ab85126717ef142b1de6decf2a4389cc8ff652f14ee9b3f28e0307d559a1e49c85b65e95033dc6e47d72aa21eaa00728752d1d557454a5b18cc8219d4d1e00cfa658e77a7e69fa580a12f8e8ddf6e4399328cfe9d5b43ccdbd5eb61fad3ca9c3c776f9725a43efbca16c12c15398d34c6da66501a4275c25b01ec343dfa12ae531c3ef044754e4cf87320deb4e4aa978abb3929e75a6bc3d4aeada25984c8922f307cd745c8ed7009defa2d6148d2f814d0d0172443d1d2e5e3d52064b7633fc7b8f532bfa5628931d2042275c977d565c88065c1ad1f96c1cdb62cfaf3aca7972fe1cdc980304aa86fb8699c71c62e16647cf4a0ddc58c921afe8ac58a5a2b4486762241cfaa528f0b8141bd58518eb8aa12a4e3306d332e52da41ee206dc170fcf2c09262a00f103699c791cd1dfa81fafa8899b20f40a2d30a59b5e362e7493a557769656af193ba85b0d231f989a3aac73f80fa1db70480a3ca051982a48101bb600588e419a2fd23af16610b91d57fa03b305d4992b490030c9b8874ff964f86d714b259211a5c026c0e2c3c2429fa65adf5e5b7698fe6fe49172738b8be0eae9ddefc67c28cc2b1b8a253b5a3988157748c66d9e0d4977d0171e85fb8cbefdc43dd97e7775a7df9235de4a63720aaf3fbae6e0c7a409782595274ecae5680e486019759858010a4ef724ec5791342780f2211a0c105e0c8888299a1090aca306955f8c3f1c67ad696590807097952b97dcf3647daecbdd3666b15014bed4451ee66d353d090442ac4d1e71d38fcce1c588b9a2342f1de2018ff114c617d1568728b10b4484b5ab43efb941539c066d5e5137983dbdb2a0d5a7df14e7e7bd819eacf223878bcbdc0551fba530628d06a4f0f85c09da6387f62f1c95f7c58fef4ccc2bba85ddd2cfba3cb755bf073440a8ea0beab51db84716a2990d6cd5549daaa7e1b10cbfe9acfd9a534fabd74e5820ea400d78b024b2179a93bce3f155c0281353f2fc67c18b402368e6ddab1e74dda9198a043938aa0573ed3e433ed56e808aa4b6da9042ab5e6ebca3f6866480c53a62b9613a7843c7c6afacc2f75da6b41a58fe6d36f3786b4768b71f819d289f92449ed1f8ceb36cd912fb46921d4af155dcf327769bfb24000418fbb491b4057f6afeb35b178e037e956c521e095e2f681189a79cfaa81d248f93bca9d425db50426e17824e03e0c54a90e97172e4ccdf897cf17c5e5897be126f7d64966a686b33943bddee7b90eec09bc9485b78270530408ad8ba9e6d1e3d6825dcc428671197a8f01a494882389e90d09a6eae8ce520a7ee7cd11b4e2782512220f6b6d4fbc0ef69bf972f97fae543c7ccfdc4cfb6b3855cba77a1677e49b413ecb2d53238f08526175b504a6bac72f44c0fde38602fdfb0e215a16c2974cc41209f0481b80cde16f79482e8e2e965ae4c112b00e38fa44fddcabc597d32a9373c8a7296612fbd88f5b8049a922a1c619cb586d6fccc59978cb33ca61371e99c7c4fee5285fce2b22925dc1f70986ac7fcef8f275836965dc4e785ba8443e507c7b3738e4921db1a1b36c8a3c3d3eafc49187efa96a5725e59aa4b4e8a85003aaa8768e4d9135a4e1e9fe5b730957efc76b61cc7607770c38ebfdf7696a0024e5374598ab654582e44c9aeedd6fe4e31556f687d68220a056453b19cde0047f70275cc1c7658822e4d76b99a7317f459eebdd3f7830c0ad63bb489a3e22ffb6ecc92d8711670bdf1a47cb66714e5b72b766c16138732715be7fc1b8bef949dbc9b019abfa4073d846db85c2fa8e1b579d5086e291bd498a8a28cc41753f1cd16395ae3428ca8664b58320164aa54106e7534461f912813486f88f2717a160c7e30c8d42bfb545955a0bdbd793b6ec1221adbb01e3e25e62865f743502f60f0510309b5b7731fcdcbd7a47cc602f8e71ae6635d0d2a4988a439b1a0e65b64e2b3fca8e4a1994435a357f2aad4b45a43864021440d27c1e66a9367b85fd3eb0c377f905ff3dd6879e8ddf1f7856b3eb200d7f67c9365570a5f13e959eb9a47ab29c8c92fbc9690f75494a2bc1d90e99d958f90786ea2349ca7ba597a5048009e452419afdb2b3339bbdee172b08ea659857f53dc175cf8be50561db7917ec49789f414f403385371c8021298585dcf4ae429bc9176ab49c8c7b978e44eccba456c2d2dc92f246e08ed83e1db4c15ffdf2ab6850bb26e9e19058c63b996095c012b3bb3d93535c0e75a919dc835ba5885003a5f7c7145bfc48048fa56d1d5c566f579be70c47e0a91d2b88af445cb85c2b7e740069a3a1aeca0104c98346ff33d45b6f0a0e4e01f41c509a274aff5f1dc60f1be92b1d6ba096ff721155368ccbb77ff636c1d67851a5a1724d74d01edc57e97a24c1a4e9f4515fc9c55f7bcd5f7cc044ab05b2705f64467bec8f01b688efbeb2ede36f4e865a0b01810b79b93d35cd8e5846e51ad0768a07d96eb18b3bf3a08489000f1631f2406771d3d08d631c6ebf0aca3a277a72572a1deca94d1306d1a3151e44451b200d8e1ceb27a13fc45250a12da7608979cfbdbf56f6d82ac6a93c637361ac7cbc499893953b2f86b363577b0d5f1068625d32284005fab314ebebd96abb5c25f906658fe22dea3b06261b574515d4bb06787e4f0f63411fac6e58dddc67ba42d22f1f0045276d8ff65f112189ecdbc1b923c033f08edd39f5990d0401250e5d1517365833b284b071a40e317ace591492ed2973c933cddd55df44a4cc9ed629a78258542f958dcb391ead21c12be58853d5ad600f22a8cca8a008f4752de6ada5e9102ca2023838645308b8d79c7b2e865d0a1ed871b321371cdd9e7c5ced7c02d2f72164c95a3f006e12fbbd73b5b9384fc52feeb2ff695664ffe6d71277d955b967856f91347988622bd45c79b410ab09145da4ea16eb5a21c6f15929d42861f885e2c32e7eb819cb04bbc92c862e40f492072080993882a1d16d7656f3238b0382139375e28853fe3e23896448352c5fa64edc21db3bdd8281baec1323341f3b00a5a079306dc01894ca840aa728464d62e155c9325ac55c844c24d2634091ee6d38c03640b6cd516552d2373e242728e7c60ddbefc72d0b23b9173c853070e4a3664b1c61fa9624fbb848acd455a7df16f9af3161dcf463a9487c7deae8fadb8389dd6850467a853473d41520fdf805d7884225e3c173a1f3a4b743692149727db259ad038ed37690c14429a23c848285f4c80364394ec039a4501fbc9a1cecd987694fd6ad8b4a3e621e782ccc5b90254c66ed917f1feb05cda7d010f737ae39864bd5e1992be4dc7ce431c2f103926706c1fada33a4ece95ad188175454903b6753041b4b115931376ce0167d6e4e0b4167943e289c15386b9332ae07dd215e7c706178ff74d79a875dc59a11d9e44e21bf7a8b8cc29d55e480b6976725a7cf11b99fde7843902114695935654a8ed9c4625f1829e942ef196d1bfdd6b114d486d6c7b8552102febc4cd3caaab6832e91a95ea77529ece0518f726819154f20291b2219ed5ad81de9de8e5458ded9c77c527b380c4883066e4258ac2978b5c29d4a57def958c5edb1843e716a276b406b206486c275c5b71f8f615bb6235a675ec78a45a66530ca5616748540aa6ec4708df057b0e98e6915b68870ddbd330bcb2e48b788a1bf4fc3733fd6f8abd556e084c0751dcdfad6a381682946329d4117a698115feed8942b6ec5f3f6f3c28e591bf95f3d5e3978240f82f5d82690bc769359775671c3e041e0e09c5a2e87905ea8ab938ea299bf2d74222ff0f1767ad1ed81262554a19ee8c4ce5a8d4a7f1b3184b5fce5ab37845f68ca1f37ac7d6fb804fad574b8c2e6a0860f1eef9f3dcb0583992002fa853944b15eead849e1f6db4b775c0f219cc0bac4ffe69f8aae83b7beecdc83cfc9c4bc2f2d5e08a90f26d8836171ccfba0e31fae8b79c869578df8c69a25b6e26469e7d052366e68ebd1647b54d680fd0c7f7f069829c4c0c710cdea28303e1923567e55cddebfe73dcb0fc91b5182d9a64be9f4f26adf563d5bb2b9119b58ce381876174dbceed44118154ea6d783c519def0ed481db67d6c060caf5c44776efab685222cf508f01c37b8d07b56202787066ad36bb8169ad5f7ae62db6c913f9528372b99bf536e415fd9cf5c08a47313a1d20739091c53e61581457ef4d5596b329a4aadeb88218591fb279b3b74145b3ad3352186fc8f4f7ba0a61e449b07d4112c2ac7d9ad519dd3cedc0f531002211cd0c2ed84265b84ccfd71bdf88377c25c3a1b4668a7275587ff8149e0e77122340a331a6681a2d84e2b92df471a0e8cc904e985117ebcb1dd0b391e9ec5e41b0c6d95af9fe61454cb10ed7d086ef881da11c11990f2bcb8163d67fd8b12630fb0cadecf4ace7bb3a8755709493997b55e23612aeda4a4900709cd351dfc422be372d57b6e7a2815c3d93f46f742f240cd136ac3d707804998501331ab8d421dba10753f06caa045527231c4ef01574ac7cac60aa5cbc1f4df73bed760e3d678883ab04d8bf315d38697af39c9e93619b147dc207532474e994cc06b01e78bf1f7036bb61ff4bfd946fbc37228de65b00720cc217e2fda98183903c0e9474622db7bbd4eac386a19a684c196e91e5ade23e773395141e57b06dd1a73eaacc3a3b309db20e9c5c3c2974d644f286ef6c7b1c9c0c806cc7ac6d4941e81026421d877bac18762bd36f314e5a30e0c9cc83c8385724c0896d8e1a9ca5a427c10c35d1417c8083bed4b7f9f0dbbeb20e254d77f187b1f82e3c6d0bed85d5715be5e9bf304268ce8d23eb6ac1c7f9b93faf98dd32b9efbedd55a45c44ac7a25c760986913b8251a5788131d1acc23b9008d73f84e5e26ae85fe8a32e9169665b9b261c89fe0cdc04ea7bc9a42a828e0722825cde8c0bb73f5e88be3a071f714cb703fd0f5945d2e7bf764644831e99500fc9e91b96da49de9ca14089004dc507b2f62985c5e9b19e669cdfe31b02e51cb24cf8ec49e558e85fe07ce6493830fa1f9e55489a39d263b74ad412da382b21eb107ff7e698055287088d4e088b7f4aa4c9f21d99d4ebb84c48be132642aeca303af1dd4a8ceeae0d5e876264c5109f034a33bc68b28284f3e4dab8645393df6b2378ba6f19a14d25253daabb303feade8b28cf3b092fde3a2f4984e7163bd574138566574d9f1c57fa0b50714da74cbd3c2f5f03f9c1c7aa0c4f7aabdfd4e42088fc1204cf49eac0e59068601c6608c195f8c4d8e9d3cb30586b7267f2b849e50cd7ef4fb82da44c6b1a9b87891e4291d2c6a22f49039e3f23a69e042ab7bb975a74437659a577aa00902c2bcb967ea9b6bb5d54c1f5f70895a5ffa2f316486316b04cfda7c63bd7b0f4d56fe20caaf8b4aa1cfad47d20476d637579cc65128173fdfc2bea2b057d0b6944a53e01399148e30c9b0a5e2fb0cdff24723b872fed8092a801dc1416ee9b0ce25f1c763f814b11dcc2b863c16fd2409391145ab6e0873fd31de022c118fdc4d76550b6723adc4f77a947e6b74d04b35d913f67078571d219723c1e6de2ba55349eb8bd5c226a0ffe8c4ba85f965c0648464ce4bf4212bc51032faffbd4ce3af78a9d25c8716a7f32bd4172accb38bdd15096f1e7043891cd5925a1e2b7b57545e05cd7ffc61b456b903f822255c5351a0bcf5a54ce2ee28d274d1258f12a628eb6d84782e1cb7bf294b2049e232a8525b7e936f6db668d20cea523e6a452a1f5d2e13cd5f37299d594d696895aa0d8093b6b4c310ef58a32c32a3886692f8b0c1872a19472d427088011a10a21bd8cba7669eb74c72d16e6fc4e5e2bc1d93e798e9ce691af59bf814d2e6f1643fddcbc1c45813b17bbc5828ff4ea8dd9d16e57f3edb2df08871be00b348d241b568cf459d1f6aa43bf32a9d7bd806a5fc163dc938498ead444d024c8e4a02d326129e2b9b042f6135fe1ed184d769d52ccd74b2ca719c2987e3e79e7304c1e88d7d2dc3716603bf606e58ae287a829d4fc11c4c0638efbe471b38f74a56179ac59cdf1fba8cf30379117baf44199a8bd6e7b75103a0d1d1685e800b129a1497922cd1d7561b2749244d2fc1a7b1ffc346f9e6adc6542d4a7a8ce418b01003965d0257624089c5c61e50ee36ad85c0102103583830262cc3b693d9c86b4975d9aa8880851df9ebe3f9b68bdbc30aa1a0a84509ce85a8da076563238af3cc47e197937fed8ced992cded59843a8eafea9786a0cad1ec0662ed091d44fb978de66f8662ad6d9e9c0b7ad2960650c8a2ba1240030b652e17327ce23c43e702c1e47ee11d14d81b7fa6196ab729a31e8ba70d41ed4ff06e3758381c538f504834f1fd66cbc741817254ff6cb963c22a78d9b4455c7d7388f425d7628c971f582f547fbdba7dc8412c857162a77e959c905adc3b7f27188c232d9141686aeb4cf65c7a1ef62a0884c1f8687f448e19c9a34689574f5b0e2b04259ddad8b75731660b6694d052cc3679f7863670665073b9db8b9ddb45a1782b246ab51a974eb5125bdae14825be5070f01e3e11fb13b8db61e587caa1752d62ab945ed3ed1b4ed9ee594d2eb32c657dacf4a18274aa2888c59e4030818db97540ed9429d728066bfc2e629f9e0a05e5eac12a57c0a3bbbb143620c69d8dfa1567c498d28454628ba3c119a6aa8885103dabfab5996ede0ea516d7c50636ba5b37dc6cf98a1034e890965f183d971bd8d840b42a33b8c9786e2ed6e370ad92f8443c174c5fa5cd15f8a2ed6518be43dedc76a4358bff757ddf79f04290a5512abc98334eeb5e4ec112a4f097fa46f0a28bd30e317c3f50669e689e8552771b3ac4761f395007552eb15697af79e646ffca169d383f9cd7464d364229f0aa24d0790170f375364409e227e4472e5702d93d96875f0f71b34cd5683b49676f58a43c9ba3c356204790555e72468065b5f030e9d4e2e396879cfb29a80fbcfd4f9f79f475529642c17da8486b52c2f2d7e920704d19baaf8cf6f6e8b073a37b939bc534a54f2c06c40428b84f2a4687dd7394d45febcb9623ee00ca4ec0eeba28e673efe189837b0a5d416a65f670ba63132384c2ed3e689ca1cc30d2558801c8717abd2436b98d6251dbb3abd86b5772d1513b132c190c1d4efa1a3d9c2e36580666b72402de3cfffd8fe0f408f8355d3c7178e518ffe6f3976c308b2c25a9e728154d0c8067de9679293b81a2a79588a01d51974ae494cac3549946e868347ca2acb8d53b20a509c8984efe0aec24935bb5925bd800c1021d9e0f2800de596e20ad6e21ba70338519653d0469c39ac52f994bfc707bb579f88f17ba075d7d4081dba0bd785d76fef58f7e13ac01c782a3bea7626aebaade0cab449b57e6f85894cba1a142ff67dd0781af7a8cf04e53bd95561eea1555f24ba6aa1cf0704f44d2528d81a2c3f105a30315e7d10f486276dabf1b5b09fdef9d0ee08d3defdfc81667c83163ed3885027a0f68990f2d26b2f85dcc23ff415d2c36b2641f213346b8db66911e604a0c073b324c16185d68d83acee048579c66420e1fd6fdbfe9d5a8e4adef2bc7f3b62147116a0ee79f322a799d779730c8a16dc5523a8e79915c5957ed61ce9afaf157cb60d7132b07a35ede80b25f50e20ceb6f262164ac195414cef027a13fad634368844ef6642bd2f590eb0782e0611322e32b3fb4cfd84762ded68eb74910a5ea0d303643ae91da642fce91df431b7fdf1685511cdb991525fc11910dbc72030244472acffab86b3e7ed46708263acded521ade5ddc1b92cf6263015a67e35ff8faf85cb0728ce1829dc7f5a320ce928e1f1cc0966db60c013d11c12ca21207b9f74e532802bb4295a0fe7f7646491c7f62201f509dab8031d89121664f0e0d899841ce69fd6ad11f6219524863ce5e7060ca69ac856689d6ddb6e7808022e58e688db243e47224a4aabae31dbc8eeb22aa73f5302372eedfb74594642acb83dbf862d755d880f52889f1ac6883613afdf92910401c1d4518873dd9b39cc43445356db5906c29f6528fff24e78b648097130f4aae0a86086ef9b5442e865b6b7e591d9760ce310054eded7f1de6f852d89396fdbdcb193d578d1fe5e0b058e4ae2ccb7404b4ef170d49ead6116b323593c0a8b425acf9d4b2f44c9a0b8758e495e50c80e8dd3638f9e0f591371f7ee465baa7e7c2eb68d945c6a3fac9c93359b249fcdc98628c448871c793c536bc57ae50747a4a3e20fdb37b545e3e28427099075c5993a90239d22f9d63e3ff0fdb206e01933c9f5a5104f095ffd6554da7baf7d2f53d720626150acae6e47cd276af7ddc47499e94dddd47a1fa7b80ee3c75783e64b69f4a3eff864a01a41a13c8bfb85134c0c96d621a591b71bd9ce79aedef875b89cc42ff548d91f046ea5823dcbcac8ae417eabf7a62de0a5c8eeb231c2c8a1e4778a3b9d7a4590a0410afdccf436fe5e8cd9a47c0902e7487701987479b54870dfbd742ada1f3bd6a0bce709c62fc10f412a557fe55e1373dcf4b86cfc10488059609bdc2833255753a5166b90a2a256c6b54c6b53dc53b135ca5ba6c156849794341aec2a6697fcef373799671c45ec53c02d783e117763da561ae8455abdcac9bcecf18369222bd2805eabbbd1cecab4b061f9fd10cc6e2ed8d4d9cdcc5dd5211dd20d12087db6d9529d3e38ae0246d313576034d9edaf98469ff534b918492480b886a154740aee211955218091f241947bc2f5cc85899e0c2a842a4cfbece0b7c4c3a108578bec6774b2162ba94120c883e20552cd7b9e05dbdca17625e35c030ef0abd590d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

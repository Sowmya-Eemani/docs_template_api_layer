<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dfa1e8a86025e64a89a66fd4cbf9a9a18130868942d787acef34db464388134c1903f7ec11ff159770bfa7ffbdbbbd1bf0c89a58e817a2726e9504061e0510ffadcba7526e2e99cf15133488f891a1404afc76e978c0c4cf7cb304d69dc31143451c2153df8ea334afd24be52a7ab96fadd2babf8e4d1f150442d8dadecc74ac2c1e651584c80de92a2437805e48d4d4b8d8dab88c38cea750c29b46ec66b22832472b0dacf268d2317cb8614d654e0c9e31a1eeee149ccabf7a3b4b09169c5afe27d0521eba5b6db046043520a16dfe2f0d50bf3d008d405e916a83b8d6328e3b16f696be4668c5ca4381b3b4e349fea9a81c8f73307fa298063fd23ce5a88086c45e2ac06ebe9dd35e7db9a8a93d656293397cf659c3ac1aedb67b84a92fe40ae4b90898bf79f69bcfb6283fb471ca211719035f3dec77af2929a31c89bc8b48ed081271fdd6c5f227238fe4735c24211c8fdb80c10227f817f12864e91e999ca993ac15ae7cd7f79642d68293499d78a90b6227b69579e878e2f4111b7f43089ee78cca2450344fdf707c21aff95a2405eea825eff7d0b0fee26648e2af31412f6a957c078901053ae745b2d8d1cab523813fc14e630692381ae661018621df807b160f41496a9cf24766083523e64233c834c0d262ccadac2564315821b5540ba138e1f977b6d9473489a06a32d51f45c6dbc5703b6e58ad85ffd3ba1a88b31fc61feb0a37639b7f51b0bafee6cfd9227f8927758c1308f11dcd731ea35791e99bffe121b9b3e1ebd3b1c242130b898dde247cab910c98e603a71b94f6ba769de9afa7fb88763ed1f31f819356932d8ac96e4e93d77db11d13b6ed88687c0a207c8c3acd3a281c9b3ad4bfa716d71218dfd68852cf2973c87414efb4d96b6d8b08e8e097de93abd7d0a48f7f531be70f883682ece8407ab8a9800a1a7fb61ebf77a4f7293ec0eba75dafedc41ca58d396d355bfca2737cfcb0dcf764f32d818e08d89da1f2dae82e85d2dcc1e47bf7d765107d79e5d0ef466a8224e9067b84dd84f37b1621e9353803992d8425166bb45434a85250b0283905982cada3cc22c6c24ff0bc24a5e6cb382ec3a880981d9d250c1c17109dea7bfb553565e09cdc666056ed89b0a0c1cae0a61cccfad2080bd01cbfbb514af9c3a250408384ae3a40e8a63354eb9e45be30e3f9c891d6f37c823b92efb9829b77b22704a1b85dd02bbc85c98630bb87ece66511254e6d787348f576719f446f77b9415d9c02a6b93e423bf908131c0c2d5f0e46a8ed4fa30fac8dacd4eff9732b1a4a6d89fa7e1851b020d58195e756d22b11d229f732c318a8791f20bc9cd70347033e0642093bfe6a4248d2f1041143637e2b556ef1a8cbb8ced020a0ee20a1567ba9767076c25bcf8c87ea0da7d3727ddd6ae58f365590bae3b1f27397e6291dfc2d2342128ecbf344f99d71587d5610bf18be648a810fdacb1c67d9cf9b6043b02c54b6fc6d280dac4e44c11df93d1b2f47e7bf5367d252b1abfc00840c8b24f934c3daec0502132cb504474dee1ff67f6ca4142cf35a8ad6b707c795497e067c48314371e491665187edabf1b05b7bb833837cf47da3445a32e07f2f5dabad297022a03e5c75922600728d2376edecc3c65b8657c01b10f73f6971aea1185d60a6d18521a9f62d7531ae62629ebd6ff82a70c98d05a7babd0947dcfaacaeddae81bd65572897129647cd92569577f6e174e80dc13000d4fef7c5ab37e95daee795f286cfd1e8748ca72b674f6d15893513b6e47e0e7aeeb41565fc2be4b1267c6ca2be161d1f1501cbd4da98a0ec3057918b679f6dc0247209396a803e8da58669b114f9aeb10f1b6cfe9dd0cbb2d8d95b632c47d13ebef5575434c4377991eced933435abe8378332350d0f4c6263b10d200611a476a5051c6639df93de4d871375179e6a313a375aae0a7503f7d17abcf19577eaf224b49073416f248dc7ea2231719e75eade01b89e23451e4eef0b37ab94ac287927e5f5f8ee296beff5bbf2e80b47067268cb3d5b1dbfe848a1f269e802c7c93162fc66bb4419d0731b21c8012850e490d4cb8ecca58ef8e91aa5b0fff17b60a131a788bcda414c6a4559aeb8e9058c2cfc61683109cb33960b9969940955d09c447e86a7b7cf55334df0b92485eec4d72fd052403b14859cac15fbd11c053f09bc88748e604ac5dab211a586449980c0af59fc695a0ec06c411b0a502d22ef845d8092c1c019cf5b1ef7bcdad9e2a41b960e157d09b6a64c97eab94a2a7f4d16e2ac672610288fc9f093fbf7e4cd3f2573c43fca5818e8026be3d038515ee00db49072f66cd228798575618b1d0b1c31f9610f4c39fa34be4d93d2524c45e9602617f6dd5b24be079745b0e1f98af22afd0903df8d350cfd1711242e17170f7230914c5d26d5673d2635bf6a14e76dcd9cc3c9e3a06615bd0bc9537252673e389b46fc6b655c1995b76a4bc7d62e191457fd235e2a1dae856ac2830b9c4ac6e934d7bc3eff05dbaa870e5ca23f435d806788adcd9a8dcf2dd26da8df6d011b680035ba1f829c9e9c44a7a64613219da72a600a6fd10bbfc875df2368056086a498e0148d71cfcc8399cc5eda0cb3809a24bb5c75a9e0a20dc149c11c086bbadc8b7c9d69b33987d82e0cb4e726133461ff036f79ab87e818936e7f6e86a0057ac4af13de33808e1f2e88895af9b54ca7a8705a22e20795a7b85f958c7d10be2e355163bb417f34b67a1aa411fdd482ce821c493e3994bc749cf139679488afd3f9f8846f28d5e5905216fb509eb41b86ac12c24f58c8c409e0af5a9079c16a8a973b0fbfe6ab70d428e94f4cc88878eb3bf4b04440cc21eb2bc4923867b214ca574fa36badb3480272d0f3f66035b6d2831334b189c34c5b151077568557fc8ca8966492af56194740cc5cddb13989368f0343e2532b52b71bd180a156fd393152abb721bc02bb3420cbe8507f84718807286cb125ce750705b40ffbc73cca20ea7b2e56851386f9d77c5a29c960f058071bd5b3141609fe69326ff8710be0a2b0295a72d3b8300811ec2cd4a996c9024f929d2fb031dc94bbc3adda2a9ee6f30ecc8a131a63e8c3cd846cac16048f3f18e5c71c4dd8fdad9e179375eae7732634d80fa0cc8d26af6978d721bc1259d8b4584241f9751f68d392a8314956e8f001916a4d13c263a8cb609b892b9982d6c68d717585c8194db8c1417ec65eda84c29b90bb53109c4f81c6d5810f50aed21ffbf464545765421e996bd1de4c8787330a59a3a9fe586329d36f37a6ad1a5abe3c039e97a538781048500621f9ddf373c253f1a9503c10705ba7ac4c2e2440432a991af1491adb9e654d4d597b759b2304c7fa9cbd7d1e5b46d5756fc136ac7dd71d4f1cb14e9fa7cb639a3b09bdd5954f134c967aabe99e32344972962919637cdb5dec09f67cad441c0c17c06bdfe9035e8211bd90b5037dad6767a38807fdd18f2574a8aacffeea5257515172eb4d5c660578e7450517740defd92e028f267d750726a604404582b0104d67b83c612c816036aa589cb33570a508e468e86b74713407eb40e04c12be171be581ffdbff76cf53f6751a534681e15b8833ef2e54757874195ab220055e5571b74ac5747797285c29b54190f1a7e7664f633fc08f04880acf552ffd3d4b78bb8ea015cf9bca5e06589c896e8144ea6596128633d417a817fa182590afc14d34b9a26ecc308c95ac2a3c47bcb643fe5229e2b6b33b1980b0a7bbf0020a08893487a16f485c2218c9e585678ca2cee94d53a2932bacb6e2bcfc0dc50ce856014a933e6b6a3bc71b5c9b915dd3d0d12482f7d97e31480bcdd0d8e9a11451ff52ab154b4e4f4daf05f245ce18aa93e54f94b104ee4938db0d45ba42dc605bc6871f934865ce47e7f3432172ca33be627f60466f5a84c013a82558990ad8f6c6f8408959afee79693519e7b0bf4edf8e4aa3d1f9589d123db37910120e7d8ea9007909acbe9679f6eb47e4a385a6ec5a5d0e214d46035626e9126565d8f80d6efd2e25bce1685f3add57534098e0d58b653a66f4f7394453acf3310311d1b90e20c200179d25e89a7874021bc9a28d37990efe9fbf4817af3d1317e38a185bf1a29306b098f1c69614083f76ebd13c0ea36ff305f085f466a5bd02797f1fe39d318f204720b5e1ae7851b0b81616006c2712464e3530842888957abb4bbe59a79c854e86851e90f0a7b98786139306dbe031a8266bdae01db53cbfdf4ed0c9640c57b00461c8e39e3fd1b8c005c68725286afd0a4b52fccdff66adc57d830f228746f32a6330ded69ceb7fcad0d9af689816a849e59d12917deb535a13c53f155594ac3a6ac0ff1016e9c3affc230f2d1681510bfaa09af2ad6bee7c82dac63d001432a9889fc2ba92581c6bcd4a99c9c286493e5378fc79e765b7ccf5e70396bfd5e8af761c083fec2555d2990da627dd9828ade3054ad34ac3fd99bbc891c1bb67d87655290ed807cebe29925b97e45950b698227524e38dc4f26d766b3468c9520ec3f7d32303e4458e36fe2610e23e3e57ceba009e796a0e0262ec1b883c5356f00edc5c575e7cacfadf8c0e0042453abf76db906d6452bc81998425ef0840a66e1a4acd5727e6e6bb0d2016da973941c0b886a2441ee7d5bb43425fdf0dfc27c03ddde3772c7f04cd78c2aa7f92f9a31a162c1f33d45aed9e3f5d9311703b3f6fa65103f9557889fd47c23386da974e86d1068d2b8a395b949764ee4bdd716f83c11b307c2f927d7a130c660dfd23d8072df76d3fb76d87a5f56b5d6aa5d04266081cd205beaee83bed8d474853743ab88b0908ac141c8f61f782e74ce0c7560c4c36e89afc1a78140839b18816be5477c41060a38c65415c1d6a498e9f3aa00183a3be47c8bf753399ca195a0715864c66b1c86c7709b9a118cbd93ec56efb1e3105cf56bc07d791f2c6c92307e797d54562a29c0af0f9ed01e519c23f0759e0c1f5714ba9cd9bd67e654bd9fe23366a7183af6bfbebf751b71acd9986c5e8fa761627bb0c79a3862d25d0f0e75fcb3f6d9f607906d104897ea454c7c0c5dd57e104ddbd888a36df66e0b6eda88dda086e83fec6d4048040d314e890e5539652bb89ff3d55a1f7161049118595d7fd3f2b7618714d3bc662cc639149aeac36266b59b4d3bc971574e1ee5c3996e455c55d3165b320234ace2f78efc692a703b85f830e0833ceeef475586147a1da309660e84fa59dc90da7c8ba877b482620915ac9d85339cb8d8b265f39dafaba60b1a589488445a9af3e6bb5e1f1d8d4f1272dd5a861c5d13335ee5db32c643212bce1a1786511b8b3e8d1a7666941ba141eb987d2aa6d603c0feca9f2b5e09eb04a4f2a711297a2e5b4e0111f6e308f3defae0475b09b441eb253753e0ab334a37e7fb3f141bcf023aaf76166b133456fdb6515e032fc8911c8c885bc971b14a96f04367305b4ef6c1d35c1e1089c568b9c2e44b5f718e9e9254a9e3e0056bab37058738a83b6bf0194510caf727e02c73979a0e009fc079d0b92a528e44442761758d2ef3e96ac12f656c75715cbaf633a83f6a6a18cdb6b443d77de9884badcc7d0835fc172184954b7037777da931a8acd97679ff6cac5581e867f0c8be3edecb0bcc153b2a4d4f618d6313badf2c633c23bd5cf7dc36bdf5563f20f772c38138b9ab2b5bf8bf1f60695f9694591080dc0602a5c7fe0b5815ba6865925d789333a7767342707e3ea2399d11aed5c0c471d6334640e22579f8b43a6238bc7417b000ef46bc095cebc3ec564e51017099a99b44579be5ea95b7d2653c4eb94ceba7dd41f42b76387430934da42e305f844573a615a22f67473c85dc39acb6d9ff76b4a4aa7353b264f8be983fd50255bbd4e1a2672a82194dbb05bf102af15fc9bf71c21149d6012401f1524560a0edd686a6e68c10079a4a63638e324ae3d61895d7616cd3c35b3a0387b56b5ae2677ac9f4dfcd46077f86b7ec46e5c7a7683deb900acc383641e6c2b9247ea23cebf62fcaca7314cc09c8f77c499d128abbd3965bfbe214c1a54dec2e891bbfcee5eef6dc6d63c6e0c219409eaacc61563855a56a05045064f7c324535cd0e757e8272cf37623579982a5766d3d5cd4da3a298e34afb95a5800e08cb3afc5b25ddfb96ba7fe3a2a5f257085637df4eb6629abc5d9bc55fbb22eef69484b143f3f1cf7267d6294a11ca2dd73b58991a5ba8153163c41191392682035a419f79b438afdfc06e713f572f840e0615cdd99a638d180f65bf3a0a30949b9df2a2fea8b3e28fa601debb8f6c7359a96f805f97d2b82cc5608eae1522017b6f12674fa35f0e4980c226389443dcecf0a9fc74a12d3eefb13deb3fcd64dd452a0d2f8cf8bba4b9312d0171bb0a5a7151f937cfd31ef787256fca64dfb082e5cbb8053b22ddec60af9597b59cf16d3af8dc128aecb48b731709fdeedd73c7fce20804dbfaf20fa5fa2940c9fa97d9394568bbdbe78284f5f9a3e8db8f0ec6773705ddb45e377711151e88000792b40396381d58b5faebe40e430d6781aeb38c2550b326dc5542f1393580764b3b3dcfbc3f4bca1fc9399bb41cc617e07973a5951f2e055c550ab1b2d8c0432454d0341287e0fb8b8d83e2f376fbe2ee8e2936ef08657acecab9067484e6dd3799c0ea5c2d908cec3a1a85c6190249b42ae2697fb1334689cc6ac74b900fcd2610b58bed3e371c0417cb6a4f34e150744a331f59a63ea2552f8e98d09e442bd88f6a1c41088bd6b547ca64dbbd7ec6cdadf300d28b8db17c565242c550b062cbf9d8ada0eaf584990e64f8b58e6f7da3e456067341054103c3ba33373f578670ca99606716b240d54f59f784e4fa62f7122d9d75f13746b7d3f568be67f4aa231b8f26b32c4ede53762a6922c74ba4ad4a89bf0c32d6668eaea50ebed0a3f0ad4abd9f5d761e0fb2d480e0b5887f3a36e1a767c9e0ca5b30ace6ab5269ae5e68a61364941b7c37dd50ca872331c061a0eca75e7de45231c92c4f379cb15fb798927067d22ff31e28d73e35017382478b72cd9f917a1e9180030e6c7dd47c8f390f6f9ef6c906d305b125b8618dd878f5ee095c1a8f18df31f88e1d542d1306f537632c022dfe8b8c4e25ebd96d92cde2c8f61252a7c4aede53e099b75dbb55513faf02ba186141e8d181cf4901a967f68f966973c178ab0f5bc0a7258c015b082bb6edea78850e5ba36171024a47c6b2c60271cb56392f4fb0f34c40d175a141369ff9d10b92ebd33b6d568c80bf0a1dade851be9bb53715cd24410589aedb85fec69f86bed1f407922dd80d19be9118745f285c9433e219a7d477c34b2e1687b9992e13eb73283318139177624cb37d8e4e62f0b7056dcca3f2a257ac1dfcbd9756b517c4c8a429c4989f4179e7c319e9155b76d3c9d1e377b635e7d2d1f649400a8d3cf71e42fd823c74ab435dae5ce450e7df4c86df506b9054586b882b855577fdf0c3a1535a40b2ffd185cd057b99bb8491f164088acece85fd233dde9aeb439993cf801825b1280d0fc6b1cc8536b0ae083f9485500383e29f907551f7bbfa174d0aa980e10499314a4275b3033fe8bdac0c90b1564c0c2967fdbdcddb043a57b9f0a9d4fddfc2ce76e55140eed5f050bcc74791c1c5f03f6628bb4b0c7dd16bd982da3969c09004ddba5d289e8c2ec7a430de55e33b5d64df513515d8de4b406eff6d669356786391b8337cc52fd6d43234453bcac17cc4c14b128309a3b66f5970928fbab973591b530d46a85ef16b4da80f1ed54f2f51c23aedf4824b141a02e0b03bbb83bd89a146e9fe20c4063714a348a5d534e4ed9cbeb01661ab1681af283a1d5b5edefc5c3237918efbdb3cfb32d140fbe1b46c22b72e3a30b0a62386c3bcd5cb46dd6b20ce44095f7f1fda66553360a953b779a95cd308d526d2acb6b13c97f4987a85143f82903964529f1b04948ae0707fa1e12407b172514c21363b14a0ac4e755aa3593d5e57b570e456ef4d69bf2911b465c8d95898075394e8eb3ea21c857810c04a44874f2e4cfd60edc272c8c3adab9d777c88b15840d5dc7fe330abe0b12564f0e61564a79ebf384f9ae4af29d8a7fc39116240486bfd05e15cf44cc4bb23695ee0b8bd88d628ca29fcf1ec4ad30479966cbbd2d2a2f69eecc09cdaad1c967704d7504d3645a9deba960f8abb12f974f9807c418852ab81ff5dad80aa1b6c1e4a118308e6559a90069314b813514cf3ea00a3cf9a8b34671f725755194589fea82168b6d693d1901868d68be815a06ca11282b92988f6b07110b58fe6c9a7a8cf8f32dbadaca76f76a734e378478fe34ee578a0b386efe48e0391e20cc54f48a7350f627a05a7d4d6c8b0852974090a9270a68ead5fb4a57611542905363890d30f8f1ddc057ded96cb39fa94befbac9ec5dfe320264c40fdfb03404955c93f16233da45846f7a12854f992c7ff24a4394647572ac493b1db154f1d8713ce3e2b350ea8ce7ddedca6596bc64f3e25773aa78dd50a9cdb63cea11f8a68159872bd2946bfd965f6620e5c04417e0c714d9e955e605bbf5eaa3e546dc36e5bca","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

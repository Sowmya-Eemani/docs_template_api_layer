<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"057e6153c5fe4433498c07bd63200e69b9f55401ca3655440a3ac26e202fe91ae29e88b2bf52fc8cd9107444647b7b8c3232a342ae695ab91987b37c548037630b78f4c8e4f372d41393730a40ea7501677368d6b996b32d192f2123c8325f722e3cd148d82f8154f01513ae9ec24a3d9287e4bd91e88549e364e5ca3636c0759f2812cb337e97d5df43e42b600777d387656450772681ad53126b0ff62e91b9bbea83af78697b4fdea48549cc7e9e33e6d9798b05c8650193818e461197fed8d142553626756afa972df301901404732007ed0df5c303f575bd8670ce55401e576debafe977f91ea0011787353edb692bdf6006f53433ebbc001099a53d03b7e186445870ced1a4915389ccba424b248b6d70e8bcab4435eee54aee7f9bd6ca106fc75731d0f6535cfed7b5a31b87933bcb75f9f7c35b211d535ff4934809b8bc0558079fb9d87b661480c993ab5740fc835a96b4b9b9b9ea9ae1f5407d47b557577a7a13ce8e1826af30216180b22df3c7a0259acdf3bcd7e70115a46eeb3b2006da0825639366e4c098fab346e2369f176c49e92045fd1978170cd2fa93fac956287b828ab5e1b0999cc51ae2fe92ced763420dbe83a9821d20e5a3c6b134edb9396f52e3e0ae3d730d399354e4b164787fe9fb84b68904a3589390d00d5176850f2a04473d2d1ddbc5a39ef0a511a1e081672d0053250e446b6e3ca8ea72262159665bb86fb1693a1ce57f58d9ef72e86e8738eba6cd7414224f9d463d45f6fd06812d355a8296730d9a6384d4e28e470b1575172cf018c28e5212491c73c3ea2e27f5e0beed555157289add53901abe96c4e96de35a7e902c20d1c124712617b69e376ad8177bae9cae413f50710826cddd459e91409d9504b3b36f2eefedef14e004b61273b3d50dceb03f5e0c965cbf299709604d27628e5e381842e49648fe9d786f1197138e4380b99a1b274597bb8f25ed361026437794942994bcddeebf235e68bee3e285669ce1bf81bf76f9b1ba0cf385a14358d98bbe8ab41f84460cf7b58549d59d30468f0a4cd0a49ff489d14df80490b7fdad0821b3f2d844deb48e63a6d0f73f45f11280d8b72920fac00311018e8a3e52962732bd77854d06fd058a946ad6292070461f698faf76ace43771edaf799735804467308d005b9245d1daed748b3197ae30569642c7995acf6c2d27a5fe3b16b99a26f165c178023a87d81b79b224318774f639b5aa26c365d5f2db48f6e92455cf5cb93747d45e96b95c57d01cc0b0fc2023cc924dc7ad92c75b47eb95a1f790b85ad5aad0fca818632426956159505d0d8db6c39ae421f6a7ada2ce28891d015b900a4aa6effafb30696585fcfd48d535f2ec425962a286065b5fd3e0e2e5e33e70f114307232a3a141e14992c38b1b79859add2e1ac6bc0f0f635ede62b981950384ba36f0085bf8bce7f35ea90a36e992617dd59fd83df5a8b1f8a948dc6bd5d517331d11851cf2f798f87bfb539b81d873c5d582d765798588da46e2c269fef6770e05a785d618c98f59e593b6e7901c217d704df652bcef2fda43246170b48b4709e6fb2bdda2273dea85313889f618ee65a1c9780039872ce6200d0f806e2e58c4c7726aec0c55fa6fe45b6a282817a1f48d843775e0bf5709304b147a051033a796707140e09d26eb17bb19ecca6257481b2a8271e6073c25ddf9e8ede6682b16240f22439646c384c052a7b8ea49817d42eaf9bacaa369dd8b3c29d05e673b5b439b391bc4f7f163c80c0ceda827d65251d8825bb8ed43126989fb06f3034f53d8589f9a2fe1f325de12351e7aaca8c2b9fd7bd1f91527ac48db23f0949222c318cfbf5fd88594e20f04dca4fa4bf39066c14e1729a3c4142e3f190bc0baaa85d8545d0814bfa3c9fc8db228350d1fcc8526089f382f3465eb9aea29acac7faceed5357059d3e9c5d71c77de1b88ad42677736d4b1ae8d32d3d9c79e0bba2f462a24e63fc7cf43b97217ddcb4ed57ac205164345aafcc173f7eb4e8d1dce2acc4d9be3d345c14ee2a3258957997dfba9efad2a9e33b94368b1e2233b0e759ae4e47407c4803e619de40ce4a4f468d3645b628bc8087cac66c505ead3890886879e7b31863c850ad259f3223b1c40d2d278be16b353f639dd644cc0802bb51d0e14c922000f4450b5dd1879dbd3070675a4b6746c883da8852b6dc92bf97eb2e861ad612d21806c95281be4e3ceb263cb1ec478c6cead30391028d7746119e5af50dd4a1d21c7cd60f0ccfd7072a33331ce8e15ad348f57163a7bff8101879bb82bdc8a30fdf863728167cbbc0e3546cdeec6d7137e6c20c3d4b69c8cbb4d68c9c9434d06183b627cf7a572354e22e55daf838e8b901c683810847a8f8bb387e43c3ea765320e37325338673e0012bb56356db0af16b46b59ab1b77d256959fe3fc0353a65646b2cb81833d8dfa806375299879001549c9ed6c398ef5ed502d19e9fc3bd1c85c0840edf90a8cc16907ace5e29e4fa1d2b37a9e9ec3031e4b39e372fde0d06436426e24aa59de7085b9a3b9e136e0ca0dcaccc21b5cf11aa69274779ccd8a70a87d2516d769bc3291c6329a1c40092f0c28842bc28510aa8186419c76ef11067f4ea9643ea9b9fe44b4cb2aad4b0638e66de567d9758d8bb86959599fd057410c9bb30a743c773348c5f32ce109d25fcb14fe36da4ca2786c3787d18d440bbf36741b2233086fcba6825e0dc0f706402169211213c2971f2be19c51bfccbc56d5665b94d3b6e3094c826346f5107e2d5a4928b413d6d2e26c9691592a85b9e121da6ae14903ad691f3dbc71b6bad587c055678aea18524cf544a1a8f6f80b581c970ce15226d70baa3809c35bbb86c030b96cb79cf224ba13039a2441bcd931e338c582b2ee7a67254a582cce2b5867aaa20a86e68ff8a3051a258e6b81a85738ded8684d556c2a8e0719c1ebc4ba25ee4d4724d109f7597fb1315efc846f55e38ce39fd3ce0d8482a01078f9125a2192d4ea63a793f422ab176fd7893707da154e3b6908c1e032c820cef089b71ed062c012936837fe31830957986e38ac2a6e71bd8630d2a9e053d231f8904d205cf16c51ba195941cb82f8a49e37a6117a471568aff6f176ee09340e09f08f8ffc875546e3cdff9fc183a1bc8170a7fe433c141ff2ed5d8e76b100583a8e787890c627c901d17056fe5047eeb63eb5160ca87f99950644d16cbe67ebc1eb62c95169e1b48f87533e2ae08d68dc0b4029d1df45acf43ba0bfdf8497797e2b84c6652195486230c75b6b81e4a7536fb1d37e9071f8421a46c30138e751fcdd11ac650f35a30434c3fd897c9a660ec7a6bf9ed4ebf2372b2816413f39c02fa8f96ff0d6764225941c19135c67db31f077a12cfb0fb791fd0b948801402d09d1d1bbb8f81f54a007886e1bd4f6c8257cf80e7b309e88a2091521bf44f732eef65279547e0293919e1954eda08cb8678071d20d947430b5b1a4946278b2d7ae1b2c077f0c0b4a00d84474247a53060fe50bf2a0054a826c4ccdb45d2b8f52828ac9509cbc86e661df97474ccd406a16e5afc20135efb3f9a6dbc7e6d2428e824158bc78e33435c150cbc779bdd8bdeeec775f03775c66e4f251e9e27d1168352160ae2d0278edf3af9fcdd076c2085f571e852eb8ce7a0509c1cfafd1644cfbb9dae8a7f414594a4a30ccd8c774b0805b55aaa4491c3af4418396ae55fdd6b53662e1dce81d63604df0288c23adf8d2069a4e316c58b04d64c3a1e52072a1c56779be1f60ad295a1f7561493c58b619d20351dbff12f9b7de4331c80303a7daf133fba1382a2c9165dfa3d7b3113271ce478562026d8aff60381702d88cd0b3795ba0a2ac3ff446be3d45247f8c051a215f466a87ae6a76f9913acc37f37c14493d3f706d0ad38ecddcac6cc02cfd19939ab507c4449c68d3ec7fc346249b21a4a348d0ac7169d39cce6d994a97ef91f03eb08ff47737f6ccd3e57d3f82931c9229147c732b4616d58ed67a63ed6f33e174d374e461cdec62d2eb48c8d08dec524942380170246ac9bb0cbf28436b42c7189b50f3d67eac370b289d14841d704efff24c64184342728e79e4e5ec33e1d553240bf01dfe3996dc794bb210f79fcf1b39c4ab9fbf1224561019f091cc16628739d8cce67ca31f4b147ee614e7beecab3d44f051c892255f77cc68a661d3a5acd928a7d1bbb5b01b70a270c9b6c26965e05e907fae26f7ea6c8c47773a1b9dd757f16758a36a7abba97be528e96c8b9f493f46f0078d603499cf4e05f9947cfa4aa01f0781b6a2c0e6f608c7b9829078dbb2e44fb74f3cdb70f288a79e96c2de47b0673e0d3841f9e8496047554f16851bbd58219f7a9e7d060e90b0f8f4f616ba587ae2a164b2fe5c0c9e87ee7c8efb445a41ab822c61eef5a84c7d9f535f7d7f587cd712bfe75dd83c543f253e36b9cab4488e43572bb924fb9b33ecf1c05fde419ecba086541245cfbc52fc6b03afe5049fe2e4ec352985ccbbf1ca058f412e79e1e889b7e3dd99e600a91c19cc985c7570d4fe277eb6b655c22e5793208727ee05937a1c0ae8f072771bd1288bddabff9c39cec7f6e3de02ea771f6054c1fee3018ae7354bdc1d23f4df83a4ce2d33b45e9d7025d57f0db41faa0e0368967b5dc5697d449075a33e0874c6e9b3d23e889598218650ce4a77ff0923b893997574a4f2d3b96b8941e54f89d1599917aeccec4e34c14db82de8cfe2b05bc9dd754c44f9a61368e74cc8d510dd2097f0806f852672a328ff56869b8a1fb231db5767db705cbaa7667274ba1c63b9e543227b7f622445a3940eebba2eadaccf469956e6e2018e7dbf33d010a0ceca6988a43b8b0294bb176f1c4b847151ec3e251bad7177927d4c9da7482ac7888a6512b7b38f8f8c6863e5a505fc3cd530ac096ac96e6ad4cf97d1ff584dc267240a5e7aeff05b92529d231e8f30757bda9d9f175bc4e71b0356d9ba6ef25a49439f4a5baa1156a35c3a4dbccc30cd372f6e5d44fbbaa443a6ff57248739dfab0ac625e0c732c71d7e45e3b96f886c4e6dacf98bba17c58980c8ab2f444deff8a90439e047905e5a37a72b6b6730d6790b10b36884a0e2170dcf6ca29fc8fc3585a860b928637cd2aa5ac886ed04d43f209cbacc045d0463c8d3d20eae93157e9a95a6d5d04758edc9bb2e9181c1a952254d6f0beb9cc92673716bcbc39f307d75bc18c368f5116d4fa5dd593a2518e97f4b4322679997c6c849c62fd8583a8b2b1a12340eb5829a2fd3a1b2b53c5ae8207da8b650533c51fb179c8c0e6ee87ceaaa19a4814380ec93cca07c421c79dd7d453a52e0ad7f5424a0a90e219365452f095171172db8949b03830c992875085afdeceeb69a6abb0c3795e1192dfb6459ee319784371df02d23fdf6b2dddee43019d42bc5aaad5d6a8cf0f1ca046f2b6da22ef0b8d274fe3e2dee382c6923506a0f0d97054f216f392eae9e975672a9f4a36dab008c773c817e6493041576cf4d5e3d126ecc726e4e43a1105d46cd507a22b65fb92bc7ef29139081d54ce643a885922590b90d8230491c2c5c6432ea60e7c020a0c5017a472539e576f5e971fe15acc3d75d7405a345c207a38ad8e85889c075318734e52f8dfb509d392a0b7a1617e4628478b896f10800c7453286a256cbafa3b7c6ff77a00b31ff35d1e100de3cb7e16b5d5c0fcd28c989a68d37f4c6c75a21f38cc46889917f500da15a109446ff5a781ac84f3c23c19401fed74d8fcb00aa19785594ecbd22ffb4d7707f1026d31a6f43440c191cf36a610d8667a8f2be4d408df4b41dc03122ecbbe4de38eb2aedccb9091150491723b41659f2a273b5d330e3775229814ddb7be1062a8f95dab32e2b9a01bca20b52da211a83e162df4d3593e57f6a6548bfe1f7e616afed74a36facd16441156053d6f00b1d77a778a4f34f6bce5bd5891f0a723248b5e2fbdde7d98cb976c749d6f3a443494cbb022becdf797a350fc2ebd8389c8e16c6d68173cee0dfb056c0b34efb2c718397a76ae956e1cb4fcdf3328eebbe5bdbdfe071d7dfb0f7e18ff582b838690a1be21b34866e7b1d257cdb9080f948c0f29c4bbb304962d613ccc60c0fc94c2d0cc3acfe207f7084fba08f475c654cf7fa38db21698a0c435fcc8a0d48178260594c77b83bc9a3837122f25e7e61aa8ca399ba1ac2bf5908e24db933924f5f32af3ecc0609f2d561fe61ff5c1eb6f8bc44bbd5a317acadb89cfe76392643d0c292a6fd3b7584dedbf14b00620ed3ea273619de98660aa0588c60eb9302f68e1430893b6588b842eb233fbfadddd465a11fd5dea411767ae9dc6b9cff6dff3e3c5b5bf2eea0687c826902d61cfb29e6b7ca59830b5dc2b4dd3861a86c0a2865639345eeeca3d122f81b6af3853849d885f68402bf14593f114be07d2e120cd702c7c30a07901b0c98780e5036dd790f02f38baa35204124527703ebbb5dc2a10e21a2bc22dcc7dcceb19dad10b2c301edfd9953a89a6b4e6d2b6e329e6f6282b3933b4ea0b0d3878f2039b3f7898369294a7725b6feec6fd5bac69a85511da4cdc2c11388bbc2f5e98b7f3283fae91a1cee642dbde21f8e6a09a7d01301e13a5410106cddb0946c155bd40a643be9664ed627010af734e8e8226296fa0d52b7b6e38af42f5f5d8aee0167af74778194710af52dd34bfe5f4eeb7ac51956a246846036833f87c15064e66cb7cd5e08b9ba0ce87d226cd06364d6d4b1175b7e4fc96ca63a26091c51e0e45903e4e80179310916720b1a026eb86c37ce33e359e9cf281005583fde242215c32cd592f94f681cb6c1c18227703076477ce41dde2571e47ee5f7bc1c33113ef0ac115f23cb0ce87883965e98380962e5858891c98c619072fa429c102ebfd5be1fa8931054f8b5b917804221e902fb6af2643245850648dd4b390728511732be224fd7d21a04d130df4c8073a5dd964a5d27298a035f37df98461cf1d33fc1058bc397c4dd599a34c4c56bd2585795113da78fe8e8e7c31e560d78b80fec2160b32524aad2e96d14f368277c7bc012cda16ce1d9f69c309b22536cd3067a5486129f5b9127b1259874544089b17cf138a43720bc5e2e5140b370e9817c5a27e1ed995131ef703d742e93d651599da1f41b29f65236c5f94acc600375a2124c3377de68d9129c8861b697ffdc9c2bba7f1fa614c44b6ae2aba6bcefc1bef147faa8e92f52d28b3d132c2beb54a9b8b1dbac6052585f65e7dc3d9afdb15ddb02c95f7aed23c8f627837c3e8f5dc32e33a9cefa44739edf1fee26f257f7f581eacdf4c72c3148d22923e83b8971d29bc5755a7dc2106b4c8a022778e16e90d17e63e276eccc8099838fcc910d0a484109d4ebdbc12d66c0161ee27e56ed68bdce9b93a77ffde9b254a43645fdcfdb1ed85ae435e19dc545faae0781918f12cb957c5b11c5f54532da955572ffb65efe4ee81c62fd647f408635e8d9b94df80d87af71ff86787db5a4f992f139ac40a29da883331712b5c0f34ee5445430dbab987d9db0516e95170ca46bff0b3022df7f8402681493b5eb9a463a6b0fe950fdb8fb9c7a581f548ecf502f2bf9a0b7e6df12fd5150bffa973b339eec9cbc0589b335f0de8e43b11bd5b4b9f5d0836b17c53df73260ca21b0b806f02dd81a49fd8d68ad14932868414e8f518e035820464f3322c3405f99f9c866ea637dc6f4314265730fbbb0b053ee0ccab0f7b1f851b85b264e1d1d67c816e48adc364f9c9c7eb87c77f43bc1a5d802840b4b2f8537b90632569cbde019b37415ac28621f657f1c12f04df57d1e4e5a4facf21f6522a81641124eb69bbe5915621209e04f79290a8f53bd392e2220a65369e45e02f6302047b437a6f212788dd9b9be0e6fc043779ef9fc34c96a47e96cd8d27268fd9458b4488b7b5ec3194b93e8a125854daaca3409737b367501988e3da40cbd2afdc174f008ac0f9b7891e7df5aaebdf0cdfa854710e26f9c2b4671c9a447462553cf657feddd2396bf96805cfecefcb52e1b63f6ff6674b05e095b967b687b9fb03497e6fbfaa6b1846cb8c08649dffb42e48750d757ac38ec25a01110e217412601edd80bfa611ec8d7fe1a67a3d40903ec3d6b278d12a372830eda9f5863a15a404168dab57f8eec1edabcee285cb26498af3392092a665a35bb419eec9239cfaf6a7bd8b8251b0df8c9b1086f359775a4c7a8821f8d1bd446173671eefdceee22f1c3127c5f1a6d7e286656280a16403a3333ccaf98ffe6d8f0049611bc5333671a2d68a50c9da9c6316eb11db72aa366ed78b408f4c75c4fb56fa40fd003d240effa78e9875138e6c26a7671a7714821ff4b45526fe2bf15ecf2402a5329a7974bcc30c77c51a96b7a17a91278be3d81286a61a2f53b74dd421e05c896ee0a876f2b80d9dac28058665cefcc9313863b32f9e5b9de3b8219c466891d308408d2c181a12a089eb5256339158d883045556d2bc400bd797dc04255f79e60a9485f347c2de0a7b558b0f2b7d83eaeb8f05d44222508db79dd916956744d79ee1ead6c4896158b7e421060c7c930832060a44cc41596291ae670b70382b963156d7a7d3048920101a159ff81994f96d534171fd45b7eeb4e8e81bc160a2494f47c4392ec7286bb579cb2cba4e7b796dfafe1c68ae044879f588e5e95aa8282568c340d13257272725a9b792b971e29487bb2347a1adaf1be7137335f5df167973accd5fa275362943f047dccd33fba5b326f5cf450ad5c3f81ef9acb9a1bc09a5004b93f3e48afc74da30885fe82c1fce6a4a67b99be032d266cee2e2a64aba85358d4b05a76d3cfe25d9519418d260aec1370ac79c11d9f3cf446448e833d43be7a9fa2d73db61143dbe9507ac3e7c5cceacedb574f923b2e58d92e4998dfb44a386efc22865da83d7be60e09cae42c1839e76f153cadfd3cad5c93869b51409a1b8693a2e108880fa81b2e5b5120d9b5a25809b472b0e5473cb23774f458b472bca656a7ff059e9c7308ec8557a205fde7babc9c376cf602659db2fd0f6f3b2abab3ebabc1f4d488341fc88d47de811ce719e00ab469c2cd81774e774fa452ed9d97317704c043293076b74e90cac7e83a45f2b0f97201a5522e4e70a34cd790a784083b408bb24db16458f54499eb74013a1723bc1e6acbdefea853c334b9128309914d0d41dbfd8f71330ec41362d2171b9f2c47f05c89004b9096d0f641b601d333546e378d7914ea83f67e37f9e4e416081ac06a3bfec3d9af5f9fb9096eac52505138301dcd75043955dbd8993ce07a41e78011da0d1121bf50fe7d5c3c53587819f7a07dc1969e765b6fe9fecb3491ceeffbf6e1084d53e359482843098dae380c32710f7d0b140ed02850d8e425dcea6419d05d98b2b44d08d684cfcfce2720da6ae3b8f67848b588d4567e7e40a196ac0a843188f702e0eea6e4803fb62c6318766556bd9c6597ba9e5bce76e3fa45dab472997cfd19502c3f96b283759de271f7a66034d755043df36ee14a30c4a413a1ececf040f642b3a3e9715a8f94a824e81c3e4178182789432ad645388f91f0d7503590e93469297db851b1887f19969dffcef3d492eae237004983bfc42e1da47a08d13c633f14cffa2e4362eeb22ed85b4104c658f7b46f1d753f85138200a66e209be5187de34805c77fa40bfe9565576bb8cdc3b608a44d1398d63e6118b64cf534d5fbe84bccd83726fde391fd447e30626aa3faa621b702fb25e7667160b64993d983b45ec78414f2e9a37567da23e45c673d1ac9bed9680fb629d753057c80972fd47b1ea5aab4a63b3dde9e00cefa6dfdd5f7540586f49e0879db145937fd5db06ecf8157860c8e511e336849f88d7d55cf1be2913178cae9dfd54bc9805730e9b9ac4c6f360f2996a8aa3df0aea97bdd10c44bfec62ed5fe4bb4921ce98ce5315c24aebaef0a1e2260e33b35ad994bebc0cc165e811dc0faf34ac36322ea5c066e9a3f11aa1ed11bc9425635050ab188c6023724992b5bcbc7357afa6bd3974992874fabd022e6302ccf6306fb5fa3d74d742fd7cc9756c4e9f27a485872fa3c10a16d8168bea6257e48b75dd9ddab82ac2fbd1c560585f0fb9825d22642791c630b9e5a846130b9f08edd872675ade379122bcadfe6bc8b8ecf930d4037284ab2e4ff9deba0cd852730cfd786bdc74173f91022322cf08630a463dbbec5c5bcf755d2c4dc4b582df0ef1da6d1205df3ced29ddf39d5994a40db8e52a6086ee6392ca15cce8b02b03bd768047be4d19a1046c28f3580e34c3d5b875b275a87e33115fe1fd04cc0487ce800c29bec30b3d9a29b7a7c3e5e6f027023a5e7bef3b55fa4704c5019aeee622945b416b6b891abf3898b32e3541621fef99e8451c8c3ae4dc76789f7388ebb027c2c4aa256f80e03e1c783c86471d95dbc01694d199e1ae61cd2c27994ec42f4a883c370db53b0cee382729db0b7276840cb8ae2849b4727e32ff41220b4c96f941fc86073a8e4bfaa16425af6436733b8dd826c270f2f6e0f6e6b593075e3bbd6a25515f027d03f4780389ff34b7adc4004bbcda96576c6f419b05077c79ca17fc1a132735ea6309dcc724caf311c08ee24ab6de97401ea53583c443d56de7bb64d754cdfa656354b14d8a126d1de056d0584a2bb378190f64bf13f6f37458da3a785c9ea6973e75ee9ffc852bd4452c8470fcb22f0c29e123ef848d73c575e5b8927d224c3cdb0bbc048a16159ddac3327dd76ea52f82682ccdc5524123b8efbd9a509686474a878c735744f9764d7eda503f1a79f3e070c7f24dd5cfeaee3bc254fcae12a5685a17826a7330554b09e90df6bcb76eaf4be61aae1f614386b37baafd872f4871f4bc323db5523b1d63f57dfe1c20e11435ca45fe8e4381803548009a2897d7dd3aff3d1619737139e7701ba160d715c528aa4e226c156afae37d9bed4b6e3b0f783405b1bf876f2cbc9a24122c16ec70d16e04617cbeca3dc839215bd858a86185e99155996c721a8e9482bceb8dd14ff0cfe71f5bc71bde6ccceb8d0f0afb0c08e188dd11182181d9c85bee3815a778770be536124b5417a261f9d67422df7d03c4dbc92acfe334166e718e4e4e829e69b42e568fa31237cb53a6af26935e140d88ccae84168920b5a605938c0b0036fc9c513bddb5ccdfb1138bc6c90122234eedd7ab7e946e966d52a325a4474a82f04f3d68c20c2c84bb59d4ca53fbaf4070374aba6ea5650311558a672c5b69d1fe5adb1c86f888a6b7a5baf489defeac781e7ec77cc89c010c16c94fb36a4542d3ae288616d9ed4ab355c2f2d33e3bc6f1dc0aa8350c25053ca564bd2b3f8deb98a890e113b971470e8640b9b6956bc71cd6847bc2055345cd5ff10e1b9867cc5d4e83bc5e7ca8564bb7d77b64810b19bb279f578ab9037b02faff37bf231b6ea23b7ce8c8021fa8a0fb806580afed586d924cb14f773f6cd52ad0fa6d1cc5938661ef13b34eafc81cd4f3f2b9807d15dd0eb6c10cec0b6681e82a943bc2d0376e60f8b5943c50d1a449d076359321dd02c5970ed91cdbe668319b0c6b36c233363756f48e1a5f9c1f689e384a585b07e5aec31367b4196dc07284c5a1218641f87de92dd582d592f1fed64fd0f10510a6ed721c5c5374b543fae5c6f4019853e0f5fd4e02fe547f6fcb97940a6e7cbc8788d807cd79bd1cd11b966f5571f6f0a2f5dbabf75ecb4c5e8f9ca6bbc0bdb69090b839ae427c103d070f8ecdb2d2fa480f1c189db79979d7bd6126982b80c7cceb4cbe5be681e3d4cb11ec1ec89c17d822e770d516a908005546b7b0a25327926cb4755047bb1d1ab6969ca00fdba034d37906d923ca5bdb80e3d3d2e351143d15b7f9d1a12db07f1c6ed82f1cacac3c09b5cf7bd344d1d069e0027e0e54fbd9c3030d0398f33892903e1e948b3573aa71e8f51db09891d4464aeee920ff9871c49d95a099e60aa36e82d00b6b24d10d6db9393b5527e5731da16a9bf3c5b5467533e06d46121ae502ecebc507f42d156fd86988f2771dec91e2d1a06eddfb399ffcfaaf13c422c4d32d4275f07bd016478da534928d403a1350ef147a566f9da8a25813b270a8800bb0d1ccabc15505593fca0574cb351c023bd1c8d3187a36dc5c9e06724ce640e4f88bad7ab714108debbbbb19e423f4b2d23b8bb70a7af897df9a61c071b6658758a59db17b3a849ca4a843cd7a9f81c831679c398b629cdeb75581d44b23e5b870d555eaf0b7e19a21dcc5c465ce6c7ae2657a30087ebb27757f82fc9cd945afe9e73e1809e27dbb1dede8ba9efbcec136199fe6b831e4fe10164152746edd56ee14378cd05de4c8915a700a02f6dac8032aeaf3c491f980f32ded9092b00dd5d946f741ae064545d9ce0bceb97e967848c7c1a97a45ab493ce80af629cabd9a67d32e5eb18abfdc7a460e435fa586f8713f276b7194e5d5c8c4fb3ec00add8dcbc527b2d32c7cd617364b98ffee6ebca40a0d4af453620758f49523713aaca234378acfba05cfc6268ee54cffde68358a6a91bded549207b944c1f5282624958206d76a57c4b205bafede2b984561c09f5240fc2b592fa54ce097388d222138071efd36e7be75d5ceff58cb60b7507065bb2dac5b9f1969f26afac4f8e7e1eb6906d3c583624e54c8641ec7b81f74bbf6936a633106df5d004c20c1936f466fa9fc45bd6ca177f1368bbf4db89cb5bdf33a4a088f8f0d8cbf73e434e49a1dc91d73f2e4acc112f81ea01e586538438c227a413ce54417b67fd32fd45db7aacba2f07b4677257ddec963c408c6386e9d6ab3bc1d5f2f96239fce88507af1a0505f960e1693143806b1398ef5389cab0a6cf8a130da5bac44dea2481405ad2d8d7ad19455d01b01a8c366d9a1c62eee43a1180a67243b94ccbf1d9d3c96fd5971afb66021cd2c5bddff1b6bf0fbe72a84815eae562eca9ca95743ee4f692ac12fded2ae24e86f3b3df3fc68b77a157d5a5107ee487937ae9b3dbec7655b672baef32d9a2fdc88eedaa207d935a385274ce42e415ad042756e1c6d8ed50761cc904ff34c99f5889180dd7821346acd13cce5852211d5c4bfa12158feedaabbe6e02a260e415f70f092ee7c27327f58709f8f95379a17ae82a0f0ed4c2cf46484244d76a8e168484bc53da4119a7107721f38e886ac320237e20193f68ad2ba09cf43d337bb1989f097809a49a481c70a3a9e3e42eb4174f3ef6ec2ca6fa21df1e2b761a9d3c4069d120cfbefd353f987c33d0e74a2c1d77c52d384c8a0468a22cb170ece4e001f551fbfead9b10a23f8d462b2d70d120651b346117fbf37fd06cb4dc720e8233e29866becc51a5d79e8c9d724fca693af151551fbdf0743f9b1a489bb13275a3052a281cbdf47b1e69b58d748d51c8dd0fecb985c1157f6808769957d55759a72ec190d2c37d67c8c8dfb28cffea28f3195407dabed97ea76a9244a9042e53584fb142bdf93e44773120af0639c698b00f3d91223bda304c120adf9ca5fc94f2b7b97e9bbb0cc508a6a769e728b8a3da3e5ec84198ce5d107a5d9ae1542ff076bb477cd39b8d0d9f53a83afc52fe30144d2b8512f8b98a7c1891392e0d49e044c7d0d63f0122ab561760355d7e6eff6c11dd9d9010d4f8cfa89d15dddb966e0c8db08e7542f551ea7801be50b9a68d3a2dfe02306b5a9d97bbe1c7dd3bbbbff001eaa496b4d52bb1a11c067c9054051ef84f503ba06c017c05203210586a8baebdc3a08edf1cc29e0f9bc25b90a07615733aba2875d4b9aa668e6b405e187fb657d9e538a59ea83d22163f1c7133f0e5876410523956b4f94c161da3f22764daf8d9d0ec00fca0277463c42897594820aafe1cd6816bc9b4a0f95375d3e4871cb5a55fce840762e09daf99b7fcb2c9ea6e80648b1c831bde35a343720391c824a48581faafcf70bef7e0b536c997aa9d8305e5e7cc0121b03c0ee1bd6b8e4703900ea3640b02c97d02539654829cd0416398916d46d1d51c770f961bd2e8f8b028869bff019b3c6e1976a731dbeefdfe2a3078f1e97d660eb276a2832382c05e69d9f468dab8f034e2de316d3c200a12a8c02935e18293c1eb1f3ddb3d08269b0eea830668ec53b239b3a6d39e8e958612a653785e56cd7695a844e9b850f8d626ebded836d984125194e5925128d913ca7342ff59c8458f0837327c502774bbcbc428ce5f4efd34a07f87796742b1299489004f8c9ddaaaae38ab023a6e0c94c98fdcf57e18a94c03f773a0ce42e9d506e37d88e025edb8048f60da35b8edab77caf10334637c2a4f786a91aa4a5c2bd0cc737871ae3fb1b6dcb4b8f94573613cd6b244f23b264fc76d0c2a25aa9b75303a31e434e986b51c0e950d6f449574567eff154ddc0e3c5edacb80c7486ab20395722b58aee7ab207ba5779cb5b0f936e13e1de6a67eff3e37f6d023f350b208c16b861706a4677f3800bd3bbf37ada9d45e09cfbda630d624b4035757fc4d512a3879b8ed6972268a216fa55ccdc673f98d4dbcf2cd31b71f2c49f00aac6bac19d56e7d4425612de4d3b07bfc935be556303e8b36ef362f7be961292be43eac9edfd1aea39ff955567a232d07ea6d6078f24e5b48a95ea2d996348789d175913cad8701ef53975f89abed3e10bfb39f1ab76f13750f53dec2548ace","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

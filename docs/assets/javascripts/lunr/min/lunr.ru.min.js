<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8442a9710c1175045257897bea1cb7d8b9ebdd083696c5524cf6133919364d8fd310775dd820e6e31e717dc5c067fddbef98d07b2df0bfa040a2d339b4f6f0af1ccf4a5b2e73619249e3291b97c6e220c3dc9179e6d64dcc4b7ba14ce10bb661576a0308eb5076dee12ee31ca078696e18a30056e6a4f560bc240dcab368ccc2b90ea8794cb433cfbf507cc0fc6f35b715616353a6754e9367104dd686b4bb1838262d492bfcce3b5547b68c1c02a972e2bb4225a972c1892a707ab4a102f0361bc6620d0c46564394a4aa3b80f0262ed5b7dc7695921265ca50c6986950746d40f239c8e513d34197d40bce8d138b6675661daf18d4ecb56cf2ab97d5a3f20c4c0987fbfa467abc9a1ba2026f9e15d06ea06b1b0cefcfa36884a8e72b403f64e56928332361fbefa6181a2dab25eb543135dfee57c47bea67296774130d7f02cda5078263cff516431ad609367ea918b782c9f81216282245fe879b8782ef16f986ad8a9c47c040998ec8eea246703fe9338fa42634868ec782704684cf4d86a23c2d4534a82b3071c788503450f83640ee6212e8c8bc6b955654b2231e5f3ec7b16103eca9436abb98a357282548bc873fe20bee31f44e9260538004d100cc7571985794d276b5ec0f759e00c874add747e58e99533d3e228da255dcae7e3359e6e4ab063cda20c429456b9afc2269c3ceea355a6803c315f073565e28bd9d91a76ac17d84e0142b27d51a847c8a9cb182ada12e1d3baf2ef59b0e3d8d3f99194aaa7ba11df46d35927839b25e917b2d7012914e5caac236d3f1cd95e54530bcb404e6e93470469eabf4e84c16ea67c3beb1d17e896a42bc6e60e3f297b632a2e7a7e710ae79b66ec55280d1ac9079a27256142711eb962da25cdcc6bd3b3316ebe81503ba5951104a837ecd08d1dcb842bc0814514f69f3999b7d579037d675c1e67a120e9f632228099c82087649c0dd8ae05b5d633fc56e532574312f3dff6805dea60c9b97aed94517da80358b8c536d3766f4af570782bacc4aa69b6be584b37e4ff61f028d4d732945e260e1e4c21e89a543172a5188b5a658b5400f9f9f925fa7237881ea8169f39d637296fd654594e4d2ba4e52d50112f147da77c02dd338e92b5aa273a06076070d638f396f08c997d326344bfae38d826fc3ea35f96d1222a3045b033a27c074920f0c6253cc7809d925238c3efa88fb212a30cad154899d6940df70ab5360c7c3610d8c92726a430a200a2904a790b6c2140a64361a498ee8b0aa835667b6e0a57108bb047ccffbb1b05aebd82a3bba1ecb5ef7d9f6997c62a405ee6bce30294064988dadc2fb769c6c02bddb411763bb74854d06398950a83b4664d7cd63cbd29969cf67b00a9ecba63093abbb71310c6a39759e480fecc29a083132a79983b3e86267147bc6c62f799cb1bd17b14f08242102b16f9fa49bcad0e7aac78e5e15a5585ba497db67ebccb8cdf7df6cf85f6bd18e8cec4004542abc5c9f66ab5ccf54c168f6e9183cbbf9600aa628dc3dcf12f769726effc6b8de9bceb735e628030807fd1df35225fd56f4f77f0f724e6a0109df693ed050ef843d0c901de9e69a33c1f14ec627b1c21c7d090e7fa1648f67124016b78f306406b4c275197dc86233959343cec92959c9d483df4421184694e20055f60395892899f8e22ef1d7096cee14cd60300d1036e1e9130ff54edaafeafb7df4c27a070f5402b48d7da7061492969c43ff1f6529cee16fcdbb89836603048eee23cacc1efe4e33e718ade46efc90b8241e5e0dde713c2ee65e5dd2c6f7a2ec04db079541bbc2b0c9900b17d608d39dd2fb1159d3cfba152ea19b1958431bb0216ef562246049a8af5aaebbf9335a734e19c2d918fe0bf1efcd2e61d30986daedae58ce32e3efb77d5817c30df66060b08c43ce97dbd5c8a03b193e50f2382f8201c9d99c45bffc544897afb8acc9205f3f27aff715573520a4afbf17f3d88b146276ea9105a864d2a97996c9eba94caef3eda07b1316bf5a9713bf5514d035fe7969a3dc63b6175b0c0c44c20602dca6e555a35bed1c72e22ba833b11dd8c960cb294d424e86542129b44f56a939d959875459c6643d351173f63ec35460786512a11de8eeabf7705f90c48a2411c10f74ac87acbca276c930dad6e185d11461725d9ea16e33bf1b8e466d70e040bf248744b71fc1729fe5312dd68b487168de4c3d10e7053a303f06f7578d830450b2ae7282dde29ecbd669cdeee3633d067b531380abe56c03fcf28af52b2ac2ea4bda6cc3761838833463bc6846f13ffb6b133f8f169a41f87d82dcb1defdb323c6a687ea0f1a41d2796b55ffa242080369c8d21b50af5e47e0205e82b790f2bccdb65dab2108372732a6ddcfe663ea1bca138f38d5d91e673d2dbd0fd4bdbc08234c96a98f67b5cc75d50734de07f92bd826d4307e22b7b18168b5307f67ee69ba0890ef14b3ee8cbacd572dbf360656b1ef2a961f996d7c57534611599bba6879af138fd6fd01e4bcd2547a92d0a629ef41afd0417bed19fd98c61a641a8ed192a54eaad8bcf423ca6da35fd1feab92007fd5e4a44e111f3aa7768041fef9469c116bd7b6aadb39c3fec503778e0f970fae27b35d3d1d9215a8183ca196919e587b22a8b96c423a2a49c3d7f71b2049e4ce342377c1f49fd3979557cc7e7b119737cc60de3a2427958be00a8b7114061fb172f32f28de342a967ef43e145a9d93a6085006227c471131123c9d889eb143c909e68baaea5b9ba8d308c2cc64103137c352444e60f0bce9179d86cf9489759d39529c418f9be99fdba771cf84ca3e9f7e0febe25a5f9669d86b002248a667e904508bc48fb39dc142e7b4af75069a5b1391f78108765ffa08476db9878dd8ec1eb0949933f6bef8a6c7b9dec664bac062516fb6204dc0605ce74fa96501ab1a772c6a06c2fd083dac59f11df00d6984e68aa8bf4d456b774f0c33e4608a7e7208e4b3a7633de20233ff8ee1f66555a43551afd1bbc5e6c051d6a862f0904cf1501e8c33497fa24cef49266f675e95d5e071900bacf2036686e5f64f8ba4cb54bbb639c873e52434ee25a0ea548f668fbf388924f27017f9675dc24aa9002bdca9321b398abe62a6d65442c94ca1b40d83de9da517c895dc7d3bc4d3fd23cd025357a7a2ae1434c85751464a2380551569bc0e8f60a0b5a11cb4a189629d54b7d22abd75ea9bf68c575205bb41585f9d7e4c1c3042355cc67f69913b2bf9907f26fd8b9facb83b3ac7716fca9562ee1f0641e628461f494d2571c9ffc39bd6dfaceb660eddaec0ca368b8edb0110cd146c08e110010e1a2343d72b45882b8353fc48b41f03c67b493fec82949b167f3c1a9a61aa375ae736d4e68e645e81a570bb337f6aa611363fada49371d9546074160391a99dd2c0c98c880a2f9f79f0eaacd33eaf7f003629893efa75e430fb48b7f941b949ed312417e844d45c249eeba3748f510e94681aa9071d92320c16930c61872d36769913c3076f3f6f40b0f39fb9bc8eaf8e1f2d4e5f03c1d5c2b167a068b769512be7ec6825a4ccfded5783b1a8df8d84348f8dbbe367f8dd60fb89d0c153daf65b295115089bf1095f0293b5237b4135ecc427814082a885329b6a25dcd3ef6d330d01e0a9171f78416e63667b181a0862d1a6e68b1d11ee63984222eee18110e58453c0bea4985a7182811d9f833143c8333c48d6c18ea5d90fd4b051811f5c390d1dd7e2d66e5333af3d78343d66b7e820d4a77d75e22a80b26e560894cd30b001c08ec764d9f7bfe04b11556ac1b445cd59d0108c3c3d5b059f10e6139a7de247a1431042f8c4658995c9234184bdccb731cf88b8ed2e23a22835cb2b2b728c83613e1278ffb4372d0c2520e4d8acfaf52572337dd3259bf8e2e32b12f70ff0a536147c95d7e9303d928db0f3b94cd62ff6fe270da17e6295580698c83f2d3f9b1d9b5b0d061a0a7870734caf0d5a5e98aad4cde172f88cdd7c831b2dfc99ef058abe6fac8825f650ee5d0cb0251fb51ead4ccdeff2e6bb474bb48ef4cec971cd2600894791a2f91fafbf1834c33f6c049e08278cd2bba22e5cb67742450098a7dbcf36a8cf45434ebbc34da1ed27df22e0a19b8691c01f1ec2eaae4da7384143a0de96323667d151fc29917182a72e2b65ea673d08b0d334654a2db86084a949dffacb3ab704be92595464ebe7f31482a91a8d5495ad5d4d4dfad189bcf0358d516cb104f37c667e22f395b05f668f711ede5f05b3a2441c78f9f81ef4816a9a21d8706c52ec145a04b3a9315b9c052531abdbe3153b69e66bb365484c073c63e2bd2ead0149acb85c40873af479eaeb6e8e6e687477a72afdc75403ab6b505d0cae4bb0eca482971d6e1e337a58893012b806efdf8151b4d3a567b5b49f8345e25e730c9b4de8f93fa8a031f0cf8fe234fcecd8317c79ec924930b6010e69d58b4b7247bfaed03c52a61ce8b36f75f3ec1e1d5bf27430419c023c0b37509c5b0bf294aca2e7c9e65d398c4b307cfab31be63b03b014f5b2a44570f18c2ce0fe8faff6fce0aa0ce6f92d74dca2810242405d46f9a41ee7a5287424c0af7998d372914b67e9b227e80628896e955cb17e6abf23332ed78e03acc6b3179642be92fefad40c4c8136d3ac8eb384b144abb93b2df9d7855f343bae059e5b980c9d59b80cbc33435f9f4931dcd58fc3bfee650432d628b0a7da5100e760eed790c1821d465d11a7c1c10786989f8e8ae4b89829b50bfb8b95c1f00115066d7ec81923203df8da800721258acace966976c78feccc48c3bf7184f8df53fc2de166c941d1b62429c517762856bcc1e5a71f7a527efd34680dcfb3482fe22c667c82e50dd85a1b512ddc2fd29d1c98d028dcba21930bc03a70b4434dcece5bb741a89e374d900e53d9fdb620455bc3cdfa92c546b2a1c4f7896d94ab0aa2f8d96c341b5269dc2c131babd8dade3251725d2e581c09659b1af56d6c219030ee0372980f24935aac2144d31eb86257f08498da98d6b9ce829a1f5641794ea8525267129fa88d62ed50fa0a812b7b22b4413496b97b4e082d95d4a9f7faef1fb39b41d4ed1e1ce53bb9d304a72ea2ff0ff8b317a3f9396c6f2f56a50005a01392a4d20d330931ddc6cda3dcee0f4ad2401093e8deabbb9e452c4308ef1cc9c4324b6e4967ebd9b5874b1aa8e5443157744c49ff3563e03dd7560fdd444d49c9ef91e423cc188921a4e3f3fa41b6b418749e30924d1895d5a5aa8fb3ae699ab5f6af6c747b06fc28331f7cfdfa724e4b0225ed3f84725ad5a96c57225172fe9e8ad2b4a20304bbf156f88ad0b63d8dd87487e7ac798d3089c625b16e8bf597511bf0f1f26b0ec3958efd4e8caddcd79797793c1ea28e384dd3bbd5e493e266e6c43245228982330e3b6ac12f3dd30ebe55970a2740646aefadce9176c63930873f40022476ac96e78ec659e30ffeefa1880d2ec7259964b29ad11e141185a69515bb97fb75fd94eb67148c42e822fbee12fc568db402e2a7452e997e8dfdbc6a48cc4ca2aa2506496dfaedc8e422eb0756200ffcea9371774d4cb61ca1608a1f87fb8922d24e853f5400b90b749501d61a4cfc7c8131ce8a3838dafa71da8a722f56e3e06b2d8b7a5e704024fd038cfad1f4cdedd6d103e55c0401213d6b476382ef75427388d02629eee53f121149d13cc599629629f3a4d53c9b802ea93c8c0a8d9ed65f0d092be7c50eac7641d1740f3cf39c880000e29927ca2afd793838a97769254e61a3eb33561790bd8a24aca67d05ba307d78f7b1876dfc1b9550a1bccd55c55c7158859110e3ae1e5928313e6e1bd200ea5f191003c91406a4ba51b87ff4db864862a92850ce9058d3ed3635acfb916ee672ed508353759faaf9b9efdd1d555bcbd13d90f2c3c37c297ab63d8b663836ed33b9fade1a5b9d3bbc4fe60231880e96a93ed422e9eab3e8ddcd7760b2e9e328af367b892d4e76a2b2921de876895903fdcb5f193fa5c79c1bfd23cd39839da237f9226a042d07973e80ed226ccc9109bbf67dd7ae47ddd750f5a45efba035be4f11095069b8a404a97e0646750e8040e56a9436decd9547aad8f90cafb130c2671c6d64f5a8ff4bf7fbdd60db8c508fda66a9c933920cb601a8862bec254add9905288178ae6bda11b2215d5bedb5bb16e21707cc627f55c9211c12bdfb1eba180b7ec4ac87728bbe79465bdbb29c4b151e68d512ee860beb8d75634616730dc064dcf3fa62ed6c3ddb18e2301c057e508924cba2c9617251deea97ad6b5b6a35594ef572480d71c3655c9662ad0237cad09d588ecfd98fb67cb7e4d751dfa9f8b5481ff07ff1f89bbef29c137bab7aade08b0a6de29fcdaea6bfb209a8a7b0c24b423146adf22396099fa102af568acaa288a5dadbc11c97ba6103e30593fd224c2878deeebe18e43882e94e8f1eb1fc3d8b62f787dc276b59eb3df70a3e2577e8f3790fc1033cbd9bc4fc365f123f91ec89706d5ef2de8cd49b24915703b390ac7f0567e64c759bc141955609a15b321324c8d01a45422bdb385771c238d0d0c2e8ba578b14085e734d9a2ac3bb455fd28dd004f7e85d9726c9fabca4cdd00a173b4835e354e9420b59fbdc70941ca7a86b14fee7be6f7122c1178f35ccba8a4342b9ec6d09bb4b6b10759d7472803ab0df8aabcc99b9f6e00ae83c258ebd735cee053757ff533f8dc03aaf83e4aa4152f2ec30ac67ee2dfc91f1124d66623908931e033268015ed0c8256568ae1246b887f86ccebf45f61ea800597246d2d806c55a021c0e8db2bc9103f21e289655055a3973303935f3297beddb8bdd8ef7dcd6a4d34949b30349429e4d28b2ff5d92ece4d679d89b0db7cc8824a84c60c73836c7a8c8f398d136dbe2ebf0d0e6d7b105c9978614b85d315bf178adf9ad5804941697b7b9b9c37745ec8905f8a594aff28900c8de6bb0b87ada1021f1c57656efa97480135d0353933684a33193cc540b2ac262fafc915485bd44332ed576e03e85c1a8d33a5232862bbb1da3de89a4405ed5116faf70765bb4788a5e8547f6c03a02358cf91a3e505a745c3bf48f0de44ff3cfac0bba4060c557b3606421009caf39fe357d82c76ad4d2bbf46d7308b151bcb3d157decac15f2e1e8119d75700b33b3e3402b5596000d06bbe8d90df36ba70a0af9de7a11898f8badd2bcf039306cfd5fc0d63ebbe58b2df4b558c6f99ddca0c837d378a961eeee456e124d72d972c6a93215a7e3d683da039bd8453cd03f361bf4dcf58c5f0ddcf63ec172b79c79f971e76269eb6437eca64c1f5d66108dd1a7ed61212dc5af820dbf2136fe1fbed702f4da55e3e76f1dc50198923af1c3c30f2a8bc76f0553d90416b18aa478a0a2114b9f4abda2868606ad39104f51b181f2b2d610f05b9d4d9685ef6edc186123129b3c21bbe19988d08d2a5a376e25f5b081030729d3832ee4e8f186c1ae44f9ab7f7419cb2283ac9467c097f14654515f3ca0442b2931c63a3e3a0542410cbb784e172e45d76ef641f1bdf8dfb8ce7b3e9e3703774c39a930a9e17e6b894503a2964509cb9807b8d7a713580de7826a6eef2c925d8da6a115f9a794264ea83ff3a64090505bd33d43706deead33746bbcfa35f77598d3b3635cef2f0e1af1e0aa5ed0ee3ce3551ad55631c76f010eb900b91fad438f1bce1e1e820d65ba45ed9f9ac21ea8ef31ed0cf065334db4a916fa7dfd78156e1a7353277675c8219a3bb8027040ff296a6b2daced69b3de958d199d4d9669ded4d3fabbfa57f70c8844924f071e6f346a5ec45bc411bcab548f0338c066d0bba579868da81ba3f12707b8b507e5ddbc0d8d36e7bbd6586b70c82103f1bedd17427ae60c26c5cf95334980837f3bfdad9dbc04986ae23e494100eb74fa1c8d555de60dadec3bbe674f082d0733f8d4a884ead719fabae45397fd413598413a5b716d8cf7cea20a2abd5b46d4bb1291db7c57a51450aa31234e4e5c5010315cea989db64942ca74c615b28180b6b34c362fedad0d9726765946d62ca72755cdb4cea3da65c5e8cebe39a77644a96d7137d8cf4c1280f2528755d9dbf7346a4de010d287abf5603b1b20249c92abde1bc2f5533d4790ca3dad7c493f609851abe28eb1ae115b9d81b73262ee925f146a7e78c22ca16b73c4278b2c4522d07b7b9964fd245569e24ef306581b0bbb9aa5089af66d403adad7a4ff1618aad28e6759ad908e3ce0e2860b55cc39f5cfa5844ca695006ac3a12b99e42148bc2474418795dccea4246d2977feb3e8d6de7c34347978f7573a40b07f8080d8f40519c347dc9223f10ee0fac361e02e78c8d7374feabcbc83b83f3aff46042925688db915bb06c5babe3f90b510bde17ddf66387b0e9c60f52167e97c07ac32883ec238a77c231976295ce7d2f4e52eca8abe1695db1d266c1a60a541ba7ac0866147d52c77a61877bfba534deb687929d48f4af98dd4b956b3cf5e4137cb2815a4e71e52ca9151f0f356bb2baa8c5c6ba9407b6caf4d427bb034eccc39d9e658d653bff4eca0b62ca0fd973a9124569557fb8e3b3ea212aa0e8e99755b3df9b84cb5df02c2c58a087047b9c023806261f816638b1ac4fd5a9bd68e2737d8e69b1998b380c4328c702749df6210bb19bebddd622185840fc8f4d27fe8ee7c6b2e851ee1e1d9c71b25074848906733069ecc9b187ea50c194397e567b90c8f5d90ce27b801ff9b6a75f87986f6b7c2b97783c3ed7df6e3188565054309bdf59f5099e413d49f2f04cf40b703cb9639831cc36833e6fc75029b83b54489b05d628f3efd662af6e230c1ea2817484ac6b24ced925c4cf90f7c864ae7d3d38de51ef8c00b4165ed7c4e849820a97e50f492018f01c281448b921e33ea084e5e3722d719c126f297ec477c0bcc5a689a32c124ffd18d403587e85dc07b94d0b31b74299724b8e1e6338dc1e5ba43394fb843b3161c33cde3d280eb69a993a9e878424b7cd59076a89e073104b126491724f1805a5426b707b2266fe52099377758a823444933edfe07c7b184b432bd40adfc86673222edfea7e19968f67d9f67225db376bcea692d0df70684394c564164f90e4f66e04cbca69f3dc24c13e5bfebe533811b6ed1e1d284a114f03b1f5ebeb27cf9ce637c784262ce739678ebafc3b1aa954ee803a9083e2eef97e1719a5407d535b9a9059f2faa50d1ea587c025b2031d106f2efa92d7401272a610ebfc1c58533c71292d155f3a161d838184883a965e372e3e8c4e666e725c63ba453773baf8b7f783283c9abb3af436d93688ac27e63adfe55e1dc8661f9a009c410d93696151f7cf095604cc598c24576a8858a6e248ac4575c13d914a7bf641a0dd3d10503d07e7bf15bccd6c8e7222355c45060a2425f563e47dd2bc0d242aeca08c586b949364c91577f4a66f296bf5c8d35f62a2f45217699a67d0263337c5324975fd961a3f1665ccccace431e4ea5454c364b80cd8f21e1f9a9df1ae0296718668ab5dc377094a3881e299d8e6d9d9a97d260240b73e250417cb22eee0837ab4cb921f938b11a862f3f3c148a6c10ff27e6051e492dd0b8799ca553dff6fac19a939ba0ff71a3d4632aff720c5fd8da7bca3c1bea66793e05ce7a410a21694866bae36be0f412835a685cc84a52cb980903d78f262e1694e5f7387ef8f8f3ee3e2504089e9d55f12607554993582347f1e6c2bd8960cff7c963231e54858e63d87210fc2422d64d64ef9ec4affca688896739b33357ffac1152aad88320e39e733af1ea04e4e0b760d16f0a6eb43fb82e2148cc7e66da50e77ebf09f0cb8a066c609269077c4653e394075159878e1b0e13d3ed64000e789625fed2aa68c3d08e206f56d90d020ace6071afeee29c3aea99d874eecb7a19e951e650b633e2f642a1f9afd68c9cdc69a736849997e0d08bac3c48ad744a4d618692106827c0aa4321545865cfc70c5a4b080fc95f9e678cedf4bbbc0e893c01f2ac4942ebe772fd8e9658d61de722eafcd1ce0e2192b0defe096e242752398984b2d2ab17957021a625a1984dc2c0721d65ebe15625f8c92acfde02de53cfd4f34191a8231ebf174a6f41e71da18fcc1325997f16d514ea5ec23bf27f999aa174627f215867991f9948234bc8c9807d96568c88cc1727f308fd968c2e52a465705b6135c8888aa49bad89cc7650ec0f2005e4022d7f6a9be5514f35e0bf27284277c699e09ab1fbd90b3bc4f8fe180e39dcf227e5d6ec55cdf1b9047dd2d28ec5dfd140b21aae86026a81013011566c636c5fec40266fe75651976b7ad84c9e62d1a8b4addbcff00f548bd887c7d77e72bb850ea63876a51f4692006ac8c9e5c76161cf68ac84f075af0000dadc61838c53e384bf4de087bf6c47a439d961118cdf097f8beb5eabccd31de5ea5d94b09c243417c23107636996de488093f223091b5d1eeaa3d004446b3bdf8f7abc4e6b9dbc51fd9bb2509dfebee0a88763d287f0cd4841b0b39edba3a96be8a7d2f4ad15fdc6bff87ed6ab578cc4f53dace17789e8ae8ff1cbdc45377e1b849d5b8a4e86903e1a371d24aa18c2512638add4caaccaeba5059f4ee87398505d8f99755f88705aa8c93df58c4375e192fc1346b9822ab32dd98028d795a3962d53b411085bb9c76f3de250f415ee40f6753186895d13f0282317a8992ce2aed4bb3fbff31f16a87bd27481d27ecc746bb04c0335f453c3be8909b7c36cf3356ad6a01b082f572f4add4a0ea65a236ebbb4a917c80d959564d01f058a2a662469fcae53a2b71b814d29f8ace84d1f9dcb6d95d21a4b0cec28bdd332014bdb84029da4540a894510939ae573aca6c6cbcf335dbd45aabe1459feaef90c9c1a659805a63b877f7e50d32a8e8453f33b57cf88277c685f7692b396475105ca9126781ac234f84786a534c45eb8f6715df657953a9ab70da909cf51572a1045b7b86c634179442756b7c6d5be073bc7b74cc20c334cd8a8dd86b99e788872a915bd79ca99cbe5ca452ae73617aba9304d00b53eb83afa966a1b2446cc672651bab280e8e68e09408b4f5f332f32000334df0f0d77d9684e435d964f4c2232e8d7b2bca35e5d108b494ea61a750e10db4538fc8b93a89f7a3fdd300b9fe28754820480773f4e9f041d248dfe11ed432fafcd65d65d1f88f322777b6e821bfc33d5946fc75080c7c6338a29b8131318b342ca917f5f8830531060a5f649e11aa6b6a685bfa6033cb3fb0ce9829a2944aacb980c2f74baad2eb2c32a2c09487b834aa72c948a3a757b760d92b22dc2919cea0589eda6088b14227591459d6c25315441ee0705b05f164a87368ad5b829a510715dabba4ae0ab199ea59fe66f66ed85607534730373b32b9c3f4acec6ca3363a46c6cda437d9d224ef89a758e422238c5ed603a97ee78d1f8ac121cc4eb677418a9a3d22e46c80f624ab136131542fd6120a9e42ff7bcdfe917fd8f63577acf8db0f2095de673946a56878a40fa12b1e4bec5ba71ef8068927fd96d3d41aa1117713f6c0347ad9992ee39b960d25280d02b1babbf4cecd132988962308bfcccd559753cee71acee34bf2b009b05ab28bf2b3dcfc2a533a3197a77fdb5ce46c7dc6742e3f243b58301c483e2f251b6536e1bed2999014b96d5f565dbcba3ef858bb41547547cb0fe6571b45ccdba0aabfd8e152f0bc16d19ef83d925a77d6c5f150e2e4c5ed1516bc5cf44107e80f28775d408f17bdd373db6d16b8d3fb44ece010686019d8d2b055662c2605b24a90507b5486b8205e158616caca4d9109d7e722c31db128873180d7f19f3fdbea8b80eaad999714789abd11000e4568440eecb5f90ebdacbfc1cac3249d187417e326b97554a569d8e12390ffd06444b9f8a25d95ea18905ae62929d011e8ffeea053d17264998ca753a7281c90106617b69aabc18f2dfd607b82630ea963a7cb7288f8247c5a7eba6433b0b71449c5eb26d2fe9f8c238faf8631cebcc7ecb6a9b1ef23455d82599ccdb5b653f83d98f2584a21f7b243b244ea693ed64fce0eb6341f84c9a934946057cc0025ea3e8a9b1f3fa5dde731321a3461278807fcc194fc53141a6f6db403108f874e2d733439446afa8cdfccb0c68bb5f4b59d40d3b93959f971eed5f2bb7b3cac99e9e614936e10f814108c26aac41569d53ae57d64ccc91d9df179cadeffbd9c86bf120273c366a8dc3279f6751ba5fba15436828b25c2dc3a9b8f89e13c3c7b3cb719d65c007264c903d62afea5c8556a328e40388a52fde5025ee746c985dcf770f346ab456b96162ec68219354146f8db3faa378c6b579072b19478fcbd423c5e4ba7e864bb93543d27bcc047eebca538c61443cebda2acdcfada83bee70c99d5b2c4861626452da7a79eb772e7c075b8b6a1a8c853dc15b2a08cfa54a17753c546eaa4273aae491a6193fd3384b37192c85df27410f45ab16bc475acb08d5a7a1a65be4700d498a7e32fbe99f798ab350690673017cd74d801d3dea15a298fbe67b6d5286ba8759dad0a099920629f441a3acfa373bacdddac2086385f6218ba791e0df967c0a179d91a0dafdbafd033ef3c3c33562251894f0a2dce3018a9333c1fb9f47a8b3fb26f2e4741e78552d5d5604cecead6969a66c9bd5881bd67270ab11ce24c6a49b2e595b9d4b3f1a11e7a7ebe263a014c0279067a390a716c7dee735d6c9f1b820ba9c7e6a3b8247286e2a311c29a1e0790a807979a2d3ebbb5f23add94933ea4061ec0b281501a89d4427cfc4ca4b45d10cf54ffaa824f416d3c6500c5ac98c54ee3f45efda814d5da7803ace72bc643998d51a60f87345ab984ede93e604844506c0f8b1b042781de91712e6a4afdb79292e2010a447f2bca2067af7a9eba9633dee21b3700ddeb049cfdd89096c422e6ce7c5a8f416f556fecf03af267e3f1dfd018e2badf12901f18c61a181f3620eef1411f097ca32ebca241fbdc25f3547908a50b6fe282655347a35eabad5d0ffadf555bc5b8cab5c5b7225a3ed9427628a606e34c8e50d3df21d5a0fe9a1630d076da314fd707b698eadf7cb31313ab2dc99ccc67f342700a8128c60da4ec4d1d642ddd208bc38cc1dd828de7a12d4cda3f4025edcb449287316ac9217620d28dfe7ded9ac1711dedf8bb81d8858b24ae891620954f2404b4f4d649d352e6b555926e27faaa42c8a8a7fdd43fa8459dc3e2dd2e756359321760faf5908a308a193de0b2a8e84cc5c876940950b4eced0fca9f3d549de3e8c1428890f1189ed682f0ccd2a4e49e024ee0e41231a2f7a67cccab9fabeb68b8822f1ded3a4a2ce92f2496685679db7b5458e678eb9fc53da33fc62f9d4c50a33ade9cc37669603bf8b6dbf290a0e0a047158cb2835e7481eff3c24c963c44c696f4e55f35bde672a831f6849486f5a6cee680e558521d201d11a66f050eeb3c9cf33866ffb21610a95173f3a53032213c3a574c81b108cc47cc4204014592c8b73f03d03f2127677f004c5c5b86125e8791ad293b969cc5e117996280beb023fee09b87d523da21141e8550a8e9fde296e588591e29185f35c2f8a196d66d769f261b4407aafdcb6c7ced4de8492d2a750da38d03065b7a59f98ca476f14785eb0072dff06e1842b1a39f9fac0b1c0aab292bda3664c55e65bd3f70eae029be115aea79caba34422c5de0086bb0872e2f67a1d5170ea4c42c91de33693619d601d7ea422f102c000f7caa4fff5610d43e45e704364e204a7759e88880eceace85533d7d0c4f592d3b2ded072fe5ae669da20ca69ebc20d0525216d4c38b8a9dc7b020ca2ea4fbdeccff29a6cb87f02397ebc6b69f309a4861a86a1815ffece504f4a2e55fa4ca12a61f5588575c836acdd71d1b45cc98ef248af0f215584d2ba4a23e6c4896765353ed842d4bc8feb577dc1051a1628154c23641edf642b0e5e08a3ff18d54a0c1e6e07420a9b041c014b5a2887bf34ccd9d5e7d809960460c71759c1c4d08d7ed50963d77c77f5dbb606f8a89eb91420b04134add4da90c2966cf9b7f0c0a4dcd068b1ecc26a87784fd791b48e6193cc664f8aaf720587dbbc5d6170e693a5ac28259e0b9b106cd3b957c49583a21c2ba8c57b856a0068921f65699e1a8859c4b58e1c6577696416abef043a22e3c402ca64ce3571a1c7098676c10d5c3c174dbb87b3212039ede82fe28ce5111037b5e5222f82373391f2c1863307c28fad3e45e1be11a446bf0955d54efea11e920e52fa6b69f290e54e2fe8302d1ab5e2b8735b783697dbb87ce7ad13c305ced5a8f9cd03e8ef2b8b8d32b584da6a38911e783b0fc4c59a5498d54d154d45a39e7b42c68a8e3b77a8c65c27737dbde521f09cb3a077c26b5f9857e7e49c69e588ba093c60e64633e5f4570e436d501e45cc95e6b59a5db231d578cae72b28d28eb45deb779751cf0f006bac1e391ebf4612fd5988e66fa57486e6734f2eaf829de38e8a686b7a0c78f5af5e1318850d1a095faab57c7a86d93a9704f8ccae6e3ca6a644b01a8c577d8b16442857884a85b025fbadaead13ed31957e538eddfcb2080471c37a2760a203c6e41aeef0d609e915eb5422d16e72ab3f6cd52f9674e187879694aaf331e26af417100077cfff1d817b96cf71f885fd2957c36c42e36e5c16d7138810318fcb338","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"db2944e83437ca1aa063632433feb34e9d4450f790763b330de17ff737391fa4888496591f5ced1427124aaa935391d55ea35fec34eae42bfd71b9dd1fa40daf719f3ecdb594b348a2d7e9e3638d3eb381ef2e44b20e788c3d1b7fb6b8ac3ffa244b4ce1706260159dbe5d83fa46f4335130819562a90ef2f0dc81d4b7bcb5b7b10c505fc6fc6060bccbb82d5993a28927b9bd1974a05bffec10bc305dc2895cc8920d23c2822db8eb497d4fcda59a614e65de1d7532434e01baef1ae22a65eb92e639d3d01c0cbb3f784c3f721d7da6d7cf4c1dd1926ad84385a86da9cee0c237d2c21db132015854131c680ea760ce07ad6a6625eb09384f17151fd0d02203cf5f517c19ab99f391c147a6ce19058a21ae4af784b6bf82829d0b972885feafcb2002c919f633efd3e4884e82b814a91848741a5ec5562dfb96a6e33a0b99dc61467fb1e0de3f203641969f318b40547c6578f0a0a5567147469302e08185880775a42d406c9d29c080cd0c54bf9ffa7cbf4e94e5e752cf9e1cd2bf0dd0e1d02f9435668b517f259e1eac6ac04bdf5d59c7a17226cb72119d893e8d715953c243d8cf2bcfe9b5c85b276a8c688167246d94a55798328fdfd9ff87fa56ba99942b2533a75336d52c4bb65ae94701e6d22972faac675fbd22f433155b9663bc399f49793f56a14530867927cd482ff4aba0696f519df77b958fe64568c7490b7117ddc641e6a89682b943cf84e404cbe8b457c3eaf9c327c5b0e20705c14bfe931e28a8564486bc0d210e69b7c9c8df8c8e1769353c50853099f5dc96036d331dfaa4faf6cfd809f6b73371a16df4d46742a87f332daf59d81829e74200b2059f2c81148b8267dbeb1e3c95f3d60cb3b3d4482b97b86e2bede52e64531325a4d5aa9c5b5b86850266db5a085f05bc7ede6f0a9dd6fc810645a404464005f0ec6821a95bbb571bc5a90c6458d368060551fa4c063bd815a53bb1fd33749b3531ef5b9eb874ceb3165479be0aa891072b036dbb67c6ef6d8dc0824df9ddca5b16c717943f001686bfaa235942f74e7d5aabb6599986266a0221c0f14801c385bf1e0147fd5969d2c5878f0fb7de8ff7e591dec2aa08941b2fc6ee57f389c42658d57916d8743ffb0b0d6c2a243351d00cd7ca0dcddb0568a11fc3ae632fc46543dad7bad9a970a70354f9a8abe7beeb71a4de137780fe321bed8340497b34d01311f46970d0b4e743920bac12c020260b765517959ffcc4bc16a5273135853623409a10f1ce4fd21c165b4ae49f1eb65777e0db69fb7a31d903165305c1681cf1b1bb6204237fd93160bf302ff6898e6d8384e40200152a931ecc62d94781a265d59d1cd55b63341d1f6fb66fcc9887933035f724b2c9e1a3b99d30b76f9be219d1e11efc02f3fa791506ab88fd53c1952399b890276ec850056155a7d443b32d8f06d65e1b672a0ef39e83f1e8b999877e1a987472bf338a694932311b42fdafeacce3dfbb4685a1c6fd47fa4959bec096e9607438dc1cbe73c1d708d322d4d86b544418fad39d3900a277846dd6ed75e7b116413b7eeec6f5f3a0316e6462fd5f2fda1adbb7d96820cd103341d60641b3f0865c3c97b1303c59efc5a6b82f9ae41186a076079320cc0f0ad40d85de96eea90b1abd4a14048d9eecef14d803399b33ed3e383edf23f73df1dbaff5c11d1aa32eb785d386162cca215de0eec94eceeb2324e5bce11ddf25a31804999a461307e8eb84f6ee166c3b2d73010a95969b6cad628f01a133540fab034f1f4b79baa66a1a29fdbf843c163a13ae47f20ac71072170f9ad0d5dbca342766abce20556a277daf96a3cd73e3313fced99c2592fc4e8a77d71bb92eb697afd3cae68b4c6e0ab665eede59c5a9a71442197946e7a47e1799afdc915880cd3162ad454ae5dd88f3b7bf0ee81b94fc1ee57eec762e7b52dcfdda667e70d6f7ca975deb32bce9a751b501271e4310d676aa11083955a7ca2e88269dfbeb59f8e5067a852ad1894d562d9f080bc519ebe0ec7bd03c39f35a228b6ee5499275b4ffec420363852dc4f41e9ba3151606a91db65d0cb84c965d99a15610220714f9a107f67c652ffeb0799d67a091d54e3c143bebd0d57d3a71158d42294c7a0592223af142d2344069404d9d475dd65e0b2771fa1bbbd9338365b7c905fda54f0f74ce3980a6b502d1b0906de26bc04ae5f73332f2b992e4381cb4fe164083ac7f6ad66bde013828485d07c7be144ccb41a2b16138d4754e77a1e4045d74912925fb82360a84990afbbcd5f9d0bfda24c82df2b10fbb97506230b7e33aa430b16ee1b29d61aa9389aba52e9937e024d9c989a311835e10ce8a7ca18349637794ef81b658683d06f16d4bbb424414d77541093093ab13b01c533fe429e6c006f87dc00d3c6f55125058542067afeaf90ddeb06f780528e122d98db2d82d0a427dc06864eb4d9e40928352083c9cce249931d538376e6800e054471ab34563802e7534cb38901b5c3908f8a08ec0e40d29c55a934bf44fc601a599b0e980dcf60e416e0fd5ab249ebbfaa0821d5c1d254801a98994e2a0bd9fcb53edc0140f8f8fbf034b2a9ed6f64339568eb56c80b12e97ac7cce42404472d39f2a8b297914d8461178714e54e229d3a7754e8d0df208920f32a973aaa15ce65ccb40bc0790713c5b12fcb7291ae45db10d07bec99b4535bb1429e6d15adff13959b08e2f671079538fda759d614833044c48764040a7318038f83177a15f2caa8d68866c51f7e6b1d9bbd1829b9b2a1e96f6bbfd7d8106d14f2c6c645a4babae4ddfc15ac69049b8bebeb6ce572352f2eb8ff3dfc9777a8f79703c9f0de80c30f0457ec88562146614f3e7fbfb27ff3cf1ae515ca6ae657b45dd1edf27c0ab4c34fc02c8da5e4cc979c6ca76574af6ceabe67a6d510ab83c297030a9117beed639a43038f74a7c92921c229615194cee3cb9384dda9aa3b3d5a95384b540a3ae4de7b003c07f742c8f6d9581aab4c774f269b735e72b58062b156235cf5ec719fa9596952fea43344d7c011461e3570634f92118686768bbca7a9dfa2c4e1d658e1c28d6b896b11d1d27896d9a9319f02bf636bd1d7279a321b16e710e51cb5a9b239db7fa11f784e6bf3db3832c8954100671372c4891e5b877c47d9f2fc578fb48286ae5221325f261b190d9b85efb4de2f6c2c57640354b1761839f4cd33a04779cd038395462c495a9d282e90272f0bc0d7fe3122fb3a981872dd16b5b45b56ae5f7a6e79ad6da8d6e55b7bfad0fd8982f7bf0353d7c0cf1b1492b3180f3839c712fca7eae68ed4ef4d79ac90f2a9d6182cd11f44f58e13691d61dca584bc65c85fb958a99aa31524b3891e802a3c4a20c0a9af5edb9caf261f4c0505514a13b1dbf9a2f331bdac0b28f1c7826668d4e2a980e740c28f45fd79c927ceed1907284da79c2e5445a3969870b42b86c9424729c9f8e65644151b1506c8d1a36ee6e05a5d99966f43afec9b7a3c811d7d62254ecde58cd25bf87dbbda38285790395509d26ba66efc25934fca545463c2b794215d85c0cc59045d565f46d043378d20fa171c4c999a8d82d5c8ece67bfcbb7aa2e4938fc6fb785e2d783236cdc5a724d9532668f291eb0c30e48fbf160983b4ac8b9f0169cef29aea8d1702f0a14e02086ce6b396d232f1ef4df11d041ef66ab20117da79e1697e36568bd1a1a9424202605495d6b1f395ac6d24e6838a8aed6118ea4332533a2aa21043f4953c7699e131f752bfdb01427c5cf91458f9a82a3f9d446034961a3fede6e32ff816b1cf1a3cff7970b5aeae73ef789d8ec83063d9ea915f2db63494a4ac434a641624fcce7e219fbd7a606dccfc652c132e5f40dda85628edfae74bca39430de2d3c515e6d7675c22f0925d6e276707a89c3344420dfdb1e6b735a9105960c9bf95a94f11a8a27c50fb9897858dc2187d6a636d9392e727658a165e6d65ef2d2bb064a68d5dac49a3134252c43ac172b0c4d37cd45fc4672426e11760b729010c8706e0812c3472c4eff861db677309deeffe0cdd8f6f183001ccf59757af12f16e758bc9f356fa81f27665f4704be535e5089147a8f288492cab4caaa53d6aa3e40b6cc2ab1ec70ae73ff372bdf95ebc149e30d1326b5305a178bad20df444842fbd29317d2ed83c94cd02442ee8ad51b5c5224bf34495c377aafbaa0f04ecfa5e24177d9dacfb32d7641132fa5b16f43e31f82db91979a9d3d7f6ec0336f1576dc74e15bbe7cbfbea817301e214678e872b067de9bfd551590494dcf0892f8f4354ad8e635a76e3ad13c29bcdd6f1c9ee7df0125f68c256727abc661929146acecd9e2bc67b2d0d7cf832510b54e8572ffe5e3de804e335ae86c476e6cad67296c5da4e1047f14b17a7bfc4a0dd409f656c0513c277706a76a5f6d0a4f0a30a7766db8ef8ff93034285d0ae7580000b105e91253adfaeb52dfac2f7c4115d11b6805061e40f23220b130bd040854fc81452c5278ac90c382a15b37cb948f2a0305ef9442870d445e3b0b44e50933eb093e4db313878708eca1b09ede1b2b4e3018fb4295f5326a2d94cbf24f7cd93ec3e7c91b7a56704677497b2d5f8622c5bf375cc575b176b78ae23956dbbc982d882d6860a027a214c04be4fc0c5a943d0c747108bd6f86e2c678717471108619bf65ef1a1effc9b3cc5f27bf884228eecbf5625fd64c774ef4f093db403ab537fc0514079184d54e6a0579a1b7ad7cbfd30327f7e702fbada7aff5e6c2cedb1fe04a9c879f5bc84f65ea05b28473c36098ef31bb3b819d0ae74ed26329e8c4cee905b570cc8529d164418b5256a577365abecd095f5353dadd8c8a179acaf8cbc832134159f865fe1de331a683424cdd7f1a8b5b861b59f74919dbc343937a718a65a7c7e16880d99c8c2410a958735ace5e20331c7c988d6e68620b3df8d92a03ede5d9c7b30c93e67fd20ef8e0a96ce82cf9cd9c065d985c407bb5f28aaf629a707aadc7cad2b40749dbe507a6ff3671a700a530244245131cd68442ad6ddf3d7cd322b6f78ee58647e92ebb97964c1fef64bd91c36af59cf60af15ced6322fdac8cb523b0ed66ecd907a923f6dce95209122206288ec738ef39fb05f2fa296218b72da38acf34a8e7c54f1b2a46392dd615661c5451bf41fdaf2f7e5f79e541b1c96070bc498bf0e830fe9d1b4fcf507c6d9a44cf2eee9f5e552386f318ed23a85c8e9c722dae0eef3b3d4b11942b3e8c9afa9fac2e122adbbae703e797be327fcd10cf72ed756fcdc3219a945d2777bbc8a2e4d2feb9990b2843841b62ad34b58f0ff71db55decff2b3896a491ca5e74be02c0bcb5b7d0546752b2f0c04d22a2e644125f3df0a93e047ab6dcf292c3a26d79b486c53658c3e33e85700387546217cd649661bd288e2e49a5d5a75e07dab51349adbfbd12f2bfea4ae8e2d7529c4242f5f7d577cdb99a9dd1965f168afc5cbd25d6435100b08f5cb7c06d5db2103f8b5bacfaab334c7e32d0d2c8c28e4de4bd3a34d0b3a252f2373e844675ffdd2f690aa4b28cb48dec0f86fc3040052d177ea91506908899d27745de8123ffaafd2e5a09478b287f9f606fa43aa3bbeb8f6e88c9d6f9df5e8404095177fb57ec1a928e93f0653ab4cd7d6e1ac725e87e9871e9c210f1b601feaa0b4ab284721f9f600d7e7f11999c9c1cc05eb4800ad2bfdbf5c9bec2d9550ae94599c842bb666a03d171fb5fb62b6011b261a8c725a590300f78d9b409a37057ff41336de7e99affbed190e20facb86e503e64fb678bfc374d45700114471b17ffbedd4e27e0d45e082ea8c0e045f88c2fb39e614609df2a5289ada0ee5703f46372e7c9715e38438e485e5aaae6cf4516345d735bfb96749d3c41c30b1d976ea3b6f87208eaf333a7d3d3ff6713bc340a42c410b1147eabbaf7cbb0a2aded41e0fdc1c96437649840b1269e1747f5d89db7ce48ae29f3394c42828c39ea3a68aae3af566ee72acdfe30911b9cd07da8836ab0c7f9120dee656b568586854cefa43ba1d9c55e0cb9c752187c45a903c442eb16701582fe7a292fd5d6fb64f9b3baa788270807cb2a7084ec282d4084a0a6132be4f79006024ac852188d6f981f539e11d33dd35f42955995ac9b5ca9a376d4d6ecce8ce2986e672b97bc25a321ede9150c6c320345116c56b9acdc6b809f29619980b515c500f5606aeb6a2c7e7411cb48ba7dbe6784e52c24d0da99b37d59cecdb960cf742e6260265222a4de9dfc6262d11a1c4465ea45b68f67d83dffb0ebe73752c140d9781d1ac1aebdb0de82b9e2c670923d42229c67ee77cc693a7763b9739d468d3b6b5334e12d6de125f0b3d7037657e582b17ad16524c508ae742fb7589f6feb6695c709fb9eb6a7a4b8fb25a680a84976e5dbf83eb45347cf07d39f1cabc7d72ad8ce8c15993eb60a85ae3e5d50134b7387efd762843b2a2048873324f9957a9c804ffa108408659b30b0f8397dd3305223fd1bbfe87cff101cd877cd309c1ff9964f7782e5b737a40428dbf41e3b2756306ab0e22e2d816bddd5f244fae5c6bd99a354079d63fb745e591e255ba4fe5fa4660529d7a1b6b981e8954a1e63d63ce22c1a60dc72aa98c9714e8b8fd347ffbc85a945bcbab9a5d384b43e94e30d572af84279d68a26f3cd44b5f58ab120f970d9a39dcd4e8b7fd0dcbdf0728e7a6b587f51c8eb3f476f474d24f65beff28e73adfc77bb7f77c14f22ae4f47658e388404e0472ee318b40f1763a0fcda72a821bd2817e5f2ca90cdeefe699c805edb28760e0d9832cf91ddd3a06d9c33e5b6d84764bae496d3b0e1736307990831afb935c13d85d41d1ad943093ff76ad2eba5e5c8a4e2fe9a37a6a2d6d948819e4160b1e215929d81c776747aec86f5023a454962ae07a223142f965b00ba4b08ef560b578aeca2914b6e6e272cbc06c886b101dbb908ead961236379a41ff8d130b7ac66983b710ef26534dc46ce2da15226f53b95edaafcba4a27f23ea6bf97372c74d1762681f1c951822eeeb3bb8d97c9d858d7bf3975ef879a76c661edbe3b4c455b184be6e29ca4f63f398ecb67fddf419ee884714474b623abdb64eae41f7267e1c8b3e9cf009d892bb3480f22fa88a06019bfda0f074e1a13f43eacd80b312c748fe70da7f4de6f209d4bc9ce8dd6ad5cc732511f5ea1e8ea63f7ab1a65f35e05bcec0e0a979305a1a67b8cd26883ad67c14880dd7fb5fdbe0d1bb1ee40cbb5adb04121b498664f2f4189f89c7e13d63897ac69b36b069663fd574ae5b876e7d749799b5577eb249bf819a1da7cedd8985cad28656abf68e1d4f9507297fdcca2d3d4a25c5dcaac0692c3b929a2c273dfbad6b64324daa11b4e075ffd4f760344d48b756f2419b0521fb31854870f037f8b68f3c2ae549f9c50865c44d6ad264e7dd920d620f514590cc3b71463ec793a236b0ccbf88101af059fd0971489a391fd13080fbd278b0e919f65b41a42b31a8d15e4cff557daf7ed3313ad485f6bc01f662e890b74b2dbb181d5b7c61ce77d2e247fa39fb729d4e6d98d1203e41c3be09442599ea8277a50ad50bdf632b80bfdde1750dc0fdeb75ec1d701b23e071dd08e00ba6afd8b528a450831cc26b01a782b7480cd78bf4389b81839437084afd414ca386063d977380ad7cc49273a4b91a4c37706ee9959adadf2576b233e53bca1de21ffbcf2f49a522634797e3e886d85c6000fdf9c2c36a767a6942b24575f14174dc011166db5a82a0e83e3fecd9292b9ffbf022c635afc00ac3cc6835c3beb419f05438408d306836ec7e26456e65ee7d6be0e6735e64bded27c0977b94849a0770b623f2a48f2e8abc8eab288772f07a34a2fc9dadeaf7e9bf0f7e1846817159b0188c0b2edaf2f9678d08fa811af2b8ee24596d721ea6044b93ac4d84a947beb6230044559323c1c5bc1b95f003006e77ede7949ac6d99fc7f1049586d4117901071636ca6be0d0e174a7033f0bd93bdc0e600477e6c3e45e41bb322ffc8887cf15a86f80d0d6c9e42ae5ff02da4d4bebadb96ad83023d73af9992f8f082ddbbe61d1c37655842a71094e96a2b6ecbdf22c6fb3a3e0404192611b110f623e5325defcecd4c3ab48e145631049b6b0c5e2fec51bfd11e6edc33cc7b891bdf54087c6121c8049d87bfb0eb6fa4c766dce6c05da76d263f6c19b6f4a6278401d2a5632af3337f354e60ff7ecdbbdf58c2ef58c0a7bae34f360b01133aeb2f52d05211ba889c2283a44b1eb50e4e5614ab1cbe7a8b6cb09e091345d16b8f36e53830a58e7133a779685337b640dbf138ebca89e59782c387a67077e7503736ded506dc3e17b883accd80f12e2eb3fdbef26223dc43c931b7dfd812647b311873674ead68eae95e571d7801e9c5582ce3a07871f0aecc68d232ff16e79bf599f64de564ad2ae0e80beff546a237fcf0827a339df03310abcacd084f717a1f30c02dd463158889e2733d298dd7c4f3e063365296b0a073a4f82ae50a429ceeb39cd83b7ed26d62a89c5ae96d7c0c9083d25dc15f9c9dcabbf79c4963acee008c640a4b0f46ac4471360d8dc07e09caa477e6d0912f629c3b5b6cd60a57cf10d9ec569b9d9024e3a4a767ba23eb669315f1da3e2d5fb305fb018080c43bc26b5afc7ddb364dcdb6ac957a077c655b2fa5608244ab63ff4bc24050b61a78417fc57096e3c7d407d59c63aee1b3c73215123c667042c0558a1110d0ad9d65ee09e5cf91ab5d2507914a07a9b9ead65a3c9fa84452e9a361becac1d6445f843484d37a33dab0455856674ab10b2ba89d48429a8a9bb6081d605481832a851dd5420779454b4f68346255c6df12d9940eb76869efe36f2361b0d2456c11d463dec4e057d150d1a1354af2fac710bf0ccc813f542a9c3fb42f4d543144ed51ae9678a64d689c25704717ae85f2784a39208e2f0e9fa18f514d26d72ca9a7c84b0d1b9f3c66a726e772a8369421381f38f6821c390d11879ca78e62484c5bec788b1db0bcc8ce123d163c44c9d636990211d2e7002c97183ab7e6e2cdebfcacd94a030de39f279d9a7b6d91be395bd6d24ed787596597fa4cf253072fbfe0db512af1bfedd1852ec39f140820c10701faf7d5f4e067e199db9cca1f335ef47fbc46a5329ef8d2358f98af17e0a1d9b8298a037a4c4189e0dc3a0244ca053516fdc9d7b075e4e98debb513751a3d108772401162d180f9cbccf69064c5adbb5ed92eeba23a98d9a13fba09f89f77cb353263097789a1ea5d3035fae51a8441ada36b761c0dd55331c05dc926e53a93bec4f9adb8854f7a1c09f83f83ec9646f02c0fbde72ee69b22f5f717213cbd3fad077dc667e20f84d6554cc6cce4a716308b0a648a38d3a5f590efa798b21e831f113f6188a4bec1beb3a4a2acb22a80471e09fa1f038cad8db853c5959bf71c090916b94f1c2f2de11867d83e0c4b4393f520fc63bd3486ba82ba463d2f154d41cab4851d2e6fbff681471a1a1a83cb5ad756b5cfcce85c19e333264bd07e8c49c6cbde39daac59979588517444ab64d72ac29f8a3d87e472584c4ba5b33135cbacd029671b79c92563d5fc86695087830c73b31407a475a2dec3b9015ec89b3081e3491736367e642380392e3cbccb36cd9eaee5f9a1ffefcef4c67370ed4d9b6961fb5a951fabcfb0ff8ca3d8f2ee3bf7b61275129f21200937a6fd56df0b0857e06e59bcd1fdb9ba1463106722fe1ebf13801abeb386ae7919dc6b5d3a65fe4fec6cf34896ee861052d2625242ec73e12814789080e75632bf2b8a1f35efd3454a45b07e8053fb1de512b4468814a763a9397731931afd35b75f2c52469b7ac80dc5c3c0ee261f804ea0540eefd0b50a5614aa222495bafd91b4f69b853401e0fe6e5eaba22a922c77308bb397ba530e05b06cb6e8a2b0a4bb826e1f688d8dcac52a72b2cbf447fa3c408555c1eb77af62710482a545945ee0f0f7f1a173bbfbee7a39b5d4d69ae66145dbf7a0b33a79d9d6681ae2871b176d3d112c352a0bcbb1e1635478039f33717a4b23e8f8dc90097baa0cbfe6e2b420114109a5e3abc4426656b5d1d9826590d6bdd7b8b8517db5f08579ffe8c24a46a1fbba069fb6f69ac3927f04818432075e06cd6a5353931a7d508deebee99c3876f1fd72e3bf17404728f28e8eba86db8e04643ab37d8b6534200e42f46c8128288cce8d3b4120b0a523114cfdd953fd98dd9fbfd23083f02dbc1ca1600a2a1a14113f0d4b85988da35f710f84f0f565fe59a6ceab9a6079c6fbe51e42ce0d0ee2069cba71c0539115d4b1856f2587ded341194586a8d959a3a814fae285f6bbbf3c2ad2afefafff755e1028a3190046cefcc84cbdfce5f23499a8ae1496756c9b9d3d159531ada3821decb66d4e9f45a6c9f4f0e633671b5d45af362f245cd0911d15c58e1d90ff90f0f07a4e74e0415d9efea41d0dd6e78de58bb1274f095b914630bba73ce024366abdfb765fb54bc55965fd14d68c7ca6b71d9701c3d746628d48d035ec7080d89f054c498a709800c69ab91082353b6bbb35fbe1b4f0c0b94fa84b8f2a059fb1f7bf534906c01929ebee850ee610167377846c27fd9b77b0682d56e05a741c912623c1c35388c05872d4c1e557e93d3818a2e2ff5f90198d538eedabc270fe022ee3cceac79a5ab4d6d1f794863c7de9f2821833d28a2d2ba4001ffc97ed94f3643c527d20adb0bc4938b5629fc0ec456a3a9ddb552b6917f68534d41fde63cd7d455e878b1a2b8dd0bd8dc6364b77a74f169df36ae3cc2ac19ca38a77abd46d1f05ed9def17b24f1e04295ce4de63af030bcfd9e7099bc9f1b16ea491884279dd3ecabf685f9350c1182e6a616877669d0b7a9a31a1529d46131aac1edd6238130c6a01973b8393252e1df49eecd5680d353fb15d53ef3da219d1f6bf9ad3899cc6f931696e18e597efe333e60df9ef28168ea6c05a919b33bf1a8dabbb0970a47b9fe0c733032678a17ac73365a057539bd30ae64b9023ca6548504c0e9acbcf3d595dadc47aa7ad7ebc370b483f18e2c9c18b8cf32181a9f108c9d4d781425296ab7d892693dcea6afb10d2029f0768478578e77fbf4188aae7ef48d9716841c9e5dc448a64bb9cbb074b4bc4cdfb12abb96a4c9f4e90227710103cae1b666837a0fb2a4469b5ef3e8cceba511bfaa1ca90615271630a79420ad9fedb1a3b69ca22457222339e6716369465c7ad946f5f9c353fa354e10961ad5523a0b80d3c5d82e78983b73c137b254430e36cb8030a058fba9789fb853d3cc26813a40397b3bedb2f3d68f2b4ebc7351a6f3d7b0fc1195230baa35a0bcf64ba850a61845bd1d94f1c247cf0250fcf3ec1c764b9c7b47953c7e3a21a5196680a0d9196865b790ba6a4f1747c234defb41448ab65636d7a304e749ce25e2acdcc5314e5c9ae5494a4dac96d4904dddda4ce9aa34f3361778276a7833f2f122d311498a69f859468dacdcfcba945d13d993453f16af8010f687604052d7cfffe9eb933cebcf52dfa433409933fa9930e5e3148432f81aeaf1aa6796221dddcbe7cc644c07950b6bc7ef948e23b4358ac6ac9c080d80a82eb7b1863f27fdc32cc68d278348cb2f0da5639f406cb3f7e2dbfc75c1db7525e34705c849eab3b6c5811dfffe863e635b7eacf5c92135ef95a75573b00d661f4ed91e0dd22c34e8fd079fe59ad92ea9a5e963bb36838742a61e58c8845aec5e6ae6200171f9f610d828017a7d9e7844d2ac0cb8624f359d439b254e95f27a6b224c5c5abcb888757d4dca07dc866277b1a685ca7a0db9ab1b510c22dabff8c6c6d341e26a262a48123081380a57f719bd9a75c81444ad0760a21b5ab198735983f68754718906c1ebfb3db189a39f3eedcdcd2e9b3ce83477b72c622291dbe8b190f33365e25df906258372a8bb9e14f4912fba1664b6dc22aec5404349d5bf3aca18664606afca61798165c7f00c790f737338be0e1e65194e3bf8fd5a1a147d5355da30c73aba57d4862f17540d97ae8b1af1252462027e3aae16ab8846e4061cb13e29c83e91eacd96cd52a7bbba90920b84828aabe0c90375c8ee229dfee22a4e1df8295445d4f8d5c75d11833c173c1d3fe2a0082a5ae969ead9d06f6d5b01c44ea79487fd5cd943b0c5b906764adfccacf7131e0825894ac2e0b92688e1c530d738baedd5bd7e1c3c98e546f95d4d32dd02a55e9c3c11cae049273d11fbb2c1b891d9f7b14d5bd8ff70c6da8625192de7056f11f23b500dd1a5533521f9a23e3e46f3618d988adc10ea7bf779996f9eb73ef430bf30348b0d1b1233694662afa9d7212bba37e7795251aa5d92cbdf29db26f33bf0aa752d80f1dce403fbb4bd63566eba6485c117154eaff3649edd8b194cc2d8b5437d2ef33052857a26a7700bf613f48e18324668588307aed8c2a9432d5575df9a3ce348fae997be3752faeb246412b19d8f527a2c9b8852037fe0340f59bd431299809fb9ed2d3eea858626490fea6057b994ae2e3b15cad3348ca41483cceb262b02b9aff113a579b8743d35bc7397a58169fb8b6736ca266d49a698cd1dff3c8c4c45a1e5066eca83b157688fd00c9f02453bd49270f7cdefb518f82906a1c18d281b0b99088e926514921985c6cad9c2cd545970221e2cf07de4803ca1bf385faa65a9dd0dded06f5430bd62e5f3ce2c0df9aa360c20221839badef71a950e8daf8a28970cce767f8267e9693f92f5f1e20accf3951d7720aa4e40ae7692341fc1b006fe67fbf94a07384ad72fc1fc87c8a984b8e90fb348baad0be93cd3aa23bb7736349897f2cc11cb6a5a02467bab4896094f316ba05adfcad131bc012c1770092c3896f67c73dc49e7c66b075641313c237b76fc7f89b28cda85ed0be619642be16353a4433fb121f72063c69a3409a47fc13440841da0d8cc0e4b37d26bd600d02cc9d3ed5db71c56c305770ef3904d41f334141345e43424063b4a4e31831491108049e430591fab0ff4e242e7e5ef6421aead017ecb429b65680a660f1f5da1fe10601f7d74cdf67317a8cc1fd80a6da24e85bf990416ab34a0eb2686ff92b46e8a78fba3f5270d71b119a5d74eb94a9be167e8baed0c2f772a3d9822a1f1aab414a7714b5b97911fd8d3334cf0f0e2299c3388e975ffd6e8611493380d4116205dc8ee6bd473a18e1d67864030cf78f4007a4aaa896896985415fb9263bfaaea34d26decb1c8cbdaa737d7e4d01f8db565bf88e08faf6f9edeb0bf6ebc7ea7981e81a14a66b84653a72463e65cfe726b28fd71c03927c070e1c8095e93b9033879826091927d2bef48bf83e5d94e780abbf9ccc72d2cf86afe1a26712cc7df0c2db46cfe0afe0e49870a8e37e528a45292c8f3fd83f22351ce6afa83afe206d467a4ff93afa211174f3e9e183da42872614123e0ac28aa2e0ecbfd620913b2b2d5670746b07976393573e9a959bc6cd525c575c93585aae94124c85d15602f76cb5e74eae3deed14058f228518d6e8f073f19ee4be0ec8efde5ef39b399079cb0b67323f44e4d7c4f0ccd0d90d2cd0b926128a3ae94f21e3115b19b9408e5dcf93b2143a8d7f01d19722f48dae281bbaccd2a3f33d96bf8b74e26ac72ab28301a4fef7e8942f259800998430830c36d2fb042a33541c9755a203855059ab0d39e5f7411eabe5e608358eb4e84efe0399674ad3d03bc3b25eb146cf3a814ebb68bd1189912bb62db8610572283dc7835e076ab7097f56a8a67468b64cc4be7bd01d4f10e37d562ffe07393303654a51d5c11d048d11169b7f8eea443273eb1a060db62021fdbbf095cf4c8e5eec2d1d448fb90d63b36cfe4deac6ec96b5a23827544139c01571af0f4c97b48921b7b6b9f874fb1e05a395a117dbe9b04616fab6be8c38a4bf268cb1944d5a43d549774cda11892bf4a641eb723894139de8f630eba76eabfef862d6268b343fe17642cf17211c09ace6ac9fd264c79ac3250b6f707a54c141d1e8761384cd0ff69a02d4dc112e28c67d9c73651d94ac3e004c536fcffa78fdcbeb454c36b872b80e5adbaea05a1889a5e47e629bd502551f927979c18da6988a9ca128daf2e5cd9cd4ee2cb38daa654d3e0488d3a2c78030e7e8cc9022883fa99ff428760e03fc01ccfcc4b43c8411fabc1c42fd3c5706a24a6c39b7f523c3830e6d04030527b02bfcdb26a502260ac075d43113c8d93fa79ccbf370fe0b85d7f7b54c76d50d75ec8c0a651784b9866acf3db049219422c66e28f078ecc674fd4be85f1e16807b03963bd801510af2fd250040a8542d13e2b07839ea9c5485f30b49f026ea3eb8e7d39f4c5263d77f18a824c0da1df14dc4441e606fac944e1fe38a7986178b35392eb9eef3b02345a5b81d60cab91be31c9b4189f24a22b8760828725ccfcea20668e7e09f2da3f232519592ca96e7f94660ed0dfe104fff8a8f2276249ae4c63968a37054d606d60698745cdd5e0d2b4a845cae5ec30c1a9d8175b56847e8892b2a97801c745f6d928719dd91819e4d52a39d393bc6e98b64bc685bb8c8d07a3aad3965d1f97905d05ea6610c343c7aebb996a658fce85b0c75e3c7ad2485f2bbd445875db256506598c4ef1f98b9a3b97784efac72e2e252c29f8f47d553f5f652d623fe879ac222ffea235ea85ec896f6906cc8a61361423","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

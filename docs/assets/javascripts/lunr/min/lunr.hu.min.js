<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"089fe45be8db58609957f92ffccc3bbe739b131fab4093fbfe87d4df322c995986282c9c05e00d749a55cb7304186b841d398687c9b3baa6222023b9b8cd279e7245e2d5114b44fbbbee4cb7d7f4e6de98cdea1e27ef31680e660ada44dfdbea1c40ea0f3e5bf6e75b5cbf9bb9db6446151e1213f52851f7d40efce6826f819213b383da10f8655ed3fe4bfbf75287bc50dd3aa2da0dfcdfbb7e16bf7cb08264ede1c952b73bef19872f871b9f5674e38bd81b8e04da7a9f46c951977d688b50bec7db3d6455e165f302eb7e90bff8ba2ebaaa0c4f74b48f4b501b22829eb8a0b838df3ee0db50924cc045cdb3436e7611d8169262d89c5049fe2fa5fbd29fdf74badd46d2ff10bf27209cb0734babd2c4d2b707989099b552bc6305e8de6375b5cd9262a0119f7daa6ce5a059840e29a3d47069e31f506975c50906f2b003e80a4a8b8522d6bf5141ba9a75057a5d854297f241ccac8744a15cb3684dede82a73265637b39efe9318724563e866284a1b0a8de995f40638d4dc3ecc1d321283c613d3f1bbb5074efba4d18cd2236711b7b994ffb138b52def38842f6e5a7ed8cc8e799ec13ca6977eda23446ef9557b878cd36026422a15e8928e75592a46ce766fff46e5bbc22b8209edeabf05ba3c1e42838302c0fe6e2711e68eade2ce3b8507923d5ed28f498c0008254e5fb9b469b02abd4a1c9e77a976aefe5a73d83a4e13b3e20c666b2759e8383e088bc87b9d87028240c35bfa59a0098b1179c3afb21a71a55f454fba334575962b2ed580ef7af19436f09f6251441a4493376debc3db7fd7b96acee8da44cdc7f0b8efe5fa4a09a859984b7d506ba68b2106686503a448e8d5ac54941fc8eab3cc0cf825177b8a7ffd70f5a322bade02cac19c511ecd872be249620212380495a6d2ffcd3c5a73229aafbd0721e79856b915cdbea2c4ea69189ae7817847f603bb807b57e867e8811988c91500e672459a4be91d9ef52685c68cccb2e959c16aabc6437b2a8c41738bf3c12ff51aa59290441706d2bb23678a20d9abaac580606999dfb8186e34aa9452da7ca73e68555daa166fee2d7497670ed24c38f268a4d947875b75cf8d3cfc75817b0b8f2540329eaf3030f96544f069d6bd83e079f30316159772390f2cd66ff1a471e364a4c205f80ca8d5293e981f774ca66044221c28974a3b5a6b10006eed2de8d038ba7091e42801f4b0063cd5df1783b736113bc31cb6dc7a8ed32c6fa91730c54ce3786bead602a8bca4bd7167bbf0bdde90d97770720dcaee1af563950b284b7a30d12cf928a60a53b4de1a5e011d27302fc273a958c82ba8561a5ec0c980a975b3b4990380dbc3b5468019f3c62e64f684440eb0a44536343b3e4b142771886f0b61c53a3eba5fee1f22b1ee6308e5a1acce3c5d3a4dc2e767a9721abff80cda3586c0ce8c37850e14bc6db07e792c3268f5afc605ef87ff46e7c64863deb1f2df9c77c6e9795f551f6142a26e59809133ed4aae730549b4830c95b1223a4cd388e70ec7629553df7771e6e7480697dbb7fc186c4258e929dd5d59f7d6109717e7e0d5e6ae89dca032c090e9c53146f66dfff2f051b183f132e7c19169033da2e34ea58dd1801938f6b0534e4bab67494f7b18717f04b5e3b2d3b60010be76de442286b0916c78ccb54fadfd6b8a39ee83056225f8c0a4811b27ca226c84224b3988b97c21ca132aba35b05ecfae2286ca58f1a7c8be3cdbaa1066fbde71c7040701fe987e0a064a1e1dcf2bd25f5bab812e15bf9cb0e3628437358c707381e68de67f84f005d9952f9f2833feadeb08dae4c937ea7b41ae4fcd924bc64cf9f45a011cf64e7ecfdda10f498a7e0656dae6bbcb1b94ee421971389a461d1eec7acfdd7843fb649e74eadea7ea38b735f8346c2be5c0e22217ff078bfc86ec4a16d9c0b1667b44e3151feb47ba506ac4e2e32bc8e3a724d9d64ad22e4bf6adb555cbb7c3bb963311f5f003d7ddcce76835626c1f90e5de7a6867494a4c6e8eb639963fdc533e61a0f5da4054b39212950f21035bc59fc4f790ffaaa3dc62b6b1fb1c66f58544837171054ea32e2b52a9ab1c4901d104cfac58838ed3c9d160f8cfc0290153befe769c1820fef4448046c118da5a298727997553ba0c7eb5caed2fbc9a2c5003cf6d54e31ce287803610c6646004b48255dfc1b18bf29333cb12ef6e1dc0efd5a3ee4e83596b196a3a640c5bda3a0d2021ce93076121c56280f818462542dc0ff9891babf75027f2bbcdb4bb366c265517eedf3f316670affe493c0bf549b2d4e53e5953c726301820e5ba477c19f7326bc6a1051996af60fa1c8468e4f9fefa341c72a3f9bcd74092f2c2501dc94b412fa455068258b2c0f0c9ca11d3cc6144fb9fd542923ef93bed932c2354be6c16169c20f5a5e7a06533a8211f84ea58e380e4866232d5d52317cd7aa40c4e81bea0209ad6b8a5ecda500d358bb716df572b5332439edb32508b0ede52493bb031f0a466375da353c3b9909dde0a6ca1957136ab005912eef1c1588c77dc2a893bcb45fa3713f538403ae17f7626dd4910cd07d54770b0e781516c2074bf5799aaf7c4d7659baedf184e0aec533d4905c3e4fcca7f84cd8887e721287f3f6ceb71e81107790bda15fdc791f87cd8f526577813eb13c0cd167df71055e52cc1b8a5b77ba572ec611774a22bfb96e5012fe33a5139dffe9aadaf0e9f839ee09ff4b00229923b81f8d3a3142622887d4b3f69bdc4ffe5df7ec611652c04410159ef84fd7b4cf51352d0db2894a78be4d40b08724c5c6821877bcb38a78f1954d74a8a289cfad5dae0135d70a431112042e316169c6acc0611c8fcbabb094f08661cc370202334c0687c6b6f28d1a311eb20ee7c0a6656b8acb406886aeafb158ac45ae24aee1fbb496cd1f2b27485204acdb387aa5f31c28f80754527f5d96b711bbbb5482d2746dc34579b73a204150bd394c8d88780ae28e13fb76fa7ed27c15c24ac58f52a412cf4446b7330f2b2f1be73697441f257da8e3148b78dad7ed2cf119cd9d9feceecf125c515aaca857b83df6bbcfef124289f20aa04c81a1dd00754f7743647d590e69478693f58f0326ea2099a287582a0f9a856a0f9a63bed6008a558db70315944ecb9d9a15d9f6c20dc49ed263f2136808768a50e9294cd3b669ad66417af874ad316fd705402c404ea995f9167331b28dfd45072aa7876bfa4f595b9b4127f79625d371674e83b014b43777082f37bad552de930bdf89682066afa191f5a111f3cb0d53ca946bfacd06181030694c755481bd7ee73024be8b67ab6248834a8e7a67b9798fc80cb6e2314f6c3e5f696dfe625c27a17cee17650285ae4028bdc3277d58770aa4dc06daf4473a97bb77e5356c3dadfaffa509fbf881046cb5ce2a8aa89e5568764f412998150a36e13f3a3bc04492a2f8570bc1eb0bc2d46bf533b3ad34cbc5039ac0eaba0170b7f29b97030dbec46d7795421cd131a7211a897895f51c1dc14f278720d8b0d88bcece1101a3b51c3601c7d1b2a5722a1889b01f0e460fc284a021c9619c3ae66feab6c091fd39d5dcbf9c7292c055e0a478e4275ed2d4ee20cd8aad1e61e53b3240bbc828c0e569eaf52c4a52af05152f69c4888e11b76ebae0d1a02fad6a7bc28fdccc912d7bb904ee5d4105654b0c2759629046cfeb5b17036a2368e390737a29f0c2466403453fbf0c5487683480f0e6cdf9d59fd27ba398071b5e692ce5e086930df4c850ef16dda6f27cc6530a9105dedc24ad154a1d29a9532091cf3c0213023277e05f95b608adb4c6c606e4d55e032f589a7842ae3d61cb3a3fdc26dc6107eba383f7170be4a9588f34e253e9e5afbb3a933862016084d255184fd7c7a84cc84241d7d9325761324a3f5961f846888de6b648b742a33ff283a6f13318d41924db3204a62e9baa5cce58169024661d5a11943e213bfbae8e784a6e6a111eac871f07db72ab87069801382a9315d1094c8bb6988a3eeffb4ff7e24129d1597a71faa4486429ed9e99914dbebdd10bd6a904bdda6947d64e213ec2ac292339fcd2d26b801b5bdb453b5d0ba9abcd5b2b70c5612d4127afd33ab0a8c739f08ad97e1013cdf285c5e16b84e9ba4c73a53de63496575d9375fc9522d8c355995f7242b6ce3dd0781e9338270e23855c3b17e51c802181695424d5bf2693ffe4a7c19ed4dd9ad06d2e623eaebd9674f20eae484e751b6210572caaf8e34350677cf423089a5fed1ccde8e95aaa6aa744ff6119247e5087f2a89cc6e5d2884273efbf9da87f6711afbe7d20f662447ed05e4d33bb866c287d420d0db2fc9da36c057819a13dc3120201ffac80c3c4d58e42de75147fd878881df52273ca6849ad7e20123005b9b1a8f005769dc3d35497cb60393d3ecca19db927d3d1e8b6264595de8dd95a7375ad484758401513d2415d24b80e7bbb2f51efd9556f3347e864701c5e6738fe383f413f6393bef8413e74eff32ecb27b1e33afd2317850cac2666dbc904d21783b76b864cf93a90206cfdfdd68e28b3f88d705a9cbbee78851fe601b7b1325e6c0df4cf6b3a7e328d703c76b2011cb2f100aff6307742119501a28179f4d1009ebb4b0e78a6fce9a7fa13f7511e2a098439f3edd9761359a1ae38aaeeb4d1b0736f432e75ce64a0bc288b7c87584849ec1bf5d00a7ed213e36184d07a64d73b2eab826307b240e887c51b49afb921a7681b9c7fb1d23aafcbd46725eabb312f582a346a6ec35be7118bc851e8d0333f7217c26683b01b8f87aac655229b277ff83878292a6a9c12411c25a9c64f2ac240c08433c9bb1b5685502ae8adc044aba4a4a0b0490308d50767ee57b74fd478a7b70ae56eeff2e7c091994fa88134fdac6265717a88eef34ddf98938eae50f1bed79548188903035d2b179f14be0a7b0ad05864d8baf75ab45f23bfd1a491eb65d7caee880b342adf0b2794cfb286b39449bcb672b13be64fa389ece389f63521f840c85e724a8b4dae346695e53ee44f5d0f5abe67e3f3315e834f34817c84bad9f0a659af9cc974c906099fdd9ea0c6eee1e73de40dec56504db40694be36639abb97d936f1fc05bf598d18803944cf1d4f60a9c08f5d495cb7bbb554f00d74d6d30ddd8b299458a72e408ade4f6b6328b68333c31b6dce81931280fcbc6878c0cc601d9374e3356e59e3375350367651f7435eb2e18b561a1fbde7c3fcf90b2eb9c7e7d2d6b4505b3c46f30cb790a785e701f1456de9e6c1470b00ec0edeed48685cc82a8bedb8f72da7966c37823d69ba568f6f66943706a5d8cbbd6f0a4a43f646b68c06bbef5286e58e9f100e0a0996fef39a9f69750ccca41ccf0fb479d1b5b1ef5475909a3a914a02dc6398fc688bd56b081d26ff9d629ead1392faeb91f6485957d426ee109f7f2fe9cf257ba8302e4cdb0a5da0428592fe214c3221e98ef77abca7211fbbb1e6651df381837290abc7bd0814f5f522048ce21e0b8842d3462ee35ce586edd89684498d335f259eeda6c4457500b904454e36abcd09fe82f3b2eee9999d63aef483ce64fe33c4fa9f6462f1b4d7e5039464e0f38706cee2985e97830c13f7ad95bc983b0a01df323abc77fe0cef3692ef16e338be3b7adcb5ae75a42161afe1c60544cca24ab8b2c4ee1bb178b2d2aae75b138af78e347ada2b955d017587ad18063dc822d9033a263a4c84230ace3decd045e4a19f37730f67751bc2983c11d30c3e6971612ef566d544990d6c90ad0b921a54596ab40efa1c7a82155416cbe9ae50e660fc19aa0719731bbc000b93b39cba8c1f6de08e08cc8bf0906750654cae9ccc6b6461fa91c897eb0155688ab730f4e2a942edf8ec7f8ee15e7cacf04f2c55fd3e97dff60bc7ddfda0e29370487b17fc0ddc0e2dee64fe008e2e64ae3d7d20ee95b6cd0624cadbeff799df786eced2f7bd4bf811c08780a3aae39e34568b1e886f9e150a9c10119d7724a8d2a51adc508bdcff7a63eb8e9fdb7a1abf6d41f0f34e8d7afd3cb90c9a5093d688e288d16ddb92189b36280ddfc849adeb5425bd3fad06095633e32dac6dcd96f800478d3630488ad4701f34e284a22e5ad1f2e8092f7b6c1281561db36cc667fc25031d29a315041e3066fa3a6a2ade304ab18fd4e29282eda1c5fe7496f36925bedf1cdeef046dc99bf1ce732e67843d34f702f6a770ec79149bd5cbaec70cdc1da32af2ec67bb23eb1beb605a8de8c5e051f4c2ad96c252772a80954bb1da0df5b29265de2c39b78ef1725aca0259c61242cb943500660951f2701a10b0143b14bd136e931931e159d132685d4afa1a723ecdc69cbcc640de4f195e05457fc847b3e0fcd4370748f4ec3e9ba11e3d0e91f6f85b1214af1944928bf16a33eefd12cc2c482a4f4c78bec3ddbc40236402175571fca1c32c6ca490a4fa2ea8cd4c7c64af9708d670ebb8a8b25502d752c12f4bed80c685ae0f047765c5d5d50207476811b8e954760ed9c05a8608a3ea6139639da39434de1ca17710efb1cf5a4e4f8b31e88dabd6dd456d094b2de9875419e8dec1d0df182ea7f9ee4767a9aeb943b220f6e19490fbf5a94cd988587e5541bb1d9fb3f99572b3397dfbee9a69834d52e847acfab6664e776f7e2cd2e2198bcba1c76966f106ca524c2c710c5b93d95af2093f562669f1df772c06ca414df6eae1aab29191f64d55056e3c5299a7e22c44982313355d1c7110c7d0c17d47e0a2279f1169e3626bd0615193b9c4f7f5a8cf9d3639fb785f3d4fdde74571330165fc464b0ce68f1d583b0b83bc2ec00c31f0ae05e90d9aa02232fd146bbd5a58dd2953d5d119ec40b8b6002d0f950163d0a78df111f55226ac79b1c188864614fbd15f938753c9bbbd97502201c15276cf9e635ba3af307fbe4522d51c6e32d22e60c41e74947f655bfa8b8c28827a721511bc6dc8ab98c30a08576ad2526385cb62e0a0dbd8b9d1cd0b8329015fc59c2daf41d1fdc4a2f8723e1929647ca8b4bab792d8f668f7e561cf24f2c9a56b58ff74001e8b54267b127c4e7a3be4940f09b3d5b078474f28c2184fe3c9767e940e55bc256db0d913bea5303fa1c44b681f4d2a398245e7c32cf303ecfaad0e3cbb8fe461d62a1be3abd42d52a8208cd54140508a37b50bf0b486a5a467c67c91bc361f9c560f6b81c77e6077ecec41cd458ee94628c6c1b6860c0da879fe037eb410f5aa54cf4cfd5322d69114b0490b0d2123de88aef0c83a13e39c56c32bbf09022b7e4c35241c904fa2e34e003108e6783e0dff09fbca8e3ca762b90caa90db6edc5e00a3d2cb16cb5a0ef855ef8c072ad7680439ab885a25f31ac36f3fca4139a9460e69d1b37b07ce9e32fc5c6b2bf935aec85a676095e5eb6fae889e10a9e08a1905ac6a6e241671db7ad5fa69ec7ef112bab65443b2574cd5486dc77b4645fa4e6365045e2d20ad8d95d48079afeea75d7b7b722688141bb483e58d0c33a80d0f6cf999ec4cbefe66c5beee05ddb9f7e1a6fa768a43d11d9ac25974b3b58739c4311d0e8edc8fd5c624c35212c95f2104317af10beb3a065c0a7dce32be12f849294117af474297add0305e4c0b8cb85eb5118f4e6586842c3d32785e54a5e435ef3f8cf0f45d423a0afe27fc46fb54ef450a8a6db0f9020bcafa4f93c0f3b1f0d2a4d31c39a6ff6aa9039f63ec76e2b7d4e7dcb77e520a999f09ed90705f3d088fc376e42c082f4d540893500d60e4932658db250db20b8f9c7e602ee5fbc9f867943917d8c80d7af015d8aa0d1e896a5199691ef052ba1c71120bf70dd6abe98a71643512313a40c4adf482ccf539c270ace86012a0ee50785b1ba70e3bfe4bf8597d063e8c3d5eb609bdb8dca6d8c0a6dd7937214930a61958e59e9e720e4df41f41e1dc8bef3f8bec817df7dec7aaa1d490eecfb6c42e8383640a323248c165dac780425d45da265b4dab215be97fd54c6d37c5beba85818c23a7a1b8ee33f43be8e83fbf902a8465c590a49ec799b7ccf745e646b7fad7723d212e8f6d9b3873a0a5145daa5b00ff9ef68d3204e26cd1fb2e200933ed72ee8cdfd69c900325b0f0c8e05719981655ba3df91f5eec48f266d368dae38763256144dcb8eb9fe63a8c1dcf7dca91ea1478da4d74b7baaf00f41ef6453a0a1151dda778ff2205f0c30d129ed8de0f3acfd674bba1241c11c90291dab03588d10e0e611867ed85a3ff361e1645c59bdf6d9899e101d817383a236fef670529246d6b2655c9b5beef1420017410e1bbb37e0bf623e07e8919b8606c315edf8f44764e749e15d03bb4193809235f5baf500dc65e4203b19c12df9df49d64deedc34d19f8dcfa5ad1a90783655154e4af2d393ce236bbdd629561e9b01a7bd84e1d9c63d0d2fc751a0e5459324eeea9f0e2e3e4d8463b7a980efd44822edfc53b49f7aa06ca445fc8c4446648577558f41bcfb6cb898fa534cd6a43907e4cf8db67f2896d6e9bc23be6a7e45c038cf3310a525514a64d4e72f1c31b8eb3a2340085668b5c1bbed2ac83812d8c162d345d676e3ccaebd0cddd42d49b9a1b42a021de5f82bd43911a577b8085ac17ea22d1e0da93113d321813789963043285c244c68af0cd745b758d3006350cdc78c0bfa65268255c3d5ca66b4383b804cfe18f008fa52dd787baf1bfab873f469292fa9bc15f9a45a9a3090f74d6c1d3b06fce7f77afe344778fa935dbeb142025c240eac971edb145d6c8a7553eda6d86627792f6ffce139af372316fc34c069ac5a02575dcb7d5b38986b5792f1eb2dfe871c440c133bdca14579c84cee5d0da4352aeedb9665d4275486f6ae0818ba1e80c3921f68e79a40301c0722133262fdbb05211229429cffdda24d43966cb07b4f8af658432c3a20c20483732fd31da4d13dfd0ea9ac68af91d1deda0695fb32b0586ecd60b190844058040c153c82dc875d4f8361fe830b471ce97b71ee333785581401bba1cda541d6dffc5e9a896f8a6cec7341a0d0d5a04383f62cc842f041094547b1dc93db3ee4f312c52ec884b385f97b7b308f8d0d36d8c841a865fdeae4a3a6bafcd414ddeb04dd6d00ca20d6184d900040c196fc832ba07785f37489d4a663a8aa4a2c707efd55bf2958024ac9bea821760f881d77b901846afb7181b46c1b5128d3e9fc39e38d129343e3c61f22fcb20928bacd7631e2dc69fe39b9b7f36cf6d6cbd5fe2ac2e9fad759cb3c75039af54ccc6b7d48392a9626a3820b78d1817ffd9aadd7a224073c7d860a96283dc1ea1d74dce0d7e304213b61b20e8d3fc7d49bc48649fa6c351c422dc2235ea2402e90e4203c4649e335783c90d4dd42b7a0261b83a09ddbf8efbe3e15efbdc5f25e148f0b983d952efce5d5f0698097f99222406e79cb82ace9ca06354548692089c3f629fd16e1a320a164d14e45d7bad02b8c0c5916fc9aeab48540224c8f2c251e1222ed0e0dd99e5c6b336c25aab9088198ee5915a204959107f7464fb6ae6fc303f0a438df09483c76d9415117258b4ddc5b811f9acff1a9a5a499d206745278f32667b1162642a6d4bece7ed90c1b76a98e8b7258bfdc8f3cffcb35963c0536282fced0306af82abcf38dce98fd1be2cd6b246b9aeac34da4fdd71c2f41a7604113a8b9ea6a7a7b70a9cf62d6611cacae4535512b05c33571fdd68c0c8711f97b004da83900ee2bc19ed6edea71fb5f52a1edde6f95edd6fe5f3628545ad7c95b36086a4b0fbd95c22a86a89baea83999e080e58400366f7f4236be50753e6a291ddd77408f0ed04d2d94e77504767fff88e8f9bc295a4ce1b7c23b2575ad8f9cbb9fbffdbf77bb349ef3cc9045ae8a7acfebfa0f946a6ff02b99199556e3798dc72959debda915f0a7280988c924b0eae29478753dbf6e9532a1db64e376c140b608c21a6d2e1da07715a01231457bedf45bbdb920c364cf543c903cb1426a9d6a922493e22e14b54bca7e3cafadbe43278db8d02a6a15b2b817f45d1ff50825c0b7126e727f3585421a6ffbfe0287717ec9290b446cd255f96a7b906844551b4e0d0249d7fba6bae564ae71fb1257d0f5196baf7c3907ae8fe7f993cc09cc0a334e0c74e69cec164515c76d55a2211bed916fca32337891c1b00342180ccd19369d6ebeb7504d69b80d0738c9cbffd4fbf2af70289790a7246333200a39d80aaad71acb05fc225d0ca4cab610d0bb7c0e9b6ff76621d7b21b0f804be07972bba8080c24edb10ba57231dc1ec8fe5fa05eba798f27f925657395fa434554d99cf865ef6bc33013b4b5740d31e234fbd92a101b9cee8cc407571a4f93ba7a2d295d73067aad39eb146c40d2e8a817d5e1b3783ee2074573354711d305b34fbf7622f183d6530254e39b761bc8f21501694f1d7308b108522c91fe03f26474fb28706a3180550ce3d68dd442bd491b050620941bc5a91368148e00099c9885d5d5eda804593dbac4e2013e4b3eb0dc4d6b12cb9a43c5b7f41d93e0da2cd587fc4eba17ddf7ab240fcd86b84155b76628c77f50d6aff2d87740456fdad1d70654d80d06c00f9da2cee50815ecdd82bb6e49ae83e25c0fb3f163543a76c87efa0760e156bec3dca41c2c8a9c71eaebd7db2c038f6c70a84b89755ca67b8696d1ac77fb41d4060654763ac2a3d829045f351d6a637cdcd93c441b7f7af66c7aaf0742db081abc04784184c4367231b319250f2162dc040b9654e16237e41c0be465356ac8f2d80071912389f56f06082c753c22887da47e8ea6a80af1a756962383dd38acaaee9399ab292ce53b689b9e8fa658dfb60b762764b0914572f2dbd1b20898d6b7c10765e3507b7e97476af7ac4eb142d15e8d99382457ffdf33732a621510526a7dc02d9c9c60f86d3c190d4f86de677a3b5da602be8d3d4d4393aef229ca32369c150f88b41c2563a8ea9c9f4f74ed0be22de5af020a153cb5a7b6ca2387e449537c745a32cb7447d48fda731369c66577dc4186e008966adebdae5688509dcae569df4e53f2a1c48a0aa8c89de2fd3d64867b94f22740361347cb52151093735c3d105c058b0875dc99c80d0c7ed7c78dc001d6704091409fb505dd83ce788bc78d0ef99cba8e5255fcbd4684f97440b30e22e4476c0f45b2a4a84664f06f4a9066e4022785c6c0b5c5d29397df06678e1ecf56e399486e11dbe4f4bdce4adc525fc4fb3c4c1b6e4a1de2bd9558ee96dce06b11a82206f6796c51d4b96239d178ab9f15b6f970d21b704aa3f2e4165c31e0b1009315852041ddef4b2abf53cdec6d69afccc29404c5c8c49fd0abaaf505a0b910fb67614e207133a26c1da5669bf6fa37470af082f27240ecec09ad1c7390ebc0d03278d7c9dd3ca321b175cdc05e85d4b419698cfc2788fae3c07f76a0b6eb1167c54dcafa367f4c970d02912b2952adfa9228544e4c213091a1b170323fce86b764f60e37ec30db877425a5b538a7eea6eca6f4de835f98ceda40b6dea90e5ef06d69c64d81f8766f6bb2efdd686b2928e8a25be39010bca484d6d8b4418e3bda6007e6b831ac71632e7926fa3f6ef3e917898f0c5ecd5ef91c5e28712cf7cd1a1b14df23166cea6085879a48180a0f4590b943f687759eaa42882a67d5f4df7a5a26edfd6d9c736d416a176a74acdab4e948d17471987666657a4c345bed3b7917be02feb6471bf3cd25a1b22df3a978266c825bbcf05f3aae339c127d80d779c908e75f9b204f45e6d1c2d026fdb8ec93f963fff3d2e2719cf53c3fb8be1dd5fc4723d8719d3bc1b3dfff568ea8a4bdf0beb9986584101f9882dbcab87941ce509f95b251ed684fcc51db9353dbb631bdd48d909daa27a053c1847e2468d777cd988bc193c9ef0a109ffbace40db0eaee8a2aad887203eb9a4e94306d7520fce16d0a0f7c1516e84e43045e82330fe64f914087d6129f164e4b44babcda83c49ea9382e77d1c47a386507fa8a71cf57d1b7f492a0a234e8801fab2c92f98a8c4c31baa02d53cafcf22cf0326a391a4f56410da409ebc0b3ff085947111fda6e1058cfcfaede79831b12d4c796c4f282657cfb7e261aa8dec13e525b0bec7b68ed90768aca2be9116ceed855ff95cd0c11eddfe109d47bb4e6e526b9ef4da25153d3b94353a1021da46c0c729a4e4e2fcd4f829bf1e3ce27af0a37c9c59cb9a8bce8340b3acf39fdc044a754c855fa2c80f2d68dd5d5c794573adfb41bdde27a172892f7e44305a8e3c5795f2371cf7841140a725b8e403fc32245f2a4c54d9d782d10fcf0fbf0f86b4e1abbe2a99d43d9379dab7640fa589371cbcf3c0c9706a5a7ebee92db3e1918c870bf634dccc2ba49a1965b6c859139d340fa5999ea9f1068d5631c03bf4b224b7d5b17638384df017c77f0da2a9ab8f155719dcf3514d14de733f04da2deef0109965fa7bf8f0fbf0fc81b8de00931f27106d6de1b4999063b3504c1764a6bf2ffeb82ba52a1b8e7e4c4527f1e1007072f3bb39ec07d8a82d1c7f0a08b28853575fb50d09beffa275a36d4aee7fdd8800c2a38ecd1a20910363a1aa1f6d7d34fb5c7c433619ed5fb4bdb9ebbfb98934f1be4406cc0451374063d12e20a6259378e1335ef84939a9a97a09ef16230e7cf21d07015bc72378cbe6404d40c97e477c67626c418729050a26a82ee821e5645af9cd463ed789aa2c26e342065fce9ddfcf8ab5a77fd954e2e62de2120fa47dcaeb897bdec2a2bd57122a5b14054ba767da5ec8906aed7414c642a878a4b834167a81b79943250e7d7f25978f815ff0d6d1689fd6dd80f84db6ce3247c61ea266bab8206840caa1bb1f949fcba9155b067f029c6af107e5875e2940de9a56c0c3ed12bf93470979550d7c46381049b137bc8d0de17250e22eac6db5612d94310f8e38e7d6ca2924e418c6e3844f02142ec52c840408ab35709718b4ad915091ee71eff2d2ecec4c4be10b03ab4f4a05b3038c53844328cf53ec3ca8b0728fe15b31f33b4243f071a51d88f9d1e70d84b344928aa5569af6f78b4b0ca2144dc77352edb519cb95c281b8f1fd3cdc692cf14d81a8134cdadb4fffa62a63f3fe23f16502720e503b4d4bf6928d8c4fa12383a2485dfd91d65e6655ab8da1073807ae5fe473532c67c7dc869164671c213d39168d921675a76e55799f00df90a7467dc19480f0515de35d32de48af3a32d23519f09fd84d044077a6da26a99d390392ebbf1b885b5c8f9687eac6deab4f900cc5c20dda2541c89bc24da638c859af5514307a56f607e417b1e503abb67b5a04b1cfbf41be823d36d4b36432ece62b21185080404ef5d2f3638cd1fc76568143410149f6c3201c192ebb700549f173bef029d9a9ab8ea664d2d31c7a1fcab340361f15dce52b565f517d37da7e6a2a929d69b1856ac407562a125061441f636b558232c801535","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5d3107d3e5921d0983ffff19c08f700eba1768c30c4363c7e5eded7288c3e2f61375fd44cc9fd0837e849b6749a5ea0421a7fa61f3faf51ce39a085915bb59588f54dcefe8b56c5d11a62be3860511283deb4a07d3a158c142cea9beaa37d7daa79deb7c517855a0c7afcec8bb05776c497e0d0bf2eb13910a1fa8350e27fd72d3db77d141a60ef21ff16398357bb763dec64e8a959081ef54b7b10a6269686dbae2d83ffa042a84583af2b501efd1a00bd6e3aac0fbba8a6f3eebe70a099a4b1b2112934057bf588de8edb8aa2e7e5741b6f160ea6ea4398b2174f7c5bc2f3bf7dd3c609834733e960ced65be1a773513f5e3959c896a32949199b735bc5ef19c48e269a4a3df0cf123e8688ca35340f762a3e6f7da141b5c0e04eda62e719521f3ac25c13e08cf60de1481f4781990f773281df1631675d6302fd9f5089ba212170f157b2141fcde622ea799cecf69c8758d12873dc7b6a870727b6848d0e0bdc06528531a37542a80e935a3fd5adf121072284f60749dc96794ac9fbe3afd00b65085b7d7a01178ef56973bc30239d2d2f1b975e1a6a9ac05dde045cdf36d98e06a09a6f46307729bc838bd6040aa3270ef9c33e8aa2a16332b2949a78fb02ad7811b0c337af7e61ddafebb0c5dc3b7c59ca8a02ce5e0c3bb81844ed19ccd6f33b85a57f0a1cec774ad71a7e9e5eee92955b79fec6102acf00da901fc5d8146bfce48f4664f956fb4230fc245ea0abb6cd0c8896d26f09a007fdde59f227bde4861708f312de032770702f6d27784af6d633e3721cda4d251f5fa1d7178929dedaf04cf735372bc1e95919e1456c8cc2ea9580e2cb6d575e3ab87a3c3ef0c664fc586e3954b0325e9698ef39f56410200dcfd7415ed831b378afbabef52a8f7abe068ee1cf83e7bb9d8fd97ffda628f0c954361ccbffca65bc10dd69b0f8f71760b922a41362f533f821f6a40d3ffb7d25ab7cf279738e1df6da5c6b4bde8a7c6c3da62631af7157732888817c92c0361033457b1d13e652f060146cc543eb861ed8c93774bb6fdbfc8076e7edfe0c09d6fd1659a2634b02ec1462fce9d246e82060efe18b51109c07fcecdde61c2e601a44f2a248e1cb73c813ba56c701d47ac0a94492e8fa9c73499cb11b296ea87343f2cd4ec1f7cc06a5c369eb60282b53fb4c96fe73ef2d19eb3d4ba4c4de8b588095b7243fa0204f1be0e4707232191407179e9778ac34934307130d60b994ea98037c06417174926169e90ac605beb16b44be8a4c48cc5702df09c9f8c7d5af2b4af9cbeb80502f4e6df4caa316cd93f19dcaa3eb0b3fdcde90f47dd816f7ec305a105ab37b7bd2b9fb9592eac36cfc5e718b30eed54d07cf27e33937664d3c1387eeade3a33fe6b6fc4aef328cbe299339a0c280a8c65d000e893998d6d2c2b3b5f18a4543dac660804bbcea0a96c1a4e9cb8f5e5f5d0c1507155875ad2fef6d45b7747625ffbb0d90e0c82384fc3fdef185cfb958a3a31af6a37513ab19d301dd9d82497f4a6c3faa1dc42dc472a8977657a92c276f6736ff268712014886b224988438a8a206be33a15f34c310bfa9e0f05007c71476aee41472e2d6cf524d6a2deb40a2e337d39cb63ad170a8bab0e4eb7044af7fe0f4fa58d6ef7b483b9e0fe0ebcc8bf1c5f0ae5b95d7e4ecdb158145df79539355be6937223226e863cbc594b148c79d6836a18760d25c24b14ae72adf504899e36236b24bcda75bd430bbc816514f93fa93d8528c3113ad577e7e485c261f71014c08461f1081440b0292e4eb5087be5ae7d8271146006b008ac9f40a5ca574617626f052b0d23e4b171873aaeb604799e3389eef9deac683fff163360d295534f95677de0277287464d171059ad451683c4d0bdbe8f6253f1e3967335b092666881fc40db2ead07f765561f9ef31972d3e371aebf3dc1c3cf07d7ee9201ea7eb29e67be4ef0201d20f9caecb0dedd63307db29f09ce3e8f6ee32f93e6bcffe01d2a02dd7094e396889e87d17035c2ad7c2efcc6d3e3ac088888bbf64e91fec0cb6fb9592ac79fd64a71734f5e01f4bba7da22b4f3d7c2d53b834f4c04337c7f6077c683a3bc7aabeec2d046c5b64dd2cbd0c0ab9734dcdd0977183a25276513b2967640e9cc49a5f0650961da502de07088ed79311507238619bb2dff4ec4850e6c03396a00a90986575e2052060c9a6ecbb23c0ccedc19988c5b010109b1aac05e85e84b60bc93a92f9c113709d5ca3c7cc19443e3edc109cd2cfd1a5fc4920630a48dbfd9727e92a3f1a640832e8a1aa3ef45fcdc5d0b0a33fc4899aeb831bb9a497fd38251b3fd573eec51f5b5509fa807fc854c67ca7ad1e71247f09fc8a87deb0956e341d0112c60ebc12dd9f07d552c7e6ab54f60e1c59cf0e39280dea5ad6fd4e37628a30e5c51dea0d12e76ff31933ec1e80d7f7916bbbd86cf4c21fc0654990642f1b9d61832eb24ccaf5853bb80d3805d90b7da4a8362c1d50893e8c9cb85f0671ca0430f477479307c7137a5c0baa2140bc31d5add96de30b9496b22bd0b91024d0cb198da10a2fce4d1a0363669d930bac0223d5faca0e95851e869243a1e9bb259885c17975a0f304339b187fd11d97f1b8c614f61963ae42d106395cd989d9437d15cf408df7b186359c1f2cc607f37cd265a48890ea64a226dd4e92534efbf1194045925bb49988dd21e8297ead903e809f7704f29726070797244d5e6cf0abe4d63a0fa1fe1d436e77f0fe3162dc46ffc8060a597e5b4b4149ae398dec8d4ebccb0cb1a64c31492f72c93951ccc4789f7c68c966592b04f08419f51c2a9a9ee3295702cc5da2e02294f31848098bab5b45e6a94ec9e05cd15005a5c3c5051fc3581476a9eef534113fbbc03e64a5ecca0edbb3fb4dbe135773652dbe9c56b54a96cde7a1c627f0dcd57d2bb5743daf286bb24a45daaf755bd82b2bac9bbeef0f603d9832cc46b19b1c334b82f34215fb0650b6f81de5be95638187d13c5630632ae4b3e41937c61e8c0f186ad3aaf5452223e588f063be89de3016ee90421933aba641dc20a2673838dde6e23da302fe9d76c589b1b709ce7039a1fa3242071e54dc70821c061a1c3a1ed0207452cb2800fff74cbe7b84a8e51fd9550cb0e4e5a2b39c33b1e9bc48068513a2bb5165bb410c31c71f75b0226cdaf8cfb2b6575b98bcd43b30aee4536b16d2f89098aa901879fa1ade2bbc2ff6bea2a5f4ca569da45afb7e87e294d850ec2843eb60277ab29a2bd05f7a6c998a7f51c38877f2aadba18efb4260583ab53c2c156cbea796df7b0145d2faec7d242d96b4d28f413fab5ef738c32a9f8d7af1e4a268d17269abf7b708128017b4bb49461b651277c5b859a7e0e05fa2c4545700345c388a7cf0d00d38ad86c3dc153dc026ba3a3175ddf7b66666438bb31f3ae9e23021e0b9921aa16244ad26bff73c4ca46fedff5feaa7b3699866b13343381e8a2c25c8c95ba5beaa603bbe5bad3a908ecd2dcf1a385d2e0d5eae9cadfa84a70cf985d7e73e496d48736f66554cbe8abe4095b608812adab7a3fc553bf15551a9c23907bbbda1bf6f6aa55b140f89566e51f96b237aab87e94a73725cd059424c46eea697b5b0692df10149257e4372bd6593feb741b216172e3da052c8b776121af7843b89250e395b944283bcd6caf225cb6716ab0a8e8cdc504e7001b9f203540791e00a4678aeac6f55d6682afb39c18d953b40ebd460af739a9d36f934d5bace192a20118e70f002edb0ab76b7c713aaa83351efadd7737eca003c877baf4751621ed6b94e292aeb0066cdfa4aefefeb7e5fc01738f889c926ac68c81dcdd33f9192cef1e667344aade641ddf9fec7ff8a42cd624f0776df09962ad32f7ffc34429b8f251f57c0c09e3e288369465f33d437a93973b8d75ec9aa21baac9828339c545083bb397c386c71a1058e7e05d3c80fd11034d719a68c8fda2b4fa09fa41432674f35ba574a0dea161008ed0014241b61b5ad6d32d1a063499ca7e0d2daf2ed6e4c8414297bcbdc5d813632488fd5115b4c7c7499578c6d88b0272aba8fc89bedca3554fc204d208a15084e13ee4270bfdbc35b1351b0123defdc59ad871c8595a4fa31d754c3fcdefe35251fe732b9b4cf208d7c8dbd4f14afc540ba78bb11a934663e7ad23a22384983c27a9ef829bc95e445f75547919e54e887f9c64ab48979dd380b9340151be154f11f180709ec2a69b12a8d76d7d040f1635743448662e0c895a013b0cb1e6eeea10ee92b99b202e76c06a318019f033aaa5e9f6422b62220196750935ab5305431362c66ace7ae8f23b3ee7bd105effb91a53bdd81e1c474b552f62b02b9b73b0ab906cc6f6fa409fe984dafbd77da44990f3b403172399a78d787b8104bafb9b1d3db0cdb5cdff82a7b6efadc812016fe6a5dba9bcde0ce81b2e5876f64092996c1f3c64a62282706e3720aaac0567f2ccd304f0b5b4e918ae8eb331e516c4afe57d537fadf25470d50d4b3d6fa60413e37a30bbe203a83827d1eab12a533a4b26e8a6f534f7e4725886a45f9a51be77e4687d03ed4fbe014e4171e28fc5dd0464eaba07d03145e90fc2d08b22a1308ca63893e1c1b84bb186b08c299c8fbc597154f5503157d8bc0d1925eb8c2507eeb359fdcc9ca30b9e2b0e82bef10d2e0f8a7901443883d194d52ba21466c090018225abeb8345f3ea4039e24a9e178c3626c1661f854d0710e128fd15d70b39f27b68bf02f27c388bf5bacc67930a76752666dbb0e6a0891037bf965deb2ee08de971ffc9359305b9b435f42c371bab0080a72728aa7aa5ee62f54101bb6c14389a4c1e46659b382212d2d26a187544f381f245944ad34734fcdb550cb953e1602a8cb57b8db7248c53156c9edf7d7ffa2de7b2f10b16d2b39e794a1343a3f1703fde026bcc2b3fa6b7713e951cb89f6d825b58930b20f501759fa03c4259f7d6ab27a2d7999209c32f42463dd72c9472e9b4060cee342a734af5d5e4e47da2e7ccb94370802013b25565ae1716731daaf814137e43eff6e360b8954e80b78b14a489a9a9d29a4d712e51ba42accd0043be8b0dd4023a39f13b0221096d4dc0e1a9b5e6cbd745f181ebd2a6bbf09d629480613226cb2538cda4a4d61f89bc5c729a5c92fb8ba262ccd772f32c2afcbee89691e30911a5fb9b398ea688203c9b8251240efe80fe2f86c613d89fd51d19b48d4d9da74c004735c0034df2ea8c41cf21e20a759a020ba82b444387bee7fd9f96f9e553da5e65e43ea6e13fefa661886ec3c3af795497c32c1f75b312fc991d645a1c02f859d996a3a0fc80ba6b9885c005dc6888b170f118603b12e9463bf25c0793ea13f29b5d4362025811bd7832e590638559f59972b4c9222d54d55397e5e4144ccdd44295869ff2a15968b2ef26d83d7e7eed4b63ad3f3535d3fac85080c14302010ee07607de71b09146d2154862d20f35400cd7ff4d860bfdcb58029ca9fcb0ba5feadc44e93e6a5d4d82e226558cd9a869decb6c8a6473d03115ba50c98653a1d701f4abe693d99aa56095f8a8e398a774ffd7db8dd017ba92927867f424bcf639f0912c7dc9311b2762de3c7f7417e5d2c1c09b4d47cdab9f6abc8e5c8328d911ac9d4c97435ccf891e2f09cbad90151f919592490cc573e2da4be43f48867f0c95abcd073452324dd4efcd63ff9b8544acacca14c623f71828c00b2a105a30d12592a3e74171872bbccc8762bcdce0b7f33eea8bcf2a015da5a6f4c45b7b41e44ea6576a4387402e2df219d2fd011d42e3909dba5b515a3ea7fddb54cdca7288637519f19dce4232254cc59862753bc3e33a802fc2f8b38937d77230a55697b144d4f904ab9edd6d8978601ed6dd6f6a9a2b434c77fdd7494a9b1ea8044b372bc4eb51cd5eff9339fd686713ccbb1417611df12bb9790f6a041eac7003f46b4a21b6b9874c6afd956ebc3fe1c3d8755c3cfee2fc696823f578adcb0dfeb0e4065852945238383948038510d732e8765b25a0158255541744e6ecfdd1c9e1f8bcda58198bbc98d1fbf69569c77340d882a3375c54d02a19582bb65363d6cc0c560d202d46a593d26c9fe4483b69eca36f4166ab4ad3005d0fd76924a0409da67afbd93fa78b622b1998d0297029ac3e63555ab8da70e98071db697f2a671cc683a55377e1a7ceedebd04c848d7f2ec79a372d4a7405825bb5c67fe6fac0d1e882bb3e8f6638e6e6ee10c8166892fe59333f31e1dccf135c1cac36d164cf5eaec296ff962d52a807dd11ed3af451d0674a4cefa085a77156cee50da8ecb7131a9f94060a0369d753b03a11ad7347d0da232a1e02f873fe9cb7df937207abd2df777702abe4bb9123ac00f4f1bb2a95aa628c9d69439195e49df64fd008114961da6ffdc0c7a2c6767ce196955abfbfc9f16c4eb6aad830a76070f6b32b5ab5400263d5fc2e44d4cd8db6cc4a3f5bd20b21dfc00a5374500ff700692fed96f1c8afbebb677a7ec9d139195feac8b9df410c41072b4fd8df03090b7a15dd48b66e1d2241b6f5018a54c9b317e1344c1d3411911db15609838279e570ca906bf46ff015bde7c2aa81ee73234918daf111ba700667d7e4074bcadedea43cbd0385af626c7f0e3185a097fa6cf240406c37fa7c3a8e59f6d101a9a145107a940aa1cc4b255a54678cd3dc431c4a7afbe29f5c8c63e209876833a2f0f51a8ad2a304b39326aca6b60398d309c5e497d1ef0ee830130606cd0fc4c65c3a5aa64c5e0997b9995afeb239e9500485796a12fff27a23ff6e0117631ed52d6d1b78d555bc0cf069de454b9bf6c8c1c30f5abc5ed54bdfb3201f5955b6c0d8f2168194b5c2735f422cc8228bf71bf89fcd3596d17224db8978094f135d9c8fa0386565eb62dbb36198ea2bf31e7cdf06733a25b98bb9c4ac4a610d51f86ed89b6d0f6fc05d7e28a8e775ff7029162b3eaf28a45019423723a4c24c0f468900795e6bf464c4fed9a992713b99167f8291c55392ee52e860489686ac84fae92200f78c25f52aab9295b9be39e0c06fbbb5af4882e3d25754c7e6e8f1f4a17e1ce111a951681420b6ea437be4f0ee68e1eff3e18f31ae8cf4e2ff4527328f36e503b04b55f1160d87cb4fda81c674476768577902a3a01b19dbb744b73a60ae85d028c0a4e54a0a6d487b85eae22d06346686ab6b6bcee7a926a83a76dbc286ca6238330f5154ebb0cc90b9d2ea07597e0ddb26f0cb83cad6bc7d7c9923ff751d48a934bd6eab9f4be0bc20dad5d88d1f9f2dc7996037aa3ac5091e503be0b70a85b2a674930769ff40927daf7dce6a4c1418799f0cbf20f13beeee0b21a813ebf118ae9714c63dec604c5e83c72a069808098df7eb11b4c8f0ea51a4a7d572453f5a434ce1ca350ea312ada8e9b1f4b1a39240d1905053581c23e64c838f0b97a8663824617c5e8d77fcb86ee3132bbcd11e10a047e954c0efb2f221cf216d1a329f8b454a0d5d0e7ea262204281b6d00cbd4ffe52b65964c744a5acdf74714ce324edbea927fb2ebd82b6b6f8a1bc1281ddc497d2262b6468750ab27fd748ddc2444f880e11043ff60da0947bcec66a2d5b468a0942046c32e7ee08354a68f84fabcdef05acebdda74cda445ab00afd525e2167b99f7ec243c92139395dd40735e6c9ccaa3704abf230811684db83f788f6718e8c8651c205dd5341f03b328502359c41ba0e5f963fb55239ee7e1d465841219558b1f8aa90f7cdd5d6a8536900d879ea83f858e56755b89f264a39748333479f284bb38dfd0a84739cc59c45a44c8b26bab0b42d5fae8f1f7c659dc898e22ae33463c6e69261fceca820588e78cdbe0532e85397a2aeb39e618a9d55a22411cb2843ed9906bdc23abefe8c71c5bb7429f826599d507c88270e1039a1cd0f614c1a24b3d1bca27622a865f53dcc8ce6388c65957079457352e65c11dbca0038aa74ad4c19ffb3861c12a22b7fc25c0b588efc8e74cddc6caf45a0d0d06a07fb4df510d2aefa3786629c4ec56c8d73bf2b17a4cfe3a2b0534f19a7a73a29795fc114cb7d8a5bf11280f2b89561a3993d7dd9c3e56e076f2d2dacbb38c661191172c7d656f6c8f06141290a9a858616890f68d967837da8bc637e23af51dae741f5d307b0a54c6c2c5a537b1815040788c291a1402b46a955d9079930d11c310f2954d1b273ba3b691106f13101dc787ae113e6e69738ee06cda3f93fa165b7395f1f027e7108cfef7c274a9777abc0ca3e8fa82caa7d9cb03e467bb1ded22e46f57b93c1b870a68d5ad4451a22d73fce6e06a29161399601a7d1fc9b07b3cbe13e584754d5b74ef57deb081619d5f935b85b4754f7befe396efeddced7db9336e3758d37cc053d063aed16b504e18326921f0ed910bae3a2c718ece1474bc45768922c268891836ec3274368a3baf9b345ef5622754385f3f1556a804b551bcc30a5ff51a4a24d1175cedebcee7a1581730166a6a19a83da6c638d1e2f111aa058bf10799b1add8b0283ae03a9b85aed31b330cc5619fcd48713363776440d93120c59d8ba17d2f544b14ef7181daa9937629a0e2b68dd427e00561bf0bb5621ca2172b965ed8ad4e5694c60e2a46534b85d3602d03d93c82c1a6aa8a1e868959784b9b7f6333f72501871a2ace28b5916ad10511831e62f73d1d6010642318559ed0de07fc157cc606c24ee69e783de82d6a48510f09d422afd1f8f8ce63ca41273f6f7b1d13bba2d24395f5459c72c1d2a8f87088fc3452498ccb3ada6fd9e91d11ac5fb2b09bf32a1a680a254d417991ed63ad37ba76aba6f7f044a423471f3ae972950b9c92853c0de97e6c778d697ec6fb9029e66fd5feed059de537fbbaf48c71c21a4d9e3a3a696f58396b30881255867569dea6379694605d4c9250c534a24204c2cbca5ae5cf50536505bd3642751beb3c9f19dff2e560aae0fceae350272af4c63c261aeb80236bc40c30938a146b47f297c40107b84b96e8e5a518407735ccf9d3968a71372bc6ce60c27c5e2df63cb8f38ed24b2aa99ab64aad19f25e925a3b65c2b91cc45a6802cc1c590f285b133294dd255e13dd24c978774886e97209a0b49c95067cf85e31f4c95e01875481eed0b4f80fa347995292d56d626bde6eb43a85351e2147a112cf7279843a4be67487557a5f485043a0d46c43e5a4e41cd6756bbe0c0de33138d50ce8d16c383622d7fe96cc439e6fee464c7a1b0944fb50dc16e0be03408547aea62894f5b64c63ab51131427009b0e301b8594b11d99aacb3c6769a97f1bc127d012016f22af2657adc1ed6d64291f82bc0dad4fc44d3ed3b6acbe86a6e93ade9d5cfd4879721dec583f0463ce199b566e320455e8f74f3c662841427d63b85c7d9e6c1dd2af21ef87799f811aa7460c7a91cdf04dbb5d82e7cb797414cb5c089b9397c5e6bc75fcdb485b63b32df69cd6b3a26be6090529caf2ff3ff9f2e018aa11cb8bb2324858a02d00bbbb2757a10c8123d6d5b4e84e0989ccd8adf3386dcef3d5b85f36b87f2fab415f4aaca878743f22ed095ee58c74933306ee7d43cbae0fb8feaea7f4bb6db533b61f0a34da6c588f3a807825f6e6a2a69b9e94e6ab564b44d6503c23ec91a1ce486bc320944f9b93970bcf6e573171a1802767bb4ca8573624bf3eaf199a482987439fca0fc7fae337e4eacd2bcb93cac277ed1a29927c486d91a4c65a728f3a5a64ce9ef964b50443ca7ad7adfc0b57cfd977f23bae16e6daedbb75cb812e408a9c6ee0c355c9f5baf925c24257b8cc1f1703c311a690f20748affa34cc78115a9c6f3672239f0f46847714d9bae4dc819b932916cfbda81f0c0b94d682bcff6658edf59d7e48c69170f58538b6110f4005a3366a7349435b0a3126acb3717ee59bf5fdb2462881de26c478c923689c8d6de1131c8e53e6a47b757a663267cb64bc79d60c8c9c8a9e5fdaa3398bd577e9634eefedb51e4234a6c00696738c2ef285c72756884fd16c391135a70c1024e9c9f41f8754f849a11983d89a396838e8a11ddcab8dfc4e2dc532312056fb4829c282fa0e4d77cb2bdd669369d8e92454dcb26e1338d624193e887805cff082d9951279e4163095e11362b13490f87b748d595bdc2995ab6dbdceddca7e7e9b70281ce3361ae8f33fcd4432c01fea9459c5c838edffa1e72f8c9dcc05962d06d7e50bf403fa53cc339e7b9571cd85a5444d6f99aa780305b762c18a711000c1a077e0907d52280bc9c5f7cb95ea872b49e3a1c891834ae1540e3065c979fc4fd428a3fafe4ad5d9bfa80541db46004c816bc9d95c051c5b240f964a150e64d009f8e0b30b29785136095a639cd4865274a9c77cbe165367eb7bd9d58f513b58ff601ce11108c2f4261d2aaff1928bdf72a3dc007c30ddb741164923a0cace345210f00442d844a4d431b30634cf1a6045fa03f9a708b8e432255bfd9f930e119a0f6e4ac121912cfd22191f73d4fd99140b2999fdc5992414197f345de59e14ddd5042aa7ee6ae097140b1411b372dc448917f62399703d81ef9d38673bfc601124524c1d6484d01c195cb59122e7516da3bf65657fad540b18dfd320cbe9c46fcb028f60d60529f05e880c2cc30ed7af2514ae408d679ec279a22d80aa5596d9ad6cdcec67c22ec7d2577ef316b5be554ed662e2dad9dc8028a1f87c44b8877f81f7a2addcbe12aca7af13344a04ae9d4df37a6345e6d280d8fb9eb5c029d5eb708a3a8ee1329177ba3e4b1c0e5ad64c845c72f6f730c956a3e3e54064108b07cc9536422a95d19799aa678c387e79800f11f9145c9c471898ae184410fd581e9e67a85d0c6d1434dc7e36945a09bcdb7ef5b9f00cd873dc89aa6a7bdc0493538a24b883b80caf7842cb3379e8d75f325d46bbaa3010966f74f5cda141c60b326d91777ffd80c7cfbeed8d61cbc18eb4ec027bca4f0a165ef42175ba91db711fe1ade72be5766e2fee4c2c9679de902c1f01831494529ae6bd9fd67cff75080a688afd6f1492d4af8f10824f4a3c5639da2fc462e734772862b7fc3d0676499f85c099477523064ce21c3cdc0dadd01e325ca77c07d7c299fc192ac21a84a24a3c27bfef5ed5708764b23d4978e2042904fa710c3e35e462edae5aa5439f05dea7a6b6016a2165bcd497fa4ecb3bf6d42c8094b6404a44574bba45f35cae6db386c16ddde5d2053dead54fd3bed62be72cd4f4aee1ae4411be12f451dcb93a0efeebfd1f3298b7339dd51cc682d61fdaf1ce7df47a6ca0b912470400155c0ef1cb77e504e7f53b8084f5677ae36121bae93c48b5bcdcc3d18fcc69267fb6e45cc3812ebf92368b89f8746f70d806edbe5f0fe22ba380c3877e0fd62ec33dc0cc7b2738a5e14ff55664e9bc4a83dfddfaeb3047eef8e9dc2f806f32e877be8a458332f1cd3ac5449208c30fc90a281e9130d49bd0d06f6167f2245b57c429ec100fe32afeda775368013d591c09e9d8f5b900e56809d51592560060192c205eb10cd5d9aacb7f00c249670887abf20f54ac5683c2dea1e7bc22ac6d7e15bbdc50e7c8392c26fa7fd04da64a11b44babee25fbb47e6402fb0b34706d7e43ac1df3b27add64948014e3709d0452eb34e0ebbef5c79bdbe9c3c2ac3b145e5034bc15d2318ac3576fe0a69f623b2b527a94e741da01a0ed757f1817a0121a675531d9745515c50cb9a73c4410bceefa80313f8ae48d850002c8028fb08f89f2a160c884b6bacf1e522fff1a870413ea2c62f60fffc18c1452402ce245d120defbed414cb0055ec113a1a89d09c862998e4d3e657bf0a8f64eafc5f31d64dd11a8f4d978c192e3fa3741e3242980a45bc50bf1315818ae628bcbadc37238595344dec17a41b05289554beef05345e62ba09ce98b94c39904103083b0dcb460d4abf878612ce7a7959a2136cc1b2da0c913f2c927c2435a0dbeebd463e1a3a661b0a19f68f08eea6342b80c6862a6b8985e5512ebfc6505faee6f987f4603041c496f64dae42fe2d4345fc4be589e9d81a6ee7246a5242376aa42cdc34820fd959108353dcbb8fcc145f6c8db1af06a2b764f123bc3f1f1518ec6b845d8d17c8b3aff499d85287233a3355f96abe33bc826dff67c1ff4204915328cc291233270a725db10eee5f5f42a0b9aacad18dee4191e41c8d749d31fffa1cb602798040da129e6f88eea38a4bbc61984ac4ec3ee9f12b14e2fcc0bc1515473e2b68e735e30c0cf9b4b1df43a36d5277ce3ef1628c183ce280ebaded568a10f7f66ffa7baee064dbc732d2f3b42b54294dea5763ca2d8acd001316f5ee8b85c1c9afbe0573d8fa43d4c51fafef22d18d9ed20cb7c2b519de99b76ae7eadde2cddb39c30552fb98b67069a623f59c92e7f4af4796f6517cf8114d6c7381b5715775310d241715abc2730470b4ecd7f3e2537160399baace4bfa88cb894532ee19a374499b7f023607f70c3bc95f61e3daf1943d5e186340ac151da37c3ad8db552357fb87d72f80d07c8a24124446463aa68dd3389f36a16b2e68cda7f212f93e3b3d25086fbc4caf2e8becd1cf9db276473194207ab7c49a8eee0527dc366d19d705d7985bcdc020ece6e83ef6f6756fb345a08a163aee2f6729c0eb485446df0029e9adfc3b047319510efe80e650a0ba613045f01c6567d1c5deb09dc8b44eb109af3fb5dd1507c5e98955a9b9c2d57459254b67cc643d648106fd90d6abca8b41a6709dffb3c85f54996fd727a9e85ebea01ec96daa3c1874dfd1fe1dfa55292b7cbf9f3506584a1433402c3f3a19dfb0b77e907c78628b8b708f8a52fff8d7c86030ad8779d4554c885d8b83402398fcfffa6e1b985404f421dd2c19385012e44b07f2c0df659ac799e16e9f16f71aecad336e4fda8621dac4bd6b5bedd0b49facce57914891dcf20a4a688abd1c286d84c6ecccf9138fcaa57ae0472cdc8cd185de3d13d89d3ec3d61fd9fe7b073f8beb787495f46b23c5e1f8def25536d0abe0cd824b422e67856f04bc75e1d4be02c9bfbaccc920ecc0bc324be29c34931f58be6acd439c71d162bd9803f47d74370ecc8aa7e0a90d1262f9b428877c99ef077b0d79577d8545408acdafc4402e964ffd328b7844d52f36b4f8f61e7734e4748919e47484e484c672f9dc08697421df7aed8f4eb9ebe949e81982e82ae14f17c290b569870e314b64a6164661e7729e477fae882defd28e2518fb4bb1e5591241ab5f70c6b8b9cce75590513f2d87dcef4546682aba8a444246045521c3acd7483d51f71971ab93566a2239b84c2cf5cee2aec0733bd0aa42b2449aca5a3d84ecc41bc20da392e11b16037c3b8c731fdd7f190a732e8e0ac9ea0a7a37ca4366899f9bc01d5a59baa378d31cf183ea8596f529080ad3b267ecbf1a4ac0a068ee6096da38cb395dfdc60b58de","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"47110992e6ccdc4faed79f79d2593be452b16313ed509b847c70833c8517569edf0138ef0789edb783a301ee8d8e5fce5df73df6e63cf4cc0a59ec1601e56b17997f18d2127d58bff4364b6514c6ae7eda900cbc6814b9e79eafc43279138625aef31a28b6841dc868f214e0528b2862f4d2c6954639a3c8c3ea0b0205d091f4efa4465a3dd77dcbcdcd44f38eaa0cff3e191c8825d517574e0df01a49db2bc436d913aa092e79f25b234ae9eefdbc29430d59b1a7a0e0225984640b2b799b8377241b38c6b00cb9c16fe8eb2100508871d0fe7f391d0c03d8014d28d2bdb689cca0c6e0aecc16bf444b6bcaf3aafde336b391ff4759e966522c5bd9f0bff3800a48e219d6a8e207ebe94bf46fe4ac199706295eb4d25ccd6e1d5b673bb2827b7391fc3cbafcf5f2a7b326a4574011fe3fb4cbfd439478df1b853565e2153c2865ba941cdaf18524a659a45447c8ec584986784a865f9805f612547d5f4a571eb065faa01c77dfaf4b2aeea08535b91ae81edb7e62bae4daeb605ef0e9959ffbe7411fb4c2808d5f8eb540b318b0552b3052dcc1252666fb2ae8ace26575b862c8ee09e181eb4dd448552255b8429de77e1c4881c47a7f9a646fba775c074da299b329c8bac9f0bc5736963aa54753f8b20a7d1d083a2ca4782067fdcfc158ff9706e26d33108900f0f93ed8d8e2e3279282fe1543474ff4599fe875df0a87a9347f6d57c748a4596d2a59fe3a741f285f1b4126f72dd827c357e53c45a568d2e474404aa93aaf1e188215a8cc30b8d9967190a2f125ae0351349e5de0aa490cc8d0eb1230c4eff33a1253e89f31b69708430e6e45502a3895669518c65416d2ea280f4e3f10128082d357a581b7adcbbb35912c4bef9fee5e06dce512bd7cfed7eae990b08467b23e3153cf32fad2a249766cff52f848d86bd701cc047574c371c627441985a3be41b7cbcace756532fdf4a56d6a83e7da94288bcc7d636ca1357bee723315f1d41dc3d7cd17665e1081d77f526ec7385852d229958856312e2350e05ac705f43b4475843a4372b60bda566b425bac9713494bc32ae960718ddfebca2454edad25e01244632996e82898ced21d6210714a8a1b3978bdef11b62bddb4a9243801dac18ab7d58bbcb166a4865b4bce124dce7b28eca383cac6d2313e211a9b7780ff7f49174f5bd8af6abdce435ef52c67eba60eee99900c1bc91da77c49d1d597b5de00b34809a1d8297f06f3f251cc5d9d32b2a1fdf1bbeaf784b06eee9717e723fdb513c1c89934cba2abb084a6162174a33347b603f3be93a593a067a7341bd2f493ac1d0dff01a7c76fa63bfc875f352e233b177e9c7c1516bb34650c0c0be8e1213518fec9422bfcbe195b7c98373823c067b2bce2fab1bfd392e90ac173bed76a6166e6b83cd1901b6af974a5f2943c6ce6467e24c3d285825079f5e7a98f7aaedd72f24403a2df27d07184a8634f6b3481e8079919533e8d77d3022571c725e927d5590c135789d5b05166302e0f57ce80c1adf257eee738b68176f9fd2f369525b45d68d12b6cdb68a6c3cb23b0ff3722967b9a3a6126c498a4a2e4f48ec448e74757ee6008821cffd4c8f46e20fe1f16addb9759db073e22af37f2035185a9eafabd3bb0af2c90c4f832d8f0bb8bc7de988719e27960faeb80f9791a64c4352ff6f6da0add56ad45b65e3c22bf4ca5f56515278e0eda3499e8504baa3c5910b08abf4202cacf75aeb7c065201c3a10c165757cef2471ca3cab9ae63b891bba5a00bba1f247d4c651f0ac0c60780e2db01345d050f69096d4f3ab18b3b49fd272e1e61bb73f69fcccae0dc4ca319fd59f4efdfee9d474e5d6cdf6c8040e0e9c8e9a97207cc7e658f55c9ff91587702dfd77c7e375293fed09fffb5cda3c25f164467a37a5337971e50092765e383e977d554bbec86801f47494249de431307c592b68f02e430c662a65549d6734f1a70fa8058da9c230a1ed4c9152e5d70fe61ddff19fa0a66078b7f4893468da54f81c3b8bd2c61af3a2b00bbd961d03a1c5e6299717f0fe22befdaf77d8b0a883675d92c7cb4e366dd15a28d2bbdd00214845443669a6f3682e13080694c17443266f4bb41f7c897aba0f69027557f8b5e89d04782a0d862df6d87d213d32635e9fd6e35027631f8c1c9d04d85226175eae6ed8b8762d95f5c853c936eed63bf28a79a2ebb135a1285ab1b8479eba4b80736b1db5fcbfa99447aa09b61731dbd707d671f13310b33693a839ea24ca832ae2bacb27c18d2deb6ada407915eb133ba2481da19aadaab65dbe9504097606718afa2ab1c29f51c97fb7e68526307d268de9f2e014c392980bf02877a7424afd492285f6a47c4e681d1b75330c09a7a9ba0b82415415a8d29e97e49071559cdd8506297c0ca788cd7d8a6596e30b516c8eed330b52ddd575cd7f897369e2ae0fe6956b2c76a34740914217aabafad53ed4e9601c3a126b8758b9e3a28f6b8b7485a5bafc442f265bff2cacae3995104d6c257d3fe6a74688a9d3c29234e2eb967ed9453f57e6d0932c5f18de113b12675e18fe0120da48fac6b64a1ef61e9dfeddeca9d4bb89895b3981028e47af0fe3713982e93f983abfd674619bc1013db8e7ac6cec9c61c610401a46c211e743867f9afdde3d8d3c2d4e1ba9e0a39e35de6c729fc41d82c6d7d8a89e3f410fd5cd6558401841795d5b266ccc089d2b6243edb064d607984e26eaeaf3bee112c5f4ce720e1d8e4418e0b063fc7f31ad5b9e247ae73a1ef539627e582334f53d35b75b8ccd162f99675fe4615fa036f8c89d9d6d6b4c7f61eccb78c6dd2f924685786b28a6b4b57a41c0255bb2c1d7b9f703b59426597da827a7d89582fbbf232be0d66f218422ad11327a37d9bd0a71d26f6aa990237df1ba3dfa26f0a1db6d308cea27e6a46221495e73f7ea6b7aaadbdd8cf59635d25c8d24258e983bc172daac7dea75ffbf770985be859309da05831cf00cb3c78619e01520ecd1a0d597ac062aa09fd9ec08b4ec40d3f480217d1c13982d0e15241d750bfabf63aa1af68d5067ae06385beebf9f325a5d8576073b2664ee65724325d2d0bdda8721b3da8f17daf9a0622d6126e03a1330f24c34b1381383cbaa418f8421575fe28b62413df083a8abc9b70e796d69036e3cc10ceb30a8515ad1b88e12d8c94eb106f529f70c5f69dcd2218e920e77d7375d072fbb1fb5e28e6a305cd2d6a3821bd57a01368c2bee51960e6b8b934fb7bcb55b52b676a9ec142a00ae39dc7a3c23136ed1d0c924ab7ee95e9de85447764e0b30540a91a9473ea264099c5b5942215ca93df3616f780e790beb95ecfcbc7cd3bd8926aa6601e4f5874d194b5031c71aec9b01c1a106b4775365e889bf3ec24145a97d17cdb10cc9c0dfab9c3f17ed948f4d97514998cf98b6a3d1db523a93ebaafb195b738dc10d6c38d62ed17ca8fed99cdb68114133d32a3c98bd7ec944c7675d90d01003e289139bd748872b73c455c480b72b3a105ec6c2b0d88aaf96b08738f73685e5c53dbc6a66047a3df867b1fb6b690d1bda5670949cc6be05ac41430ac0ff139087dd38c4438f6311ae40751a9d21753c33983a54675c8c66817efecc760b0871f7bb14deabf510991010dcebd59f818d7609a5d82eefe03f06cee8943f75590184027daa35b59ede5c09b2a7e540d79819e3d8c5bf9da4dca33c0db29bdc7a1e478547b713526b52c8879ac47255bb810f2e49e1961fda131059c4cd9f54aa1c7dd483b6b3a9f3583ad21a2353f76f27d1b68b79abf3e8101c433218f64d251031a5ef6c4bda4c81c8b08d093d7fdb07d279ad242976f358b051b23d1e3631399711a0e2f50ec6959db9c0ee555dd1545604d97e661088f6e7e3902ef94eb6010370c057a9cca8ae203d4661318f5a7bea2b90f362a15e81692470b078bfa45840e040bef9ffb962815758966515852b8dcf323ef25f9c4cb42a4d758d08d8d79797930501730a2c66702dd777a447ee1c6712d580f3707fbac570ba12f54108e668a0747004960055a03a547d51fd7af68804cd25920b7141e381fce1d011b4ef644418082236d2aa072e33fd69279464aaaf9da2895b9ffbf15815362319e20feaf7ab1eb0f376a99f4ed48db39ef5ae0131aa6e5a82de9eadef528aa1dd7641b67f6bcc21ea743937c4e47d5af78e39ce4131420cf3875d3d860af7f7cf0726754f80bacf392f74afdb476d639553bf335aeac22e87b5c66b323bfa2f05bcb9ef85e60e54bea40abe202eda76102bcf948cc598d0a981dc7bd43478543d0e0c45b43cff71ad3a4ca727f9e523f3d9800ff6de0fcf530ca6b69bb7fa8d0f220c29ebef2e499d3fc831cab89f962410fce5bdc450b20fb0ce4985ff253269ee53e8b354f1134bbd1cfeefe79934f47d702cf97f7d445d367a52d420d0dbbe32cd524b650335f5d6f8a65159791037d45d097e2546738a7b44a79b47a7a2b4a30025cae3ca75e2441dd13ce8cf7bf6cf61ab0d984551f1872f5d6dd20845f501a4482ae1822ef580fc43bab352e187aef133764d6fb208ade2b27a4114acc5be5883cef69ca51897f05ae2739ff3d0a3fc923f4486c7ab31401a9b3391609d61e5e183c2963d6156de75dea4b8faffd09635bd395b723d4769fb6915b6a8a949b8cbca6e10a7396c3ffd501ddcec540ae167245fac96dd0833c4cc21c2a7792bae8f9414de822cbdb395849df7be4b14b1f3e33b04e0bea1c9cac40047c4c802bb49b61e1b558689d3357e5e5c768b848f9e47e6e730fc8d651c1d3c50b49a2b11848464f63d69b6a1e38da0bbba5567f414a72d26eaf06aaad212478c503d634fe62c1c733940f486d63a7031e3453676af80ce676e95b3c9368591d475e789773cf65df3e67af336d795766e87454e936bd42441664988a8d98a84efa9624fa23419ac903e43017d32ef472c823be6984aad48f8285dc702aa2b6173186dc929c6a0e4052af2455ac186789ddad183259f294423cb6ecc51bd9fba65c6e53d12139846a49ec13a1ff265936e00439fc093aba73378c0baac07587546e409e5a98f5e7f4bace386a3d917d0b2d126c00e793354e0c157d7aa33a23e8c091a42173214c29cc2373e4dbdd5322f3b1fbabf0f36455a72252d938f9dbe2c05eaa3cfd149633277474756fa086f628c43a936e8e540ea62ed2ebf3f3524e3ac049db1aa3ffbbeded0a9e9427f9bfd46d8001b55cecbc8956dd20742f90acb880ae728ec92b4a3034f45ac224e139312f9dc31b6518c5bd491b18ac7ae2adda8e6bedf8db189c6e4996477074bc960b3a00728218030c653d158f427038a16fbeea38740daefba70566eaa48fb1505f25eb26721800362f6f9fc80826cac03001e6c77f0352089475dc2fb9bd9f9b0cdfc9eec225931f53d9c6e033ce13f95dd71f02c284f1f22b05ed67be41b6c3aea4367ca3caeff308f6e4067446ff983e4526fb8a7259946d773a840be1bb5c34a145ec179347b10ec887db1259ce9f4ab41d19d71fb870a25d1358bd8e32eacd19fe135cba10fa7e27e7f2f742b03b71088e97017a796394ca7d9c7017be0806b1cb48f6591ac4c583a281a4c6a86f8fe6d355aaf56d0dbd1b630c79d012c188a6e335f339ee8b6582749b7653137e3a3f8480be325369f73b1c082ec36732c813c0ade32e4e1cd49d8b53d4d6cf07e1d480f846e322b1bf96f25622576d30fb8d5929502c36eaf1861a2a3a8abf7c4e14cc07f375649aaad07e7aa24356525f35b936b29e1e6ae2304cddeaedeaa287147169dfc7c944316248702de7062068230adb8e86ad3393c619e87fe3a5e87f56093d81817c2835355d3728f7a2fd3a29aeb44db6fbdc6c68778ad374235040aab65315b1dea3a202f0957c68db65ab79fb8f83cb5d045db92706c5ce6b6d0bfd4d092141e947913538d11b6bb8b339fa939604dc5bf30cd75903468481db80ccea6c54ebda482254e563a85c2ad1cc63f923480bdf69e0633a53381c28cdd602ed907340639312a87087f28e30e5845b44cfc088234d028e2cbd597a4764505584a4274b4a358f590a0d8acdf4f5d910c7d51094d525a73048bcef570074c29fc4085d8f566244a61b64b9af44c1515deb9f12d38cc3b034cac6f21d7f8bfb3d409d06336bd4aa0712888c2c075b00e6d3f402293f81da3225197283f39976b3a73d0876ca172310d18ed1e802e478137ae95ca06ce1f7ccbd908a8b81f24d6d579ccaaeeaebd115fe3ae52a941e72b9741caf491fd65aa42aeccbe55d1d06393b1ff7971a762391f09626d06b393572b94b2c20a98d5a107127d76746ff8ebc99f5942bc95885e6cf567731bd6b3fa22fc45188b2cc6ab3d2a18c73d9feb2d662f1a4af4a760ec99378f6386bc5375202c6c74b2c459d42eb2e7058f552036a963f959136807afeedf04983cc7a496e135be4e94831fae3c70dad08213405151988039733efdcfd6f63d162522393c9d44880c4eee68e7b7994d4c97b996e3098535ee04cb8a9118d481cc9c019fc9e0ab8338a2dbb654663d5793cc0569bcbe39278b99fd07e2d6b41ab745ef3896cf12a29840dc1fe79f84c90d6c2c929de4deb76e93d2702474ec7ee2e4ed2bd36a8e05744d35c6eb2a5bd3a8d6403cb08d07ddffa4dd2a01bbd2ef1ea5692dbc61c1944c8f8d6d6331fd82bf54c8bdd6c7aa72ff962f7d18fc39a11e9fa732c79aceb467f787999635c62be59f74925d349cf583d2d33dddd712579698eaffcd3e50ee79987f1026200ecb85d3688abf222a86f60cdb45bb41cfba2cb36ec9b2091aca2223a5336bea4c0a1330e207d51a58ccc5a5058f88c3c1391ee95e5325c3b279f57565db98769428d99e916bdde91319c61ba49719b5fc1f9032fb8aeb73204e375eead5c583d259ab09e779363eee61ab5821ea841551e6ffadf92a770a9975d4d16ec8978dd89f7f41c57c04330dc29e24eedb30bef8dc053aa73fd9bc6f03aeb84c546df2fc15f338ad0509694fb15437bbe5e147106640dd434c7929c87fb448d3b5b15ebc89750897936017b89b77a698ad70e14f3d658d3f5051c53edd2702ffafecef2ccad3b3b9aeed1dd117501857dbd87f10d0ecbd32dfdab6d0f08a15b8c279c67978a2c6fee7326dd393e9c0e668bdea162f474e75724faf002955c3d2b7b8acfa0e2746e781b8c0ed17f7d2b50f2907ba3c81f5f920eef4f771524052798bab44756ac72aa7d6cb97826c5ff936a87fa5dcc3e21453c05ead340e5c97d51f92bfd40de5d9f2c9ef78255ad7b599f4aa10624dce1c147802287b9f5a2165795a618e553d83caa8b30e35af41115c403396181028017b6b71160f1b37bb587b52a6ee1389c155ad9ca8e8da8252ccdefd538ef095f35c695c523daa06a7b414eff3228c96f3d8ad84d6728d109520f877cbfbc3cc8726045dc144f1bc1c64d26bb067e1a1fce38eebab4b5dafd09537997cc1167aa7de8ac14e7f97b343ca1a509f248d269ba5b4cc3d350bcf9f3d41ed29b344003b8a850519d73f3daa11bf6ee773faf5c8473a1f18cab49739f45f3f6755be014f1ca24c6b31c1221ba5b75846a5def7b268d32e6492ff345ec2da17ff5fc20efd715523bb9be94019b1a59b311d602205795551842a5f1024f9a260ba2f75eb9ad7918bd93954f8713570682cafc3f526075360f33d1fa66a5701aa961736a1ad4b5caa33cccfed1f2fe24b1599bb7e700db3168bac54c59e0e0a41df1b4b2be299e3d9fb4a647647eeb418e9018fe66fe46a653ef9ebd9cd531c5ce9d1d71fc50328d41fae49300348c8825e639a39ffdf461a18f62559f3ee735d198d0a38bb8638fdf608fceff074a8f07c59ffa0e5c7584a07f2a3765a8cabe3c96b79f5210b5b5890bac4904944899e39178edd1effb0319c85c1f06ac1ae0aebfc142eb32d2ab9a8c7a14f44ec3eb5f8fe4a8ae2bf6339af90fdba595503504413e838148b92d7e34f1d67dc8f2dc5405b6aefaa9fb34641536d8805b998580924250b8975af604eef49486ba71acc8396a66f886deb86e340c3d64d0a3cc30aca9db47cf506f78c4a3b52873157407f1d0b2e70155f79c6c59d9bb2706146086aa0261acd5b27919e5b09943df3c697b77c8301af7a321e8597ea18b250b8f2d027cf85abc7c46304bde8e678af4b632c71a56aa2a37f8cf86a68c5d12dd0d8245c9c6e11e21b9046e6021ae23ee021d6e7071fb31699cfda3b15ece8d000d5e97e70d0e4436f3bc2a9740b11bb188e215f98d8ff84f26993c4d9f3c68b394cc1e63d6c4b862dc726cfac49be4faf9e73a379a0abc9ba7d42ae03033738b00517bd78f68a1bf4ac86504aa6f44a44b9be3ecd2e91041adfba5e2fbdfb6e4eaad835dc1b13680efc5427fd696a4d4234cbfd50a0b4af0e696b9333730deecd2d9bb8f9f82d90bfd3e503c86a1df0e678c9ec10c0f08693ecee21709f48d3d89bb03bb08d483f0a8716c534c00de5e84b14a56fc88f8141e9645928740bc7070fb9c78a6b87a313ad1ae32b14b64c49aaee0ae8d7e3c650971fa20cc05fe462f66abbd8b3c245520642e7affb2bf87400dffb66d66a9eee067a323815344e1316df78ccb21d78d16436fc4e7c14ce6812c5785a75f5068a742878cea6d5db9914ff59e9e7d9e0d2039d5489976bfd9f986f0dac19d5baede71c23f24ec81fc347eac1e62d9382ebff010fca8c6d9b7a295d9d532c10dd328caa3d1478eeb3f28fbbd711d3535be178a6027b74e5cbc25d0afc53a6f4b5b18b2c880ef8cc3d90b4c1b9de77a781013882c876078bd1bb29ce798331b0d23ebab06eaa7084c213962212e7e3a3c7b883716af9ac4bfe9e4235328c0181ce23df8b8530aa649c22253e1715566e1b26aef0e344617e5a7d74a637619edc61b0c0d16267d7cff4b9c1cd51b23f2c7fa78b55df0c235f3c119c82eda7e8bfb62455a3914e2dd3ed4fd7f6a3edd86d6e904fb92e50960e8943269c791c5a907a92dbf8af24f99a479e64c5ec0dfef37ff11e6a7adb2f1dafe4d44e1b598cf55450f4a8d72a6eba36829eee16c14bf68d1a937f8326e68926e3629e920b4e1e2477b98cd8c2faafe40577f506709346ef7ff88570a43eb624b4c82c458253a027514ab70ad5ceaec17957800ecc5bdc1e37d271b297ac5821a70715b6dbc7aec27201e9bcfd0e07ce831c44ee7188db50d48f0c27d346271c07ef6ed5362125fdb1e774d8223bcea99f0ce541112fa700e6c3ceb0929195cba84415e9694dea5092fafae0be293554f5824faa376ccafc29fcb71261ced339e3fe81a1cde5ce9cd921bc8d85e221b8ca501ef05ebd31948e42efb00b520cd5e15075af3d29cffc86b9ac0d4ab72310f6308e2b878c6240892db3a39a003bec3b87076adcd4eb91e5d155f0ede6874bfc73587afd9a99a08eaf69d67c9e3a452008adc92cbca999b109a540689466cc1280f6c9c3332fe49f4690d0ae7883bdc5e1486e6919f34d1d30ccbc4134ec5e0aacc229d4413beec9113b866d0a1d8939388d52c1b5fa980a8f2dba0153c664d4c0c68d79cd9b3b30e323f524f18b4dc55375bf1a8c3ec2d82e46a1b09a23a48321a02342bf742ef6d1b7989930cfacac2e870dc6b912287a9b9ecd482e87aa1cce0e4f8d27d5e7e27f8c24ffac3a8670b7ae8e5d19f57bbbab5ce1d30bcdc6714910769f57fc206809084ac6b9e4480bf93fa531c64aaa550e76174b8ffb361888ca8841d5481100ce21bbb29844fdf127e471b18a533721949672746fdf51d2848ace84a75af9be5bb6276c1344f09403a0a194e1455bb35b8d6ece03e33892a1e443d591194c9be94b182d69d6792190f6b3ec1e80b24c407beddbe27b375d17ee632826f6fa39f826d6fff622a852206b42c1500828f723fc8c8cbe609be5b56e8374e10a1e78df2ee93497a2812a8a71d3e60f374b9de5f44117d4664d5697d74775e398dec4d3ffd63bdf749426211b67e4fa8a9446a08a3be0e0f0dceb14eade678d1f25c47a9ee0bde1dbde50abd9d564cac40dde3a0e398c57d2580332486a57a9709a9ef9d53dc39e7aca8c38d769d47977de24bd2947fe0166f2e013f1e828d32d8cd1de319fa8ddaae1e5cb8ecfcaae76317773b0fed8672df3a1bcf77c154c7b2119b97ced786dc8999d6bc0403082b3c4c31e63b6b04fd854caba912bf665931f2346bb4dbfa80a0d5f568b36028034283393f4860448ef70b1f7da6a12666afebb39928c5edaf07cbf2b5898a7661afac60f51f119988972eb08299dcb41c3dda4f16fd4f8a7cecedcfd17d7111c4481c18754b35dae41e2d5c32b523666cb899f9f53ac9e9635a3b786d73b8560ef0280c57b49ce85da393a4b5a3d76a611a7a97e69c36d4e28076b62a515e6123360cd3a120a742dd7de0f5c7bfdad5752ca17437bc189cc8af670a0277c2e34990bee5729de59f5d463e3367e5f6c4bc3a1840cd2888fadb1b2079e7e34b683414d80436888cfc9ea2bd02b9c65a1be67b85174ffd5e47b8f0cb610ab3fe68e7d3cdf08d05fc9470321507626dfaaa9d16f3d43130ae3ca2a9100d16f5e46531379178ca754cbe2b3a0511f37ea4d8389cc463b85e41c8868db56233ecb238df77ad68152d232fbd9a6e7978124d2b275ebed0065e275a1c25703ce56f5b0b2fb290e05a02336d67d4b38bb3544dbbfe2af1e3855bb1542a8f4b3d3ad31edda8ef5f4d190a0529a3122f33363ba21b30ea7997a6395347c85dc2d9f484439947fd06f52cf44d2c451f0bdca286fe51256457554d5b4c2e3f59a585cf2531af265a02d9c37e5e374cbd89b4f767c5d58498ad5510e7558dd5e30f981ca8ddf4f9c9d13ce60d9536ce5258ccec6cd555379f82b5b74cf2670e5a44d879bce8b8c0b9ef9ebecf96c0c1371d19232b0317a68399ca082b8f2a4cbbbdc901952f688da7bacce1c32b008419f4889bc5e8f007d4446ac7278305a95562d662d16969c8b6fa0f633328af7058dde26a47ab941a0d8a6b065072f74459f85872df006c5119b84467b9094b7d25fd4bf3d413e33c38917b0b57e45b49fb7e42b3a12953e5770e9d063dec9971f043e246c3bb460e0ad46bb62aec20c8951da157192db8e6d06e087873a240acfa490331300e03243f4bfc438460f87d9f2c345e76186ba77f59a7f63ba3a67ac7e94b7b92a11564cfbbe39df52dd6e7606f3d605b6b7fc8fec2ac203933b94ce12e4a8ba077abd2f32ed08d2eac86ec138598638379ef25e370c3ff9293d351b2130aca33f7c702d92c00e37cd3d6d9d2f7179bb360fc3b56bf3ae601eefeb63c351c2355c1934012778cc9f8da536be","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

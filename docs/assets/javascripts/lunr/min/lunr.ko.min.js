<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2bdc0e7f5d2eb311600b58bee3745b07b62e116d34a881a9c750b7d3453b1cca364a9fed6d45cbf979016feaba37556ac9e70b815858f26b08c34b86fbc34ded0486e3d4ae02630cec5b17d46d8d5aadefcb1b204801d5e584b3403bab623cc041126e0d8e714d8c74962b85827d0dd1cdbc6a0ee18b84f5144379854af0d276691ae779d87ae810623682bf08b94c6920dc6b5346c76b640e2da0b44a137576d632c51f5655bdb18f6bcf7a8db25c3e20db9a39749e3ccccff3b2bf7e7646f50a2055ef2ccabe06d55f7745e7de2c50a7d0780770d4d9cb83bd9ce7b30caa6f1e0b2b47ffc4ce3357311fd3a416370ce2a0fc8cb6deb2edda463b761ef924b5007ec3d83df38aa7719e57c6b78785d68b15cc4a37eb8371fe8a30cf0494bc9fb162819c82dc3dde71d6e32dc2fe5f011ecc8bc943bc9c34ec561ad9dfe18b909bd21c74fba4445b36d7731b58f271ca15fb94f715de0ab2fa586f814178e79397471a915fe195c1207fd4d606f23b4ae39a5a8c34f77a6b089c13bf74ca7ae8f94e8684260549f710a4cb6d9976c17c149d36ef38006ac96802410ebda69c0f49d4184f00cfbb3e105c5dbcb61181347a5fa1234d24b1f7de8a305b6b97da4bc9ab4786259b8af684a7f48fa495766d8638f7adf7a72e7f76d4d8f0c9cbc036234a1c21e1aa15938f476ae6a4f664d7eb505ff91f84052ba300aa7581e81dde61c9d8762caeeff7ed3e8e05e64272b0672cc18621d6440836211851733104bd64a7c78cb76fda6ad26749640861fd03136702c4c3e53a7c2bd0a363600e8ba2d22a9b6e24f9f0ed6e2cb5287bc3ec724bd09ca80d3fdad0586c65cf704926d09146a736ce25f1d8d9fc022316b6f153c3d96863a2d45829a12db5758531c29e08c649f96d1d9f99da09f83c6aaa5980add5f1af8480633e9cb2c1c2fd68a4bbf277efed20dfc9e3d2e6185a224c8470521a7f97e6e15979b09fe21525882a24081dcc1b610719a82cb1ad92ab3dc2d483579865e86b3cd5b54e7f294164379cf8d0cf11ce00c11750e0b36f8bba225f62e93ce0eb2f8cd4f36d3ef3537e3da741f7803da16d8db8f995aea30801eb4cd1251623f043034d38b7be7874131036965718cb803ad005bc0fcdaa56597697fdee7e6e6ec0c5421f4f2f5bef299e3115391344cacbc15d5cf3960a5c34565fe5cd1758911993392535bb49205a30e2ed6dfd48a7ec5aed869af127e2dd5211568388048b32ab2611d0995168de7def108d9c5f44479f701bb5d908e931903d5612992dddb317fa1318d3934b7223fa9f0d07d302fc2e4c6fe01759523dbe7ef311c82db7733fe6a9631454da142b758ba83854ee615eef7482299e0ae93bd01275dbd75a2cf86e5ac365a7e6e90d3295d15bfd1f41ea9c6edc7c33d0d7b1026def3adc656b0d456d8ed01c70c7805ef5e372fabcf8f0873aab8e9e38dc2e0d1840b12e6d16b7eb766ed9a05877ae9aec5143ebf3d3fb58c3ccba368091aada09242bb8ca31f005c09d5f4d5b029f8654624e7220848ef30c1c8e5ab005d461eb843fcd9d78aee1d11a6214351fa5e14ca67e86379228075daebf07e9c00a628c2f0faaad8fecf5332c63eb8d0a57c5aeaf349f17e574d3e4d9afc01dddec5e2cf4327ee3ae33914245c976c135df318ba003111eeb44717ea15e13e7192c1b65ccb81abdf98a114694f63734d0419716949b38c02145d00236b8b1092da6edda49c2d7ec2610c4505e3bfac291340d97698159e59bfb8c6f24267dfa5ff5ecf3af226d3ba32ae1745e2650d6120fae28efeda90766c0464036efc82408a599efad418ffed25bdac6eb92f952525e1c450085b9011541daed0383ab984c05fe79cfca515609130e2f1d3829ae30a7e1dbf7a5ed019ad7e053591b1408c3e14ad0cfe9e2d016e0032c2955d2358a67dc14534a6a723648b2d0d9ac91c937a8443431f94647ee2065d66957e748a574e428731ba763d1f509cd4109824465e61ad4c65dfb6bdc07cb23f85c06f1b47e3565d44e4191eb247ad2cff4abf82474c93f6c19dbd394116d4c89784b96b676d9e14cff3f67aa4e592252fba67310680692d7bfb34d2aaca719791cb2f07f942a1af60fabfe0e49c9f9b92260e1c1c6caca43d1c60faed829c7a26caedd8803957f94ed674d24e6672030ce765c53c3d012351375cd710b41e2fe8ced19b5ecfcfa4c4bdbba42a437e1dae6a759c0ed16854ca4d52dbb1fbaa3424bde49bb65a4de01588455ddfab3a9cbe17fb704c32eebe0527bbfdf9a196a9c8ab58ba52ac4eaff49c58fb0639cbe5c3299a2a76c978ceb3e7d4f1da76ba62b3f38a28106af62521924baa806d22f83b8c34a371b018f440723d1bd61688df60aba2f304d4310e6140b4eb951b07c412f9f0b760fc2b7e2e76292fcba0eec005c09f46ccb1275487ff04a0229bd6eb64b019a995752318642a510aa7f37dc0b6ce5bd02fda5827d8b3999445b75e888544eff7f0e8d42fb15bd1231966db86fe7195912d5222cfa98a635c86aa8f10f0921e97e170f16309ccae075a521feae335874044274563200f7c26f6fd26fb3f9792787303c16958100aec5a7935863ef41ea750180afdd1f87058aba11383fa331aa928d7f243b9c1d7a34ec6482148cdafe028ceddd10949e1506d5bd101ba16381661797c162e41535e6f079a178b9185b7f6dc3b37266f532734490335a4fc72231f78ad53631ccfbbedafc780668ad60512e4e8168307fb0ee408e602fce507e40a60d9f2bc66f61971748c608589bbf64752fc0d6543f59a2ba25199fa6ba2757adab5b684b453d3150e69a4564c54ad3f50e51a217ad1459d6051ea0182a2a034f680541da4efabc9f892253f9068a0c62017b51751b08fa6bb56dff062eb41a20e5822a826fa8615abb80055a2708be18a3621aa81b0efc4df7192ce7f460a47feaffe61603ab699d70a29f9a30219da48ac9dd618ab5d38576a2e46c1736a27e7a7a36937af4ef87bb8a98dd61cd175d8e297dff2a60cad788a9fca25e3be7ef50d7719255642b41fc17a4885454cfa6156548fcbdfc4266a4c63bb249b8a23b4d41db4dc1d36a4ba37a695448e9b5672302bbb13485266c3abf94a88260ec19642bd83d36b65ba83ef8024fe1ef5d8aaa7ac82b96ef58bd6aff848a55c7e5ee5ac405e570389e6683c3c576b33c69e1c51ec1932b68ab882bfce8ac9de0cfba7df7eeb8e7743add437609ec9533506fced7ec1671ed0e7eb2c5f94bf7365ac4259861174ebe9e5b44dfcd6c348babd6c57b6b7a1ccee425bf3fbd0db94330569e0db3e4e93346d0815c8f6a90319ae741dfc0b0f9fc2eb1825ca5f357fce6a0ea83ed5b3c99afac8861bcedb2b3bba7319559801ac837ff29ea43688fe53f0a619a2b95a67a6beb301a60193c57b39629f1fc4df187676db7367bd80942c16d05191c6d84187c401c94feed39daa9cda7e88b4c9621ba53cd25957c45884057a08e99a9ebb73dc565eeee1a1b2c5cb30c5a4403166bc2facc80d9d5046c20ae1367f33f7bec0e7080306bbbe36e12f9e60d66873745eb1725c712a6ceb78227aac833e797eaf63352ea0ab00ae007f3fb43f831f801f0de24d3999222a2a2d6f91677d10b03a0680be4d6c2de5e685a079393c9a9608254f40fce07c43b7eb98b18bb9dbed5aa4615379b62f63d6bcc2e429eabf3ec974b964beb74ef6f6329c52cec10c985cfb3af5ed46edd28605b78c6cb807ddfa52b8dac1566352148ee695b980bd2b4be6fbd73c89224794854a837a71c053c1fd2896413fd0daa559bf84f29ccada4bca7f630e790ccd61f58782c3a07a064831dec1eee4d287e0c1ecae35c4636a635c9ea7341b4b0e18742825a03213ff31040c8dafd43e3b0ba2d67f418a2dc903539d7e104603e582168f5495295ccf025e1e0bba13e281b1e09fbc6effe01edb7b315d46e91e4314b8bdf0ef341cd9b27f0c8a46fc9d9e8c8a54e0b6fd6d92bf8f57cc185caab1764b02259e6c095e18198e2c529bbb0ae03837a3b9d73507f64756484a2ec596ac2df837889ccd88ca30ce64626504a9898b6ecdf4eb58c0dd6d59386db91b4a761f34998126b8253329531955de2dd3a70adb1f18eb61a7565bf7e0a7e7ab70272190da5391b76fa64b8c9c076c8d459f2f61280fa4bc7587be8ed9760cfb112c578b46bccca0f8259c577ccca42e0b82e1ce70a4389e683e4f21502aab35eb8743f33159002b1948d4a1a1755c5c2ffc2b5436788c41c3c5c87f44f18d8aa618ed85a50eacbbe68fc387ba93594839702567c3a96da94e8236431dbdb46d58f0f7c8f27fd3567701ebffe8ab94302f6a227a6c19a7e72bb2c50dd5654c09fdcf497a828d206ee411bafd10e7066dc3b1bfd34075a7919b51d72232cd398bf724e41c1ca37b99c45ea908c478ff19861892ca0c02a254abb5c7b6c0406cf921076d64e4a5eaa1b1aa3de5bae733a54cfcd8812a515f7692f6da65b2b4d123587adc076fd92d4b608324f147db87f01d61a3cf1c5d3872dc44f5c1f43f9bc23b0fba5b8eec9faab94a4baf5926654f2694fcf86203ca54150ff3966afb112c95f60560ba34167e9aeebc52ab6df8e0a37805b7247c18d4f8a713741cadd5d49632497c0cfa00545a2754248c1979d5e80acce13dad8c6e489d783b3c7465f1c6f046f2824f6a81bf7b0dd580b1886fea2dd6fb7311f4f5f106067543c7d654ebd56f6a56675ab1b99e61ac57f0efbd056f70bcc986f96eb77a4bb2a7553fadc44a06ef47afda18cc7b270c573f30c90832218feb6e294077728a79325dc300b6b43c349534528c9f808dadd43b60ef81eff685229ea2c6fad60e7264274a49dad68e2dc973ec8876b4b6ed15fca7497a8c63b3a0c493374be3dec6db0df032736b3f010fc815969d660f5ee640b32203f7d52ac95ac0039589a5561a9bdeaf1d907083c00b58071c43261df0e017f52e5ab9cdf180295b3156dc7a33cb60f5eebd175bc6a86024aeaeff5084d2805eb5a61485130155c92712507fa4e5ed065d023832eccc6842697a93a94326a3fc501b45255ba324c3a7514af706438228ca5f81147394339ba4f28110aee2ced4e979e6c98ce17c97a8b7bed8deb4afae291889706eee33f26528f2516bb657c551e788825a4e484052c7c623757a7e63b0975103762c1974cc9eb768c8179e89563351cbee40a5719cf23829f31debab620aeb1abae34861f204677e516d84f57f93c1c5dbc11bfe9202ba2da7e46674e6aa3d9bdee61261dcd5730598ae2ea89113529735f5012f254dbb5a3a79c75f0d65f22a00406d2db7bca988b562b3384249229c35ecc7fdca42bfe49c710472922938919eb5d8b4a01f5f3028043a65959f8b256603295e4f798ab85d46aa4d6556cbab4a53b378e22aba9a3f8cccfba2d961b86794fefe49aad1bf8fd578b317278d175cf1357894c464894e127045b320975972f35f0fec7bdfdbbce7921e2ab821f156224605cb8ac6dbd819af1a4b8ae49479a4ff1121d5fb92567259c922043a76ce2e91311be581bc28b0cb370f3ab1c6c3bb84249f089e23a39c2d54dd274a09b301ccc08e209e27f5f959cbe444da8110c7f7156c6a022f1d45f750a3cb7809af299267fda480a715a21ce9f1d89a9b3908417092a4eab182c29642f80275c334eb1b586d0bcce50f6471dcd34de67eac8710fd100e3f62591808db70e5d924b2d76769cea9273086f050935e4edce131976c2c5a4f7146d2a930f738fbaf55c9c012f3c0ace239f4640a66a377190ab6880c418e8df35864dbb0ae6250fb983aa573dfb6c7b59b9e39ce3c3381cb4c82f98dbecd30823a25c30e04ddc1763ce8676ced79f0ea97cacbd7298f92d40a0de2f7e86b8fd57345d9dfa9f07a446c7fe689d50e03e1167d66b15e103b3cbfebc10aaef308c19c6476d2f7a81d41f3e551b7a9712aee94b9d24a8666c3a4186eacf55fe11c25dcab060a2f12e73ba64ddfd5021da3e2c0a2582e3339ff5c79bfa2b4324ef106d9ccf581ba795a3bfae2888784b75ea8f98fcaa8d4641dc857d431548b3c2ae42dc268555cba1511371a6bc2824e74f88c0760a3a57487e47defb7d2176426392d25a45b8088f9a2c88d53f8aa551d23d86a4ac4197a36d79e3d339b7505a4d915d6a1fb77b4774561acd55168250e01b4b0213f23fbe9848ad3b22f42c46b2bdc46269bcda79e0d885a584f4736fd53d580ae6c87ad1b1bdbe936656ad223921ce0a75a6ec3d1c99cd400f84cb56f801465e2f10722ab343605754e1821cd8eb71e980b12e243a7cd0112465661220d700bb186cf52819156822f7d92d5e927da7816a1a85d93fe422ed1f46f4216d5a202a674a99050f607b19be9761d411d432790fdbabc7980732411888b0c6a249e47bf9391f2be96ce15ab7191afd07f66bd77cab6504b367969d08fadd73b6bcd05c81022f64a1b826ba25c6193ded0636e371d4f91025d911f17c6f1714d9a47f1eefe5ff7e5252f054235d2a7adc615f1b56560cb2b0940191a35b81feb0d48c6846b22918c41b6fe541e1ab537f659d851b022b702e07e231b7967f10c04f72cbbae886c736f3702526891a2880cf54d3f3dab10c4dc82b3a07cf184f9c4d56eea6059af00df7f894cf61e9c3c092155af6fc986fd77af23f1e999ae26bf50626387e501359e3fb90c0abb56c4fc5c89045917194cbf7f7211828befa1f10b706df57f262446b9ddbd1b0b8ac7f64a29fc167bcbbe1d01971955b2a11705267b0c450e417534ec6359760f77a1673d32b392186e3ccac34c6c25cc93ca11f793fe1ad40f90f71be7b14e4b12cf50f4dc708c2accee0c2fd54a950e7899b0c93810365379af11260091b36ac9fd19381817151930d7915f43252038feed462f3df3dc6153811d35d3c3a1e451c92b0cc7b981445c053a2bd2c63c8d93b53add25d8e0b66d669db7c088f5ddc269d0dedeaaeab0d46d0b4a686a806475d54997ea99c9b8f17e0c038056266deee2c1ad1289654322149448fc3230625fbd74e4d569f598acfc30c7694ba78851642d424b483587e00dd4e6270772319c66cb56e044e6bc20f5768c6d71c04ef52e1dbf71ee7b85735b6bd511cb2d1231301aa36600bb962aac3cafd51a262ac75ee442915c957427e8ad4217ac1fa7a2470d6be5a92cde5b9efd9356fc62ca836b9bfdda85fa63298027775096d957f946e59b3217d97b896f4346fef481ee3e28e41d92a82689031f13c0ae38ceddb74d86f8a0a2d965c3e145b4f45ad965a5161c00a1e785457727960f6a4bf858a1ac41a2d1dca72a4793562068f303eea61a164d26d58570c35033c44154cc767fc2c71481c8f66a6ee7eb72d0590fd13dab36511b8e6ef5287b3fb7b3a8b6eec10a3d15a672640d74d0847c83655bcf0bb89d74576fbd6f395052b59d04aab6533cab31ad0e9653bd4b6ee0d9da0b86d60ae0ff58d33739b6e93a6b6aefd9e49de93cf7f2600925bd59d3fbd626d82b941c26f7f6113d483f1bfcefbe8876c91f343e42e798f2eb32307dc6b85ecb98e2c6ad06bf4bb4e8a95b79b3a1b5c7d95fa482b92cdb8e55e1e4ea2001bf51560a8f68cc6d9261baa4cd9cad90615f463c64403941e63efcc29700a4c8f8ba63953ba36e076890f8775cc6fb4e300225374faaf86d9e118bd3ed6ef0d1dacc20b49a18c39362ef24bbe15a4dd7c38203d4db86951553c5805651d4e218a73b1a28fe254efef1cd1e681853f9f35a05ba6ad09a98573e4c3cbf106a2aba7d81ee8cfe4bc6d9b799c2d2eee37eba5df18a6b8200901f8ebc1421a6935856392d8ec22480a04f83bb8e454da63fbb3d49e07b076dfc7b298fad780682db5a02a4a346913be4b03b2f824d9ab82cbd26c8e72b7cfc884dc2edbb784cce1183f02ecdc666066ff870395c41c23bd2bfe6556e7605d29394f8c630761a44630cea1aa7588e7f11cf781b77c27c2ef37d242916d4d520b17e890574204bbeadea5e3297dac7a51e0e7f9f635a9d3af568bada6d87d4531b97ed4c0682860c095d11b3d32c23bd4db75b9f25538188626d46be7d066490dbb4a0bfd1b4308d04d94214c9de469eb8d88caf1e2cdf499cc215f1ce84e445a671a4aedcba454bf2eed2669888e3d492836cadcf8fde8b7258eff9906d21f8b065a66b1c7bf67f97c06198b809c232b20fe0430d505cc7c71e8d9df0656da9dbff61d0ae87b31bff49a1ac849fd6f50382d58be5cacd0d02e454566b165c8a8012988137fb47beb97812ea9f1b59aefd27605ac86731d2a573a43115964be246908abac3feb307805505feefa8142ca830f16d40a2f86d6299304cc87adc06af3c6c91e41f1ca9de6183ad95b956a732960c55d46fe966a48faaf0d29eb172de58b32355a775fe97d9f833fca7ca86ac743ec2a19eff11854776d0b8f180af72a6d9d2a1e3747f6d6f923d9705677206c9bbd082b7d711d918571c502842cc5fddafc8acbab59cc8383d9a5d8d7373bcccb2239f3dd71699b7fe8b2f6ac612a062ef93c4cfc7ee3ecc7c4aa27ad6f1858d12ec3fe2ea5412957439616588657914269445f48c3b71f4aa86ddc575531546b3ecf2634d20f535ae660525ba8b1dbf4330ba8aa2647ea283295567f7201e1730841a2daeb7c8d8727822d258cef52277f28ecbdf4049d86a014622569a9f06bc310a0aced9191f6e4ba50e5e49eed3dc37c0e555ecae280574a5b2bc4a8464c7d912f7308509a631f26436f78ac19262c9f383e5e99f617802a6dfdd1c2103985a3da60d25b455c7ecb7220197d1bf436914b44e5477088aff42d6b948720548ec8d2256ffdfd06044c4382b1010c2950ebee3180ce0f9f86e03682b9da9c9c9a38169239d0050be696b5dd5c2ea3cdc204d07ff2b0fcb52581265504029a093b9e6ad5391a51270fe7374849374481ce9c319cf49f3305b33134b54434e8601332c43bd66205645349341ff208ca6474990d0138a0684dfe4fa51997f810d1ad35474fd3100a80058601d0680e6b8394a32fcf0922f290a86dc1bacc3c564da40eb6b5957d6e65c30e94dca274d38102d45615f6d516ae031a25c812a25f37ecec68857353e33e843bdc76e620862f0aee70d0a780702d183f014600af1acc50d7282baa4198f32becc6db2e2d92fd8c74a508f931bcf4e648e94262e9d0aea46c2cabdacb97b7fb5ff6c3b2300b6715230a12af7b4eeb8ce84010c7711e01dd721f6ae35a47849ad66070db1f067225ea7b0bb0d9581a963f2836bc55666d7d6b0cdadfbe345ed0ced712e41df291f37554aa169d1d021f04ab52f397dcb52ef5a05a9e256c050f1b21b3a984cd1e487907d6fda2bdc93512c4e8fd0bb5e3766156166cff2895ea1d96fbe2e66ea2ec8744c93072fa159e525e06a9b172c0e52e1cac333e0b6d424ea9c76e68eb767da152a74fab343ddf1427eb4966eef3e0b59e0ab6464090ad9531fc3b0de9e89664d553be6ee1507244ea2df54a21b969a9d0dcf6f7a2fc2864001d2d990089821b636d6c78c2e67733f456c82c73a6d311a14db527a7610b2ec6077a36446718ad689bff577c303113ecd3161526f12c8d3f3ef122c21d2be53b0e368464b415fce17e5b149b94210cd92b36b9778e50c9519758581cd3c53baa323462caa15f9fcd5c55e64bdeac3f4e9898c6f8ad6e1a13b1ff5d15b5857e19c8a3bebdf52c0b6bf1396b2bf3bcc1a2dd302578e7713321d2db2b26d8b0144143dfa700a37ad3bb7bd86fb172f400ee9164a1621189a7f0a35eeedfd78695c18df0ce7287e00bdb8412f9e79e1a805cb4ca62d293d9cb1052d66c2754cb10ccdde22c691a83365fa09679254639a10d821bb7d8d956e65347e7670aa5c21795fc0f4675faebe5e1c020e1ac48ef234c521e4d9f11292bf4f63f3e8b40c2316055a8b5f563dd01fcb688553b0c75a3011917d0c550af1e3d60bf608321d4a0746a0a70122776165fba7ed73ecf2726ef6449aa06bc4f7eab5491e7500a19f843acc609f546f9110e0170fb26007e8311fa907413374ee101e740d1a9d5f7b95c2a41f72139932103372db5299d376881d3b5cad9ae1f39cb7335e2ca69cfd912688eb2871f06b34b0726ec151e99ef074b222022baf13b30e9b48b19fa710a7182793aa389c6c5bdd0d065e61cc08126da2f82937d96ff517f545a1c594a7048fd3c3f8ca037505b56027a5b638edc59b0ec242022a73afc570d354da3542e30601cb16c8d5ff17f958120ce4f565ec06da41007dda36d79f43e1c4d6df998a48c195b5cace39a48cdb21877eb8d4f6b7af0b7aec9bba0a5fa9b6ce75cad1735fbfce209eae7229a99c1f74606768f76ac3e7131aae07715729d750a3e62192ec8ce6b8bc99d40e6f004d8864ceb473fa9abbf65f21d4190f400ff4c0ace97647ade11e2ec46842008defe8e12a9b5262c29d08cd2a071cafbcde6abcf55a1a4b6240369dec6f05410a10357fc792b389f5e4ff3a14ee9086ad2138e23c131add929cdbba96b53d593b5faa1710e2f3810d8a4e4da687ca22a07612c67ec8aa6d0c9f99613f3649800ba724467f15440f095a54507e39122334e9c30542136c930a5d029892d16952b0bed7b12940b2277680337558cc77bb17ee37482f6457a376e5e667bbd5ba00c9c28b68557677585873b0c20d5ceca48651f79ca574d2a5508de2d64cdd262f26e2c5da58e75033d7b4ae7e39b1bbd6ee6eabe11e2cb2111a308789ff91b9ed0ab6c570af8864241028c89a82e3934d86144a7a5d6d34b60b7548dda37ccb77a0509985ac42008560b380e1d8aaafcde5fcd91a33e5b21201d4543e0aa767ccb6274d84b30d6f3e4b0dce6f248264bbf3683a6dd15f233c4312f08bc21f94863f3dace91997064d8fbed862666401801171b3ee28304ab02906b49dd36b0fa7de812fb01c3e41a7d574fd73ce7841120c5d4a8f620ff38e8ff23b6d9fec7c56f446837f47925e3a16c9051ed2f7eb45f514602ea57cefa58dd2d634506400c8a58cbe71c85e41b6aee5d7d8adfb2883f72ccfe15efbf672d96e75b0dc91e6c2b422bf05436e2c554d46f3c314ba25d7d9979ecb4fe9e0b316c21999105f6f26a27a78f38e52663bcc67a203c6830044de3c928529c6af80f184eea8f5e43a03a9bfc6d9a565cb4cafd9e3003cda4a92744452e4352343b037946b87de1712e85f85714d6237fdcf07c622592639380a5e77a1abc44b9656e3fcc27a72234ac368bb735c7e08c8eafdbb712f6107e99fd3f1d4eb8bffabd90b85f3699f8d0db28f16f504baa8fc5917881aeaa70b3da47c127bc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3d6cbb74df0882a2674527fb1ce312a76e9d229db4232a482c1852225595a3403ec09e87350f4c4843e89eb1a9f22fa153bf23c45876301586d866f4443bb75ba81f06bda7908f6e1506f77d8b33600228fe988cdd2fd4385982ee6ee996f9e97ed2f677e99f0a9790bd0aeb30e2cbe83440f6238266ab0dba4040d6196088d0344d24d02515cb4aecb7f7e1f04922a4fc8a68432d637be05b2dfba4b7d686e64cdfae1870607b40fb709b25ac397c9da42bd7ab294ef5cfe8d2ccec70a5d60fe4a513ebd42057ee947431eaafb2d36e30fcc9242ba147cf2c47156d0796bb1b676f2a56603eb2ae24593c0430789d671965a54046a2ed430429f24605f92dae10ddfde1db90acc3d759545421c5dad4af272408c3a028a12e399a7b848cac170c2ee5e6c662e45a4a329e86e0604de09924a1b1c548c4fc37b8844ca7c731e7ea15cb9a6223b72f2470eb4be441a261e84d6960dd404346e35b2514a2502d5e93f31c855d9fd8b767252f43b00903689d726cfed605edc8f6d2ef5aa076cd582a5a137a6ceb4342f42ed56c250c6389694ffab999a6223aa17c0d65133f462b613c2d8410f146c4233b800cba56b60b5670b28aa8251e7e228d1d942d392b381b1de65e7c9be7f079c78d429cdfd310740c9ae1e66744d9cc11196ebf1574c8873e0ccf0d2cb67eab645b5b5389937d20f15bc596a146852b5f9c2deae26691cbe6f423e0605e5d392fb43a023dc740d3195f1c25a47c8afb88edb569103d6e15de28c086ed983e661c28bb3d83219f7aee2d5fde69bc9719963a64e5a67f094d362c0e48b1e28c9bcd969a4d10feb35621543596f2ba434f716459fd2b8f0f445a09205b24dd64ba1066720638501d7c3a749f1d970a0f61be411fb58d466de8c2ecbb1700665541925735fa2ffaadb19f465bfce051480054616c66a1cb6e056b5554d9ae38b2f275bacc88e9d482f6db53bb34e0c44a8818cf75891eced71164e48236e9a4e18654011308c43b3099c48702445651566b6867a419ddc5ae2d53e49f52ae6230f63d1d480e5e657a1ab144ab4c2e0dbb86f82cbb77d2669e9630d11797a0df2756a5d47aab5e6331131071cd95b4826e92e5c3228e285b8b81fdaccad59900e97e28b2aaf031389222ac93b158238d4a8221c0844f319849229bafe389dcb56ea7af8daff9c4f3346d056b2f3035980a4bdd9c9f28e7a5e4f1a29c2743b652b53925ae6c8e6002a311f73b045c46df04a958190dacb6da7dcdce576e574f8dd3b2c04256b71f57a250fa0e3aaadc21258c7114a8a840f472a3141b3988a78b6eca6ced23e0334f9041447990d917aee100bb864a1a282c57b81e57509bca143d692fbd6fbf555169787e061ff087350cf509e017e67ece411cec3c2ff30e39e99420fbf6bd252507efd5ffda2a81189b96510ef7d328e9e798252ac85d049c991180b6fe12a6009aac87067eab98e1a4f110dd411d52fd521e6c2098e38c6848b62ca2b82dccfab7d9055d047e36870a1ee702572af32084966a8a9fc9cce55d029f9e783279518cc63fd5589a2bc53470f032392497d0c33ff96663d1c4aaab2920be703d3c8060ab53a64005ca1dd4b32478ad8c4097531a56eb44fd94df34d28a873370d2dd2b95e6d8fd037c672b2736365f3c8004dd3bf54eb737d2b582312fb07f3e613c706dac0432692e45511409487aeed6ad599081a9bea1751849d79ab88bfb2e1aecb59c86205c40a030668a36f95fe92edb769f3b2a756585f483cce30c6629d866f9b8ca9ace2d4611c829192b51d8b22d34608ca069926449ddfc472c363aca184fa67fab099242bb0e0533c3a30e6a21b1e79543f2ac3c52b29171469d53ba473f69148fe247e1adfae4b6d33643f22892dd353000d9cec457f3bdf0dbf6d7c706ef2538e03c45ebef5cc5a4b8c6dd0446f8bf819b0b70a1c65d2eedc4d7500de8818a0c426bcf60dfe588a7fa84b1be945cd60143bad17a93dd9d076a62d1745ca8b8512ef791ff07b3edf8162882fb73cf40ba5a0313af7e64c05c5e0896cb72d845b8e223e86f77c8b8e4b6c6232a77b90f2c3ed6e98c82a635c3f02dd8f7cb3c0ffac5fd1a67b0eb52fb783ef330a7c59c27e252ebb2c4eea6dabe5163e6f20035fff78f125bc3a419e4d23d4052541bdcfe4664252a88ffc32a45be18777882586a21787822d5915b0805711e36d9d37bb3215fbf1949873b1756fa1ae9c31c8605e345d6d263c27c4f246ac391bcc726ab2b7243fd5cce82f3915754fbd6f1bb0b44ecd0cfbc1f61eb5c6b65ce2bebe058355d27bd9c4eef04e980962d447e4785eaa81682ebfa6a2129ea9dbafb3484dd8ab73362ea340a03da640bc18c1e818911914104a650f4446ce93f43d8fe387289b6dd30f498fdbdf2abd94ce1a9fd1785cbfb934389ecca19758d29bb4c01d5c3fa6ea7ab307849d1a7079de13774f9966bb7fd107cc48ae8b7f39a80e66f11fe3bac4111e996160758878e04f58f5adce7451390e76c1f1d726a854bf43944107f3a16c97f68c567bd29f395f407286b4b2ffd72905e466f144224bcc08263314dd8a53efdc222b9195c0c611b92a5a14ac08280f69a837ba79ee39991ffcbebc587489b431812ceefbcba9239d319b8eafa78ca7f06d4c494e925e50de579d4095bfe5875592fb8e99ff1396ea2874f6094ab7ac93ad8778cb5ab8e29e449cfbd66d126e2f8627850cc509192e6542267abd14f3539b67ae558f87b8df955be6c5773784847f119e60e2186be2d04e34b9354067f9b786499d380da7be9a058659800a4611b99e19977d01b8bf65e7d4b74c2ef3ae5de8fb0754ffaea8a0d352dae3900d3c7dfda5834cfa9261a944a88420295acbda610f2a09c3fe12a775f4333a4400227d04c6220bace3f4962040a6c85ac28abd905d6d09288c06a4d56ded74828729638d015ee11dde4f62b5a86cde1d00382c5ea58d3a8c00f749ca2c35bee19ce53f2f112ef8537288f8792431d9133f21619b942f82e166e693f31f6169f6973ca3207513e39b1437e339477b9c376cffe25def7dad8801b13b860f576dc0f7767bbc7f3f43af125101fcfde9c7853423652c08437994733e8577c7aa9161f3a7fb3c7fb3f7efc8c62e99d0dda7250a1d1e6f06164c62693cc1a285dbb57d96efe13380812d0dd453be75b360b2601f794d82d3146e0f9bfc49c22963eb116b3d0bac23ecc58afec38d2de6f3e5507de02ce2808daaef18ada863132281b0f5ecad657ffc0501fa95b895516c7edefd5a93281c371c80b9e40cc04041743c2e0864a5a662c1d90bb171df2eb2e69364f732c7802ea4979a463a66e2e73ee327e40cbe3ba5dd2d2c9546c5b1089274915d8b2e4f5496a906c600eeb1fd971be42b1db3f66aeeb572b2e7fd550efd331ed20a4e8b32be2afa7f9616c483a737723d5fefb87b7c15c1313389b8187a10c5b3a27c6e315b84236f1d477296713f1365f55123ef273f8ac79c9846eff4f4f6c38cc22094c2cbae1803424fef3aa5d57fa6ce8b7ea02381d5024042bd4a8e2d0455dcf1e2cdf14338ee7eff99a22d16fcd4630c2f5a918d0d7056a5cf4b5c1ddd2c148e8b1bd1c8cc52cb1f9e5a848b577d1e48bed0923b9c49aad349daa0204d4c38afa06e29b240ffbfcaea58c97b8a93f21a4dff00b5b9d8ca5c8fb5274a9cecc8f82b54f4add89d37c7a4cf304a338dbb73b6e80433196fc8a141c535d54286477d045db5f9ce00f560d0d134ebaa926c81876de94ed2790dd1470ef5ac13432653c78ca8979e5cff5df8593175c8b41d32c1730ac103c8f6040d2ebf552aebd231804ece2e8a9e10d8d1c61e554f01e1045280175220d6542f2335e34afee2056f6d01fa19400500a1763dc14026bc95c2d5aad7a5b1b0042ce18bd58b6b8e2afe46999cec826c3c31144c1e66712d33308e1193c0f2aef47dd1682a1cf4806367ab60879516e17a1f07125ed7f07dfa17ccfe2d91cdddd36e24bd55717fbdedb3cce35094178bfbbd93f9f0d979a33a0aa13119eb71944e3b791bfcb0ea84937b84b6aff30205b72464037ab49738a912aaa7f0f92a36249a3a417c0148b52cc9ea645c6a8d1218eeb5df0846753af0352bb355a97463f214db80a62404d0e066a4b4ff637b8ac86c782d41f4f4e0ae245c8f720386bf0f9f0bddfa595d215bb5c870756a8a24501607766668da0396bc992dfd41c95ce70460fc81773cfac9e052c86bb0cd47b5e8c6643a5d6d6bd82a8b9d71baa5f719cf8cd9f0f175749c32fbc1b5692804a2fb08eea7f68b50bec27f351c527f8710c9ac5a529ecca77323a08573eb8a78ef42b445bbbea5d71e2daa8fb92c8fe89e077ff6b711cdfcfbb5abef865c4a8d5bd5675c8c2bb0fd723d82643906947eff2233e126cedb29f07eb291ed2ce44f699bfae002ecd43a1f5aa0b8a5136591e6425cbab66e6fdba75876e4fc49e6ca753d48e8e4c218955420134d98bec8740444c3deb02a89aa403cdc96bc7e9db598e02fb8f0cbfab8911b0493f967fdcefafba8a68a9fdf9e1a7a42d4a8b567e45a9987a77629b28a7e35e99d27b16f1c8b98fb95fcc3fc237b029df91181fe64088288925e60cc4b22008db8d007d8143b69cd4ef56262a207bc5f6243c8095bb9874f9b05aace1a6ded7a8657ec99197fa598de509dd8d96289583d189d25933f2a8158d5c6fd6f934e1245fb427ff4b0e943de0fb1d02d12f1a4642eea1b282f1b85fca049013335392acf0d1de3f3cbb2661a34aafa35895b308be48d04ba4d66534d7f799c6394e09cf4a40bf5059a34d0288072ae5e9b5bb097e42be862ccb70d8bb0803e1251e29ba12decf18f21044eb2908be0642e70fb67b371cc7390e8d2e18b40bdee8d10302e93c965088a4e9e92141ed5df20eea279566b999b328f5ebe1ae48d823cd588f5673fe30ca095199645fef385bc4e3eda54d96a05abe53e78c367d1d0327ab12b9579e9b5b5ef25763d655f5b6bd317b3ae348b16a6a8169f33b455aeeedd46b94ba8ee86c96d58a28b5262140c1f2a27f3f6bebea5fa5c363dd1fc5016711e71a99c59e2e8ebc62e0db5aa73c4e3e6b8f08541d6e9d7ac708937c71a6dd048bc55f2b5792d7d00a3d2d817796a13dad654c896074c3035fa1110590fa92a36d8505daed35aa2b258326342c3e602bcede244bf55839e80f97ab1114285c799102e8728ca16f146bb8e48a2d21541be015b58b794c23da24d99e9d72bc9cb0eab050d566184def04c91b9ba300c9bbe501d4584d73bc98917d4f210f870213614eb0dc19afcbe7205610b8d8658dbc724261e32ded2aad68ca071e7740dcf004e4081df3028012b513559caa7a47c26c857fbe736f5a61db1319fc13cda3dcc5658e4807174df29660e5dd2dea75d599110579dddb0862b1f0b9d96127a13f153f88e4f1eff8f2e3e08b7ef4ed58b8e594211ee19c9596bf7f83fe9eed47166aab0b42e702d6657ccd1031334a41ce75fe5b5a6fe1e608693da90502001d87f22289518729c86ad4671537e2966effb7486f5c5dd47f6163b06abab6d897da82e0908c29bbe1c8a4f272f86e363754b0b81340bce6443e22a4e1a224c29ef1ec6eb2d5c9eeb4a5f397a851a10b0a11b0ae03a88e790a6bb8f2f9943369320cd22f7936622e79eca30aff4eeb1ff9c0cf80c5a99fca290a8b433268afb218a038e42df11b75dc65df6ba1e28161b5684cb8cd68d0b6649f57153c63ddb599671c50905dab661154f2208ce140d86e969261569910cac65081f2133ac7a7a45eec85c59793855f489cd6dd8ac5ccf3d43628c22c5e892ce46257f3aea1b7cf8935a57cce4508a79ff46d472552f1d6e9cbd4defa304c25bb744ca2a8a97cfefeadba1a0430bb4c42a63d79dbbcba1f8d264514123fbed2945aa341e59ccd9cf3d9a993085f0b451db71a7e39d8ac7deaac5bee2b922254f42cf7c1ce9157a21db26e79a0b0eb5361c74178b253b6dffc4aef9d6a6afe60aca8b47a0a8c3c3db28a9ca54caa2ccc6ed4b71ea277a7203a8eddc9c87c356111febbec7be75e4ab1c0137a333bb497c8dcf8d573b3405d12ce5ef2f3e531c576af02693067a40c375e7aed3994e4be7e746c36ca179841d51ef1f8a52ec52bb95dfd66cb8fb1ed541e259fe786f3c161154be74381b0168ff708216b98bbabce008d7d7a4a35d7f990b4f7046681da64ead28ed6bfd435c59759afc759af233a123ea02f618f580bfc216bc60e2d2e682bacdc5cd5105c4ca7669f8d4552a97b79bca83d803a62dcc1ad3b873c1f6ebab6473a2910b06beb838f248287b78d9b28a6debf438ba2d481bc9b66e2380a1ed48c5792f480867c3e351fa8d3d6080dc8a0601d3ea718565e9302bcee66582282be0a81c319863e2064c3577a2d81c2bd7961ad3d14865df574564f6c49d62b4933eabaa7122700948d416fc2ddc59600e8ee98da22410bc2b3cff22c81bd2075f555664ddf6d22a28a61f8f8fe29d452908583d4b9cf306d41327687d67917443a482dda07b61821e32e0bf66600bd07609af696d9de54a8b08942ce7a67f45223e7100ae5e02ba52d8427da1221929a136a829c6fd3429746d334d56fd86bd8f0d9977b8cbc9b517d0528eaa500550816662cb4525b985da23b04d96672960923531dda5e5f85855dbc61cd5ff87d6e8602acf4d5b5930c28e8a1411d0f00bb7cc6e3504e66fd7a6b4f6f2ebac2e7d0b16cebc6e776b5bee3eccafb748f2e91819c8e2ffb3449928be6b2aca0980fcaac3c7c7653dc59c1e59612806b74e1da754c95193649954d7124d8b516eb5b40c790c0353da9b27da72aca4c786309c7b09d09c9e74bf99915b18005a4d0cbb59f8828bd640a822fb7a88295b612bb36a57eb70677e2a1b7586da549bba41c0dfaf7d6987c2b0930b134cc2f03ac613b3408f9935cf6662be4eeff2439b6025457aab5e1b91d121834003fa1d9ec01838111f938d2ceeafb51a0e2c09ebddc00973d50136a22f617b51cafd1e22334512caee484ee8650a1bc86fced50efdf52e7d03941159099d55816b7d85de9bacc30e808e93d2ba50d40af7ae5203cc259208c23cfba92efd0bc3e4f9452718a7ef11aadc2d5c6cc86b0b8415094f7c78fbf3423aa342490cc845e2150eb14c93fe59eed3ce0cae5a23de7ea3b6ba3e3cd68f4e9759b601916c473a3bb26a8cd07855324123a74e4a2f5069c37b3ef2d614e26f3c54c84ce4b6214245c5f8418145140697195f11cea71e9231ce06da64798862836806b53fdb76f5dd8d7396e99b8695a288d9593b55c54b755bc07ddcfb78e51624fc51ff5b6ac38c348e0e22fb5283648ea9feb1413a2b5ec67a0c33b7dbf0acf6139e38e30f39333db8648c54973aa7a2cdd8b197b423e4c3ed95a23b488ce4d0349a8a1b77074cd505f1037e4238c574a19b81bd8d60e45ccddcc6912bdb06269a4e541aeb7ee4b87cf4cba188fdc30b805c60e092bc2c77352f10fbe3bf57f675a59166409bc7e4cfbab66bffe6e562cda6b622ecb25258d90a8b8002b367586a688f195c4c68a9915a9ec668655df45607fd68bd3a3bbb0d66e8af188332508f37e717f8210fae8f5e81d92c0e0e77f3974189f471607982a4ff17f0cd3198ee227970afc78185e54eec6301d868ac097d780a5d1ecffff0871af36e4e6566070b6d5b7f7742ad9e64703cec6535fa3ad93719e77fb4a20e78954673128f7244efcf245731dccecaab37716e59fdac7d31621cf9f8a6a94cf12be7b42d87af6a1107bbd41de491ff4be2ec231067eee3b1a72faf46f7e15611372f29007574a311a1e701ad135f5bb9b0fe4d22152e5014977631bbff3bbe7f8cd19c0e80fce6d825483c444a09638b670d11863ac1674d9340a0114c92d0a0016cfd6e35144b3f38e8ad3567d869fe89ee77012aa6b8c61738011972fd796601fea6570bc7c65e7898f02a82f1a7532007fc0d2f0bd2b8614d3906d11b226f9e5117f017841d16bbf9a1f26706e1fede1cd99d20325b357288e63648c5d932ed7984fbb2068d255f996083357a90cd736ef60fbe9833d52571c0980345f5372ca2260531a08b9ec33c96433dcebba55893bcc55e87026b007828980c10d62611eb11fb52b8f6a700cc31c202f47c38acc361713f250dcbad25510e3dfc7bdd6b44269285d7ab1963f635ab9aa536da792cd90be9b540516974c7feeafb0af9f19620a3fab0206091d0ec1e19307973152b08e16c8f2adba4cac287cca5b859a698577ac98655ca16910f6b69c995b5f26795f6207db8298248f56b94acea955db9742ab482686c0e3c32b33b4b6e3bdf05383e829ac6331bbc1ab5e68b0240d5680d50a90be66e65b1daea3eebdfbb276581618f03ec0fb5fadcee48c0efb2a90603d1c8c5ad39b4cb57ac05e8c82682ef87af8f4f691ce24f1aaa25b71468455d5582ba3cd5630cb5d9a7e127144bfcaf012b2ac5e1262e5737ebbabe4e2e186902696f8ec02619cf89f9919c79e0d55c713d2191265b9fdfeffcba769f73dc21cf8a1e385d8f3f329bcde148e6dbce66841d2e95e925509421457b53007f23b69e9e97624cc8595cc35066b1423dfae2bee58450ae286b3dd61cab03ba59c8e31dba41f9329905b55d7274e65abd3b249f44c27cde98dbc42ac8210c0f3b8be3781c5ad58963014950aedf7a82de630465ab8af09fcbc2771cac783a63d1d05b933bfed4127f20000d142c4d6fd7f891d5b87d8dff65e765ee9a124b94c9d0e47e729512a8c3c6b81e1906e7cb64ff8af0bdfa1bf6327e0781b43d84f7b9c26e47c6906705b2ea918d7005abc7efd31b53306e687c6e113b9328f5475beb99f4a50a7344164f43b465406d41bfb0186076ae349f3f2ecf76271644add292a5e5c4cd191699620a8a44e2272391ff1d813f94cc45322f28364c067b580edea73837f0c6c6fce49cd2259ca5119c312404c561299c45c3b646cab65a1ca651ba67da721971e39884f5ca65ad866b3f3fc5de0662576146a9fc22673929daf067bf39641fabe51070a0ea64136ea7fc9b2fb1960263e46d65766ac53bc97a97f322dbf75a1dc24477b53593dcba8e06a60b6d74ae9c8a8a20e81af559212a52dd9b0a0985925fb954f1a1347f5e86f1dfa3c281bbf5d208f25520cedcd787d2ccff7652372ebcb93ff4aab257bfa0fd32a6c637b2c7212298353574757df35082bba2e67887edb91d88529d477d87091773e3616b843c3208c712fb5db6f182a8fa6fff9894f0cf3f915b48d5ef4aaa34f28db764aa10896454a24c6e3052f09222b5ed6ebaa4986f7e8d9313c06dc9bea8b04485108b142c484f160ea778ee6e63d45ae2e8dd2ae6018685ca79242f23855b6d597738dffb4e40eb214957890bd425a088e2f2378a1e4368915cb58d49abd10a7915a52637127632af1f4a7c49cfe50c6f47c4a3042158cb5a2260a677e1b995c874ccbf8e178753f4296eb3636d343bc1ec35ffc394d6cdf7044abfec885734f964c4302d450669d5954df8f00860b899567edcaa9c3e4f70a4da20e7e2c450edf9e5eadd2e39a9397402e060d493b11c8a82a634264d63628dc1a800fe53c7b1bc53317ac1251faa433a7e321fd458491fbc72ca777d9b53314529e5fd2748fdb67fe44380a932f6f523a6eb2c90355dc55bcb7713f252309f9cfc409cc54fd8c82f3e6da97c8ef8ee804fa004b95d074909227cad54b1d5ffcb0c26a30b4fc80c4295ade16c98fa81644805617cb1ba66b6eae98ae687e491f7caf9b9cecdfb960edec357561a50a6c87e54e099d2793bb2de75d7d80ce6f2437097071e98b98e76d762c9c9b5fb2d27e7591bde9815a346bf8fe5850170cbe2144d3722065512a911834b9711fbc09c7b82440a3f1c0b4b3fe16adb50cbecb1c02fb152fe6450858d4aab15a028cc087679abad2fcf8c77488b8aeb40adcc9ea94350905462e5b55f15ad092576ec1ab425b8bae97d2adf144ba0830d4f5387ce96a450dc2b4dace5271ef8e0714d403beeedd894009ba0e1707528f3a4ffbd193a9271e9071399620d74421d915e978379bf575beecf66c7d8e5b772a5142fa4e49fc8e66e892b7ffe64c834b1f0d316390a8c2aa71ba97078ad64ef949b12cb382fa306fa20c4c429dbb16554f89b1ecd2ea4bf1c02c3b8c2e53262965869cd83cedb8d855cba64e599ea1ab10af2c770ecf58eb65ba6d57183a5da8340f5f13c4f8ac9e4d941f0ab6cd8ddf89efb27ca115bdc4ccbff46a9ebecec4402999956cc35d90f9bd4f822b63b4140850004a1eae4c8028b73ebfb0b9ea8d04417fa8d649a20e2f8966213b560e57f245bae3569a3f08a2f2a99b64ea2e2d04f44f3d89446c938fd1b86fe404272026c81fbb11726f33e6063804b23b45275798ea017b2fca11cd488756e3dc2a1ea58ea5398a6e8f765cb385813dfb2994b9a52cf1deae82dcd06c4459c056e03eb34fd8c618d5bfffcca0522bd2828e96c8514d40c646665d6810e2ed9436b1024f17923b8424028fc66c067ba3753fe9e01cda2ef14255bfdc8c5da857bb8ca60ba4b9a7ac8aade5c04f02f6fe405b06d29cb87d3a8cedac0de065f095c6046172e180d0dcbdfadd8a597aa02aa92799b5b630da0aa76b5f58db90148ee1b4869fe148ec3e3a3ad2b11f3f595b957019f655be5e90b5c3761089cd57785ca84da3eb32333cc3ba9b918df2f2ceb6d3458512227a305cfec161d3fbe8212b2b011d4d137e2a4e302a4c83d1446bb77aec0e5c8f88b709f4bd6cb9c68e4bb55d1efe950ad267932f352dc463361d5fff1666e1baa1679faa9304a2ab0a9c5df9b5e63482fb17dd0c22e2eef0e4a3c32f15d3f8cf55969464f2c34ef8248ffe79814e42d76ca6cc4bf1cd760a98019bc907427cf8671c6fb6deb9053a95593dfaeba11dde1b387b876ece8dfac0d3edc732eb8e5d08c110840aec5489bd1c300a13c7491f502a4c52f637cdf8641a73058b81b0834b0b317ae378b9ee91127d7f6d34c9ae1bb2d0b540d67509bfbe69e341a9e6f4142692b41c2ee37b31577d912200978bf2713fc9aad908686e33ec994a1df81603679ea46f8531e451da0b837a8c3e2c5c477b8db49482627cd0f521efb6961a71bbfdf5955a492620cb13ff89608de5451e698c08dbcc035f467958cfa0da9c46945ddd59d8c31c775d03dd13519280a0918d75181f54a1dd88cb5fd8400578f167a692aa5a559ef4ac965a42689b26cdf97494594957e330005fd77bc7cd3673b402c19b4855aad11ddcf2c2b7cdd8a9509be588e5881cb2a79024c6310aeff0b58509f891a00956f385","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

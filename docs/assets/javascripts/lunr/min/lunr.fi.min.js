<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ad099a054b71af10026d808cbd68e8753f70471d4e6cf4d90ddff933f8a62fcd09739ce586e1fc665af26f35875551169a0fb8bcd375be67a28980237fe10fa16a04618f1f9ee60089b4464444c4f5d580c79eed008a27b0c4507664132e2846897cc17fe0d65284e28879fab066bf3ba863af4bed87adf24c46c1f22eb63e3ebe09b0fb913a38c2613996442ae0c3fb73e678dabb6b613650f8e358fdfffc8b97add7711d91f8ec5fe4031bf02cee17118cb61e2145f60e7bf9a3cf5708fb211221ea08bff2d43fa4006a4495daf3fad7493099b53ba9f36bdef7b2febbfe20321ade6f17c3692a0f3e72b9c306e58f5e4dfd7ac5945ed116d94853d2cce59177f94207156df579612065c7e90fb2d70451b932f8e272160a8af0758717837090af6c788941b8d407e245069b396c54335a701968ce6b2e94fbbda0a933b5d8bf29a12fcb35e73387e028336ca71bc04158d8146bb8f57560955e94150d3b5d92299c7755c3f300e327bee047524e91eebd67df427f7d9b6cbb1f75a80a5a0da25510af6420438bb3d49eb60a8b27c4c77baa4aa5577c07034490aa1fe7b3c4e872b8911aeac4ff6691a04f16fc5be94e70957ba17db85091779995cda5c1e0909103915b33f6b21051672f9dd821eb9ec2f753ed237a576cd8c183045556ef3c597a04b2b3d0f023fc3ff80658a7aa1d937e9f5c063aa5dc5f0cea446cd2db2cc8d2c28143955796057cd5f72e75c4df017e6f221dd7a25af4ae03e4ee54c9ef49eb2df2e4cd486a73af73ec736c9e69b0b56cd153112537a2bb26b06d277846f9cf15c5a9f6fa194d47f18cd875e724e1973062064017ad8957af05c413926ac8e76dbc51a925362780e90beff9603fbf598572345efe36b47f992ef9968b433cec8b0376385843e9f7e86c890e26a8ac44335b7b2abbf22a9f93cac59ec6c73189772fd892bb84ff7f2bef9e11d9f7c55ae8a8341dad8b4deab021b4883a72faced4da592fe41ce3646d940ffd7d1d9b64fbe1d60f8f65f5104de90c3e55411b8c0bfe986f8bb8a7b62c6b400c0aeac86066ca4c17ee4eb2762edf6a5cb87ff4f18b2c6674a684a8a188f47c2d1758cc2b3a93cee5c5a48979a2ca10b0652f167cae03d5073da9468febf2151e51e6c8a8460eaba74d7728d4041dcfc18f680e4976528a9dde2e30809d8f03c941db7c102fe5233c4db5b0ffc0ec08bc54052d74feae249756c4c0023d77585ac3f7232c1609a94525cee489045510a2f0b3e8caeecdf376a7bcb5b07ede5eeae7545e1ffacba123f503511ec62a1ba1b9a2380c708e81f4ad7b73b6a1c3fe548a82572f0c085e279b9a1c25ed318c6f9552db414d37336d497f548a5fc76c9115a0584066ca8beb212efc233751499a0fc8995639811e71c87e81504e0eea1680349b6a1935a91bf766b386aff5e0cca05be8e564d94d718440502c1f141024e3edea90aef39cf44113e292c771bc0084a49854882cf288cdda12c9b72f4201ff08c70585f5f6df8e2825d676383fec1be02bc1bd89799b06208ff7e003af07ac5f87da913fae2458098e1e55aea242c2c5f75f0c5b6b03c21d496d0e66d30187f08cc2abbc3d49ad5e95361a99e8298991f90553a65a346b8f3c020b890f98b826cf1425b253cd91b1934b9639c755367c7706a7ad2d5e772d9d29ed913155d258390c7f6fa93b89b456e79cc34143bda6a55a3fea171f20d819dab9693ccd49319f98ff094efd2211d5f37e10e03840ec326f896ec0987f393e291409475cb2fc797f6b278de0d52649c19609161d699970e1241e5e43d1f920797588f719ec75ff976a056e9d7e9cdad283dc7d182361a67cd0c6ec7d91ee2165538f1fde9136f9641b46811d04dc1eb8abd32cf68d154f148918cfa2ba496a3f31cc2c9fdccb4c56e9c873f506aab292db13b89322e6dcc3507c33a65066caa858df1e2af8a6fa9af3a795c8c0b7b7e8049059b5753232137b195ad1d8c1cbf991aaf617619ca7ba3824ea81510dd567d93cd3052fdb201c68f2c4c63fc6aa16fb49e94205c5eabd6e2304f0cefca7a2ed56dd84625f98c0231db8b14e1872a7e96c6c29ca6e5899ca0329392fa48ab028ceddd15d227243803a4e41325fd4c0301b5c31100c2f8d0e8f464ea4b79fb1bc226402588e421ebb25e70c3ff32b3d24613701d6309a3474027c07dc10efdf136dd52b6e641774cc5879c34729ac86550daec649ed051f376471d580467c89f93d002215ee47a237deeb65df37fa5debf32d1ea05ce727163c8ebce5e06a8c86f8df5273f425339d24ae6a183dc5ebe24e116eded389f5889a2db1c11ba070f6e2c163c3160ed0ba6631c06b91082d55fe8f6ace07117294e79228fc89889a13b5f73aae35672702549f23009d5c929a7648af0655c0818561fbbafa9cfb747d17c11a302e7d150303cf732cbc77ee4e40fc8e043c58121a222466e2c5c5ba19c729b4ee46faef0043aec17be12deb5d0c40feb20beac21556bfeabb10f476906d6f7bde8e5c47410b5ecc3291f739ec40f56de478607653257cc84f940e5761fadfccbdbc38fbe1233304d38e9a5a7a6d69c1225ad7ecd3b667c83130ae2b01209ca675bc42d833a47171d03344be5d67bcb5a29a51ad477782ff72fec242c6ca32fc10c6b7b3191e07465b3f331d43ca3e79c15c752a92ce7dc9bd5eacaf2202988b108ed0294b2845bba69ae315feeab5f35e8fbf568eb0bb44ef0ffce19b8c05c9ca2f4ba363dcc1e304a01dd6544627dca1a5ca7c0e0f6cb3bfbb41c1d922a3d1012453b7a594b632bfeca0ce50787b172eed72c90a1b6884c9cf6d703bf71c8c19a33c4fbecb869296b8731542c8520340b6e51d1703e4d618a76a8ede1b91fe04e0bb866c45902439f2de1fb96a46c8109a6e863079b27b994967f09bcd788b7bf981587ad53c7d178eb9a963670acf6405d3ca63fc17d315b5f024699141a8066ed0ec1a8a75a4a549d200194cc0e9342cd46acb902411a4576daa4a9b75e78a7d1e50767f6d04776917914945a22e5c084665ab93a0a23b205126f4bebb87e9234d5e8e20d29db6b489ae980f3aab82251a77f618d5c84e3856b2cdebbfa85a999757c38158f7316f7c9af8b11f85457b99e69fe7226c711adcaa128fadb8dcd30937cfe4fa2d574397eabdfa9259e2a72a92193ca6c788fd35251b6834b2a9fb1959f13e401d4a056818cc810eb471687c78faf4c4fa30423c0fefbee3f5474238c513c3466b5e9957924a0918cd25e2b4ee0e646ea942d9ab466164a15a42abd08343e81e3e5812b792692a4ad9b104780dae779d92d7cce3a4f6d9465a459cfeb884f1083d280f9ffee8db427405120f6328b6b6e3235ae4edeca995089a66ab0ed18d2c5e22b9b43d3897ed25b2e5ad9d33f610a0618d53346dc9d52d2b0012579f8f09282d68272b3c3c979a848c2500afc0e0a714b5f4fb01ba2c49d46dfd62ab8127b25f8e61f36e5f5f368182980118b7718f4c3f0a8d9b9407a57c0c627ce71828f6510b4035659c794b08048e1393a25c33d1ffa335b88f70d2cdd3f4352a22f7e97b3eb233663730dc1e9f4590475b6aa55232a1af1eb134ad7fb2843e59a71e726b18792654698bda18e3aead4b8d05f6a26dba74261da91cd7f73cfc71d11b729bb17d4cd027ad6091e1fc4326bdbd7286043da8ff3763e4f9506178f045d718168b58459b388e3115b2dfc46c84d4b2cd9e174332bec8e452c838daf2ceb9ab5ae9a62b7671fd05d6f37ff1e20763eb6239da7972efbdf96d0139773d2b2df11732ca013ed337980f3dc3809dbc3f7cd75cc126da33b3e1958a1fda391ea9770d702939b6f4fe1d892fcf8d93852b22e5d1be1ee63c159439f8c2913dfd0d1d1fa5b14eae41213530e0a814678b8fc02d5698a5825ffab864fe6c9150ed8aae4188a7121f708976516ac72afc3f20e3456e6655daa85771809bae155f1e068503d3acad3698f768f0da4d716fafd5878a19daa8f523195e4a604aa71b6a82c7bad893d3751635c64b3197de07726b02f72e6eed2353121524503b21a534dbf776f417bdc28e3cf377133d23c138ece3cab8d95337a3b64f76fa6ac0af2d306a011083976e13eacee247efeb1cbe436d6061001c282d476de7a88ee142e391603abffc7320731ce1c018cc696157793f3cc8b87ae3f68e53d71746dbc8f363db33e24a89bda636384b62e0f0baf6bd5ea72597682646242b3492ee6fd05ca61f5fc9156b948718ae54458d2a6598a9de1d4fc80647e18877b3101a2d1ca4715e2d7c20583095961e056244ebc10ae994a934360d5df5ffdd9ed423fee0a33e146987b634fe5f3b68096e45881ee44c23f63f6e256103a4c32c6ea548b7d0267f8947c04cbad37db16b7efab355c8bbf468574d1e10fc5ed12ea53051107abae2fce336d872631183710165c8c9c50f0e767f3ed3d5b3d630bc1b59dfe7003a3ef8d0da92af578fa82a6b04ca0673c72127d4f2ce42d47f80f4441500d808430164f20b8c5be97f1e2c8a994fd60faaa55542f350f7a058a74afb0fc960dd21599cef119d683472c70f384829cbc3596d089fcfb54ffd02bb553edf12c706b5ff66dd95ac88373aac742b2bbaebf0622518366cbde3a393afe6b26fdb61a9f3f2ca2ff0ec7f69ba218e528fa49adbd5817cbb8cc8f40ea347c804102731b5b3ccf19f650af478c3bb562233ec5da62521f04a2a283b1ec24d43004f631279f195fb475a3e0861939c2a62603a3a5fd290ff09ef88479ad7befec4fdbdbd7408c4c8659ea40ff554e753d4afcc89e1b9059480a542f91de361d79d74fd02dc3563201d604932292186b9f223f39afed1c1939aec2f234ed0a904e84cba989c69c999f702672bcb0ad06b930bb4ac5208cd0f26ac7a1ae1e82dd4f3b7278fcc9ea0c6a7ff97fbd8db0366dddc7fc78666bf8bd151e7d639572f743db8dddc983910e99f161b5d99604715106718f71b19bd54405bbdadac32a2e131ca2266c0654b68043a4b893e0a8961f8241d29b5d01be3643a69f8304877fae74195f2e9e7e6a12dee6ed0c4457882eb8e1fe280964c2c15fee33fcbb6866648b47a3cdae53844fd318afd987023959bb79cd09ca1ef442534bc01475e2f1ec18131c783e8a9020deab55eb44fada263060e07e85fb82300e903db661327ba82e570f0506f5d36b2f53d4e4cff995d958e7cf350404da1b0ae82a573829f07f13b42b216e6ff247aeacb6531f0aa2f1f8fad98a1db5c0131ce8541691dddb75b4a098ab1305fae2f30feb3fdf01d57f7151f99308ecdb94db5620a77eb4d6fb7458cc2a31183574c23ca235f004eb0fa37f82efa1a3f92f2bcec6f5d9a41642821589dcf6b93574aa89e13be0a0b0fd02ad871a4e5ce80a3199f37881d79e5a7cefef416d792d1469df78e9e2d8933c730a0dcf2a21efbfe0925124e3e9a5256dca64433333e2359a8c8a147bd04938c08823245c46123028dbb95e821f77c9e100f27245faef3b446a3e07ebf6a5c99dcbf8bac1495dee0e586375f050bf82427e7094b94c4f7dbebe05ec3500795051d52613a474c22a23388540236971e5b26af2f344c5141b7f80965e14310940d4888d989e448e592aae01da39cd265bfb47a577eb22604f56e1d55bba017191e202806633cb37fe9336c9a96033f99bfc6434d061805e3c0b7bd5c279e93391ae6a392457fb775e380b4ec4c1399798aaf5893615caba8c940486e417130b764f337c1a331e95fdda8f4290bf13923732f1599d8aefaacc9a65c0042510a7bd444b48d8cf39d0e43fda66495428e01975f230b4c2d0b762040ec5993d10625ddd72eef57089a1bbab5a64fd8eb36985eeb2474bc4130ffe63459dd40f488d06091c5b0ae5397b5c6598fc1d800cbcac0cfd98c8f340698f3174b51b2ab9d46b5ef15e3adcc60f90f30001593e8344d97e66721ee6a4aab5b985533c56c078066ff653a9693953c067085a1ee73fc695024f41c6b489d07f507717fb19f4ddf3147a65d5d31c12e4d25021be2d41339250f82f99f16ab5feea0ea7e26416fcbe2c6680310312d4f0ccad8b38334b59aadd8e81303f18a1bdf29c3654ec51bdf00060075f083c1f1ad87e30e0af847298a00c09db1e4de4fc6eee7a1a4d27ec1eb542bc7cd345772a77f4982ffc998391d3ed48eba4bced3b0ea9f9b4bc57be68b3eae6e545ce303efd58a225e2eb1e85ce8351be7761a10059d625e75e981ac14acac8141a4510f2ccd57dc97c03df9113e8731077f2f8ce13cabe749a11033c43475d356d78e0ede93188184658fe1acf70f65aa5bb6adcb6a2579e9597c9b05d9b3aa2bfb5d1b37d1b70083e25f80c9f479566903c717834cdbf92ba436db683b749be56e6e4056922aa80b8dbd5b95689ddd6734c674a3ff00c63f74f4dfbafaabd6d8907633ea14cc17251fe9bdef7600b1f840e4d1d3dc1700a9e528fe41957bce8c0096abde131a084ef5a80b761cfff0af7317a50e5968877c1954395809c79c15b1a18476940543880cd3379b889fc47db1d2dbe6ea00e6c669491d3c06f82b69ce948e0d25ba919b93b391fec40273f5ba50f5b40afa76f33769e1401deea76a46668e807ac920cc52d4af882a63e92f808f863130afbae045f5be99c568bd8ff44f4bd3a39a25f12d2b81fc25bd013e0d27fdc59dda2097f3544ce2c530c4496eeea117186e6c33844489e544f3649c7950f12f0464f9252f87c93ea13c26daacab942a9188c83a43f377b755335527b1ecdc0d5a95751eca59b21d766611e4cc8eb0805f7bee8ed55ca4ba0e61183936d123e36962afce5f83e81527ddeea4903c4cf323ef3f6d05cb587271609e18d0b9047d6f5ab1a5ef7d27701401004b9d296de5f8bedd476119f7b88c7b3d02ce3b3e93120079c8d4e3d2dafbe32e8e5d6690daf093e164cfbad8057d8130934f81012f2575da78e9003ae7ee85dd3d1800aaa18a5c6f1e76d063a13cbf1994588c8f9e12450a6bb42725cdac9b1d577b93885328800105c595f8402588a72ef8e72217ad013c39c1a090d1ba1fa168881892794563edbe4e33165ff53ce9dbc2d4f8efac96403a7efd36370322a8f62dc54b244716564673987b7aff2ea51debba38910a8931ddf35f9c83e8a4531e744def192a38326e41abd4aa9515736ce627734ac34aa79b8e26a90bf77956fd8088d562240adc6c43d6922131a247cf2ca9b3c83e74cadb1f03ca3906a709f832b8a5be28b8546d70a65feda9912ee16b14d10ef40f4f750be4d29009cb5fe3d03ea2a5b483572bd8c709a8728c3d1a8f7570e71f0a1b636b158ddb78162be7f91513fe1eb3e72b134133091c8b6d08ae416399003b0a54a254632ec79942a44a8dc38ab2a0eedfb48beb5dd0a5cf684c943fe263b8f5d3465040b5f3f9ab73ecddc17114d9d60c39996db186d6211166920ec6f242210b03931e41320562cb5265f5119c317ea34cb8e5dc45ea41de641a08997e8c3d86fbb7aab4bcbbe96ff2922aa7095f4aaec2e0c59a96157c58afbcd165eba3757b207f2eff10563f3bc95d4e4d341c93289269f46beef2783c97f86c7b4a85fe7cff02d2a0dc6b1b85df3119f5f230742dbcf0e16bebc7757cf620a1cf82048de811f26481ae563a695c417e630052a764b855e2595266269b9f36990ae7bb99d989b80e69e9bfac7ae9a56353b2c3771972dcfd597439885e9993b0efa90cef320925e436f71f8c4d3e747962abcd78215f03863493a041390727ff2dce9e03146fa6c203ad87c6470942661b4a82d60bb519c050cd853e754dac71b6a66b3b0a34ae093cce9f308684815cc2f4363b7550af8bdcc1f7524d0493ede70d76ae895de32656eb323cdf5dde2ef856033da89d24013dcb1319ab255e725327e31dd52277f4d0569db0e31a80c862cdf2aa4e816c9a8c3de3de2a313c885d96b0765d242a1233012e7fc7b36a824e2e8685af4cdc8ebc7baa6d9ede343b88121fa33f4a8992b4387a07531f92e7b1a157f5487ae126cb0b20133ebb1546efbb97c3f352b3da841adb0f0c513264b829e124ad5a11ab66a0b81b373b4386adeb2ede623158d7dd339c5b73a38360b2dea84f4547e5c3651a4ec405995df1704e027a43c89044c58b83b86ab042a198ba0fdc4f6e057236454ec952cdc8d71b34adbad50176fe5c1c5e187fe7f078d87ece7187bdc45bc59ce84840f251bcc1ab0a9f6318db60f9243acd44f855036726f279597b7d27413ace749277c1ec4135a3859865fbf4f35af386847a497d792cb47e0fe039c8fdc7a9e87a3bb55f101e97b56038dfd87e5fda919295b361a74e86babbf9f3fd964a60c5e3b7567aebdf7f37ddadc955a0e39dd28d6eb93a46ed86efe0d30f8f1c7225c561084a508d30a4ec43c59d576eb8b117d3a08f224dee73e65b4f6ca25d98006e4ccf040383a6d10d0459783de448626330b7eb519a764096ef23dc81de70156a8b3623ddbfe150f0ad367e6eca87686ebcb42eba546019d8a37ce6f725fef93f28461a3e558de3584e2d3ddddd633d31bb5c74d8ef34ee59b0834de08490a90f39ead55e05db6850d8d0b66df62003432c92c343c7e182fa68c5a78c84363e3efecd875a5d784033d6f34aeaf904c6fad38c89f27976222b1785555b2011e527e79ddac4f54f0a22d5a4f5fa39c11897063b9502fe66d800c04d7294f06d9dc1ca6c54e6a97da99eaa8217050380e70fec0098c89fef4a1f32d46ad1c48e792c74811caa64eb7b1610346ab8e36df23827c53200beeb7b315fbc34e214dff8b38117322981ae0bed81d3141d1345234c3b2331cf5ce70bc4dc51d19e2eb86eea9de886279439af95bd42e7eb2932f4b70845332609f33bf2ef6a6f755b4f45b0c0e7ad5ddcd161d740fb4255bda735d91e63d7394f7646f3c12e5824630a2aeea6ea5ac04ad638859ff23964aa06a228b6380fab2352fd0b6c5289a90ac5e7bdc53afe4045b6e89f3481d01a9b80b76103896e25c2736d288826d7fcdef50d6435ec2858c78c1d0688c4274730a625b1505b8ab27ee21c4b8d110f190d70b863ca055eb8e76a0f02f3b46112daa49cee82bac0785260ac0be855e8ecbb7b9752120c4a4b5f70fe581510756bfcdd1995e94035eafe5a1f6583e39002a00d1875fc558ccd91cb7e63e5ea751179c7df788593e6048a44cc2478880d5fb5316be675ff40548572aa0f6e762d1308004cbaf16961e3d1a39627ec9aeb353081149d6d605c78546af31074a3250b91e5ea5dfff6fc687fd9b4e0d1c59317f120813ba209b7a38518701877fd0fe140eefd9a58678ac616c9bb4cac23a4b827a70cc094d80b745baed16fcb3f11555d26c5e08c763ab7ac1cb3fdcff1570506eab82ad457bb95550f3e4e0855216d97b91e9d38d66c2c647e90e208382def8e3f220f2e12b3770ce2eeedd8361b9be947ee7a9fdeb4fa757d93bf732c4127d50d97f1d316832ef67ad36f23948b24205ace902f21702a09a989c7e4493b807a0eff69d10b0459ba2e55848227da7c9c11ef910f43d828ff1b7912951c6410c99ea3fb35fd1149a08d81dbee62639abf1743abdbbf818a36b3421f4f4be4ef03307245a989cffd485e661f5ddf5034f4348a43389444d16172af3caaac417cfb610ab9331261a7de9c5d901d6df80b08ac1d90093e54bc2ada86dbfc73c6bba0fc606914eeeb346e76348157e12471548ecf346d3dba2db20cecdaa76b2a7d6d06669e891be5fa7df91245c2b93d9e28be3abbb5a29f75361ba501a3b3f7d4ace5b7b46690e5df1d476ce2837ca875eba81299c0df06300796dc1079e57d31d35f899f3f7e2f4db7624d9cd24820034bfdc2d454c4f032698cc7d8da4ea985ad3260614e7b14eb9ce59b06533f171a824ec037930de18d06124f9ba739bb1b636fd835a390cdc82348e0ca6dd2d73f8b41a208fa8a7c0682b4e32ffecac9106d981f8651c73caf29bcd029a4e642f2967cc2194f741caaac18125baa84bf1769321518a55d62c660107550116de8da6c812749786ad08f17c59dd0ae5419e283e800e9e4dc739c1d83766d69036ffa9986e6ccdf53700b88d68f93e0bb8d3bf80bf612ce8087370b736fd5ef9c97ae4fede12e706c9c6e35c5c7574c4860333a77b9f13af365215e49672dc69daeac94eb0ba33fcce6dbe386f74e2f0740c7c572cdee941cc42887985383eadacacd016e946b13bdf5b0fecaeac239017a7ffe18d9ef86d71eaf50d5658624f8aecda38745d70429169a7f9bd5a507449022f8b82646915fd29b1df614b277b38aeb99719cbb978883bf01ea5a83c8a56b31edc15808236f8acb2c511f42389d22a2ad6a5a16107a2c57bd50ef769b5d2e8c00b3f76f40abb9f13556d41287c53b9dc264513e754f94af1c3a718ebbff2da76d02735bd95788c1878bb7e7eeed3613d2dd978dd6a73fac90cdaa722ebfd734f8a02cd5718dd97b3587297d39a3da06e0ee2de3ef569875e21e124cef9426b368707593573210e00d10019603bbf2acfe69b798a56dedf97a48491ba2856be303950b5e1419e7de492ca798cd2dd88fabe3ba6eb79e282e5da41e61fbf64509c175be4ccd7987b0f68d8df3fab2aa0539e8990cf17c6f0f35f619820ef51dad44b40caaa56bc99760af1f5b2f5359e31879ce621e8d6d48b11177eb119895310c5057f921f735e037ce8d2118fb025a49fd7195f820354a0c96abe79303641e5ad4b4ef69425f941ab2a4f1779c4ddb07f750ce2883418087681c99e5749d0cc665f95f6f022d76df85218eb9526ea87ed79c648a982b388bd0be2969c78fa2fb1951eeaa79750accbdc679c1da277717406b0a65783dd9def3b098fcf0a4f994d31fd16c4f23bffde2e07879112bb0abfb7309b413cdcca3ad44e308625bc5a2f0baf6888eeeea3d84ebee659581d3eba7ad60b9ad1b18615497c00eefb6a25b66344c7c8605a5ea68ad0ee4d3074fa0bba6c45111526f86ebb4e3c0312536ae20168d3555ba0f3476c4858e4887f6356a54be84a4d0d7654f04a7e433376ed51dff62cf9f5a7a733cab0c079f8a9f23d1576fa7971cb4d8a8456ba558e15fe9d361fae1181666058818987a38a03182745d9a1c877fb6941c2cc2f28f6021471197c88c66acf7ba1fbf3f7bcd06e903247a6aa8872f0a25a20799a647f31fb75083d588970ca290861f56e3f0e3e2a4dd9aff2204c48f3e0c4b81cfdda6a8dae61518c22d9814f09a9a6c381f8662387ceaae0fafaf2b00cfd142afed2d9ee9b4baca0692933aac826fabb00778da72f79b6eed6014123d9b244e73972e94bdd121bfd0f3ca88612b3057f2b90796cde23a10fa0ab60bf2bcddd0f47c71e0ab2b9bf2752aadae4e2a7dfd26b138b3cc86950d660ee6ac2aecf0099946b4985417d9ad0d266fc437c1902f6725a6e5c9d9e7c417d9ac824f581d5d750e077bf267d7d65db1e65620b367d972f5bd41df077c348bdcebf71363a1439be1b8e72dae84b92d99d616483007745f88e2165a907648cf2db035c35798d93adb315b0d3be6132777b33e886bcc3a2c136a0be1c90bb1e5578d9c079f77588fe8dfdf932636f9107b9a78cc5c7070c077d6e928ebf908820befca4464d2e2933d32cb0e2f93fc091d6c2e2f7a3a5be2101a6fec306119695d4bdf56f2b6967bae8002ba6496db0e9b6f721c07d5cfe62c2c129ec2d984f1c66fe532e431ee09b4e78c5d3930ec904bbf37c2882ddef5b384ec9ad105e3c9648d9e5826cb282c2da0ddb47ded207b0954d2e8f1e1853334ade4ae6bb5bfde0d0f88b7d854785057cb7083a75ef84dbeba76c64ef602874df337de0ac40ee39cfbaa001bb46c7ceb09d0968a332e7030ad2b9a1ca7636f6f5e149be733ee09abf41bd946be5f46eee0e3749d00d45df31556adbaed7e9447a4107007c8c688973636377e9504cc80c32fb508d959b6ee8cb7ee7fc9a9e8fa965627bd26d9b115b2900653c39750b2063496942cd61e980d32244a70a55b82492e993ae2aff61d149eb7320cff2536e290659d3e672f06507aacecb10559b1761f0b1a250e12b0161a98b5aa5b8f54d8bc538e577e74cedb88c98a0e461cf1d210fca08b2fd436d6e3334b5201a79a3ca983350febd9857b909472ece704804fa156a03db8ba483b528044729db6b134fc67f80bfa85d744a857cc0b7bc8a366f1c4f6bb061ad88fc251d072af0a13d51794c0bff2e5eb9497d67417ff1483cac58432cbcbb9ccd3b7e66669f7286c5cbee980cee4a8feaf7beb6acf51906e61ff145bb19f23912bc2982eb2b15ec1ded69d49334bbb253ef9858fbeadc54f0edc71695508c45c8b3a448d25c9126d02d634cb7b49752cacdb3de3e342cc0c92170342eafbfd50a520ae52d0b7308dfa195cf0a87744d4dcdca7f9ae6aba782755e9e23614e6e38c576553799c886239be6d038ccd5413c9b5aba79731179341e0abaceeb2e60b7c22669003f9d627bc8c18db669f293ca15e05c773cff0d3f3bf9d7443eaa7829663f9f6e860776e5d2ad91be9debffb11bfab1a839427e2298c389894867a9909d8931ba60be2143d44b54d01ecbd89fb650443d21ca518e98c3eb6bd9de165b0e12528333c10a6244e6dcd98216ad5b40351adc6717964c0ca367267e151b9f43fdf79caadedd1914c624e350c9febbc42b97479d7b26829768d0ead314798a46b0afc5bf7ba1dd9e59f0e7edd1437e4ec4dbc77b80603f55844da75d4a37fa5e19728928b74c3e1d131cfc4466dce150d4fd84d624f335917d634a2806cb184b8c7c0a51fe8b4ce22476f3adffd2a199a493d641b53118b8cff2518f7b5ed1e6d502b751e471efa965ab3045343204e241de48ae83ca52664c9b92727c46c8cc444126702c52ace24e8cf9071a48a45bc5dd50078f407b945336f22fe4853ee8776f7fa48a5c4f91d4c16dc4a2323f87fa003ec2e3d2893b67f9ad89c984826b8cf7127a151502849d3ef8f13cb9024c0fcecf2c7130e331c02da28a93e47dbe7a54787834602381f3f9e6c840bba2300c52b6e070229fa890b21fcae82c8855e95a124247bbf6a7132aa610a641096df5e89290b16f5150e55453667ab0bee6a35d0b5585b0daae8f0999cd9fd493aab24efed09fac3246fce3dcbfc43633f0b9dd2fa6a186ae89518869932bbbba3a3547fd489134a8f0927026f5f54a304b7f46ad100af9cb7754bd9915427871e6bf730129f7cf0523e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

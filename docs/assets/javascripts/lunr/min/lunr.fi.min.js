<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2fa7f45c8c2f36cbc21f8af3d9abfd1cda2eef710baa709154f896e988a9efbf8adb8dfcf9b0ca0e4d941589096392be01d0e0d862213214ad6b7fbc334818891e9184ec6bba6ec0921aa5bfb5426b828ed3d3046514d80001c1151197af1123e3bbebad921e5069bcab3d422f9e5fa43990c624b8cf4c4abe1478a5599f70e6ddc3f14022bb1b5db25fe6834177444fb0d849494e8f44a662516fd95bba9f6a070d3e7190978ee9192936fbdd302cfc7d2edc279ae5073d03d61c165e58e3a9f32f232a33ab7b97578cf9d78b6ae1ec92495e7944537b4db7b1b92dd45e6644f24c51f211b35d158cf600960e805104c183963c2f47ca8a777a49836fe563d8c7cb2db5cc1ddcf02406077c68e4ddd7b62aa2e511a15fa21122a9264e80773df0c8f071bb93039f5e78fe3c716dd3206bc7fd454bc11710601805fa8440cb28482aa54d9335960b0d5a989d9c6dea1d65adecb0a0f0def34d062b0445c97862e6b200dd44f2ce42073e0be13c30abf70451333ae965a6eba8e6f7188f5641b7693a01b6c60d9b78a19125586d8f97b98cfd63effbf4f0826de38d92e129967a50aabccc51592e724f9ac4b7566ce6a9922ca5f2be68b68b4cd1a281bbe733f5cf222af7573e6041e35f917479fbffdcaac5e696578faa585c8bd4ec90ecfb444373d44e1a76cb3da9c7633c451216f2f13c9a4fa8ea39075507025ce1ad6c05efe62dba27db5f7c6eb925dd1f1c53eeeeeeb77df4f3076a7ec7b4ef945bf2a92b0487bd106951672e2889b8a7f14fa6570e51d42640c4e31d92a7def93b18c5a60ff912448a6d109bdec0ed7bf50c7027b068ace7d14fc83b008f787916dcfd35d846c7d689a321fb8983060a6abd3d1bb1e9fef80a702697cd1cdd04b868ddeb31e9dc768f52295d70e90316ea51de99ce59d4166e5e4ef35b28088abc3310a969030e8b7abeafecda481681c24781c59c9e5bca623c6b414803fb38694bf55b102bee10230eb5c843d727f3fd4471d5cc90e167952ad033ce1cd5365adc7d6545b35c4dc110eb4cc0696d213f4eb301a9645c1c2f5cfbb8ce5a4f5a280ec1ee8d2bbcf1b0dd8b94702a60eee96bb8fd0fd573ae92d5abc513650f269fcc91ea3d496cab0f73e2e621bff53c3c62524df810d7e80812e0f8483d37cc0d8ad377e353a4e73c2dc62755d7c4c0485578ae1a6114a44a6c4e3e7bf045880346187b6bbc9527a52a2c7759495e4cbc78c0ca82c6d47d60723e767dce4e029ec251d93cb9052e07167bb4d44bd44094818d0483c2e21a45d3a900fd787e5cb914a3873a482a2b8ad799ce1621f0791471d43774fce76990d204222c9d25fcfe2cdce0917cf7837a2c853bcd7acb4090f04e3f6a3227621af4b3c17d53725c9449eec6a866b96d15d636c3771fe4bd2ebf61b9a51e64f8ada17b6fb833402c3c257eebf17266981723404eb39ba13aaf918994730c8331e1b6c6fae9fe35ac4653645f55744c24f49f02b75ce1f52dfdf794df1593a1ad03b0fc1f5c1cf60230894a3c05c63f4be4930f12c51a3c85c3b30821a3ab49118e144ce7f2bda09d26eef5361554fd439bd51c05d887671f6e44554ff3012ac008c3c81a631db547d03ba69eab6ff5e483f456d5cc65ee1f44be1d6f4dff86beecf36e27d8cc117aad809c986a93f362c122d1b0a2355a34862981033e4a3a071138edad1209e5aaa6117050d837e671f8ca5895b917e2177e2f8387555e9b4d4b0b4bf477c0ad4af9a302a30f489b4e2ce42d7da161f6f1a3fd49521db0414e9fc849df0b305d2577bfabc7733574ff7a2c01ff23b4e947b38f5956fd97f1f4768ba8e43b018f7e75bc9883f753f93ac1ff7035d63e85d4a86f553545d51bf38b26ea704df6b671807e69001e28bd9f12256b0e4270c85819fb75d256d574ceb035183ff40cef40ce25ca49c3e731e07252fae49f172b21c96c9492cdb48e0b97127d41cbcf9d705169f186a3bbc4708121a873bbf38e1c670be550ef3fa8aa8fe9284946285290386dbbf3fd730b3be0507af105c69a6c33ea3a8f07a5eb6030612f29fb997b3c4111de10c88f6f43dec72d1cc85496bf30a2db0b2e9820951cf5cf0462727b4ec7ad3112b7af0cb2d1089548e3d8c7e77361d6c1686dbdcf2b3a5c20ea9685cb8c5984858c680f3a2eb0d9e7a5fd9abdc0a2c507c5293904e81c1767f8e630999ee62cd33b6e9be458b0fb0265650a2433726121cda74cbb70b90e5162e4036c7a538862b48d127c22a12c04217eede4d5a61559cc626cb641cbb148616a1c9e60ee6108d95865a6f133ac24295b5edfb222f6dcd2ff63445c1682f83d168d9437d7b30e711510800ea0a2a002770822ae8e47ae792be428c51ed9804284ca0ddbcef3f5d19b3b5906d7f09168ae07b96c4c4aabbb3b3719c04c8515bf4f938198e80cdc728d35202621653dae270b95fcd1e82ba8e3a28a989c89ec07cf655c1db2a7a75fbbd53c528cbdce0be4fb2e2af67223db990ac2e695335e3c09b79699fa42ee78d32845e582cd3e5310403b255ff43664093614a2b5b31597b877d5030626e080fb6a772467ee67df4e82b37693dad9bb3e4bf837315c90c97209770b09151ee6820cf5ca78ffb21bb8bb1ddd17e8311a2de97668aadb5c1ee925ada0571c1b36a2c305c72daa9eb7787bef4d9d6494b87e4e3bb293295f902af417b85dde3619fe0500ba4b98905b38b2bbb49f298fdcd36dfd82e1acdcc9b3a21e9ab25ad2d6e090e87af8fdf4d03c340db4938bea2243f3e2e0386bf8b7e771b5c9aa1f7e1200c749a5a8ba9b5b0d1e05b739b0f48c871f430ced62720f5d048896f30fe11deb0c54ef3bd4d9762e122a669b7d5fb2eb41ae09da0cce7aac64e1322efbe5421adfda5f84c25c32044c68e33e87c296c65ea64a911085721a6a3f469416f0ad50795374bc651c1f098bec2ff68784ced3bfeb7bac69375ad79e9a9bf39317db6f4f8d113bf7e5f9083c671214146d73e8e6120a323cdd5d0fba22b71d357943f3330e1463d3505491b6fc5267df3c46a2ee3e81998c4472f6d9cd131a122e0d849d396500e98e8ef856af3621e905456d5c74c65ce10c97001dade03c38e7a50cdd0782eab3058be2a2e489e069eb35563c17003336a229ef0f961113abc1bfc2f478580c54c1e4a90b759ecd7933aec10b9bfc77bd0ed65a54115fea32e50477b6a7e699820c01c0a9222dd062de0292bd6e3aed5f08e6fed785a01c772606f862a1275f6cd1edd85f657837a953c4da94632473b62aff4d6aec8f651ae87ca9efea45cc60c823bf171064cd31259c8ca347581391d9da5bef338b5826bf9d1437ce04f5b7b5acad38bba3a07eb1af4dc8891842798c313cf375670863818e9e9fcec40a2a634de9166c54d9e1b82b319479ca7540cf827092e616476830d58858026a102d135624017eaa1672a8c4d9da9b9697756a27237b40decdd8ec3ec367e9f55f18dbefce8c27466a66f8251cbc329885ecd92642c7c6e8af7dd2949349fe92abe26d2416b9b74debf765667999a8a30ceb53609b04ee94b6b19cf3cdfd9a20d932ada543e48e91cd1ecd0d9b092d50476e38a8b46b9baa90d185f1d440b0d254a62c006c22f323bc949e4122b1a7fe9568211ccab9bffea01b7e1635860b7a572358952dda377e27d6f71897f1148944c0d93daa36b01b379bd2b8738f535655d4d87c5388335fcfbfe6a0f2ea15fdbf53ea6694fd3b4bae830d8605ed534005bdaab042081bbb295abc60d58d903e9fbb6c7babf02ddce79895d0849e073ef98dbb91e720196d68472cc8f7c62ba11ce41156ad48aab290368b3098a44843187811e36ea4e01865c6906540bb9a18738505175d64e94341a04837f20663500c968428a6d06ec69927243971470670c712436c23c83d6a8700d85363afc75b7269ceba0ddf28101fd689739582921b23ac0642a75f034966e7adbcc633fc8d8acae9f63c0356d6b8fe3dff225962c0781be0b733ef42295b20732344335aad964fc308f944c4b0790a6d224141d40bfc8ed5a5b65da4bc437a3e0502266c7e64033d891b6503126b01bd5cc1df7cfa00d20c3f127c190baf60c1de8001762f1d9f79e33cbd37d173ae07e7fc71df20724da4c1766c4380103d29d142933d9c4ed73dcdb2f55c65de66d3cba98860dfe6b4d0a623befce3c136edc9b742055fedf3400d864b17869de79be23d3a912934592239da89dad938deadfc6475194f6355421cd4b34a950300be8cc41e09a4d79cbc2062f8a2fceba10671b80aecd5c06a4e6121daf6e97a1bf432fb3f8edfd4c7cb0ed8f6287924eca61bd6d0b13c99e1a5a6f2584e527a81367464aae5bd78bfb4eb2a4ee0a480fc23a03f8849213dbb8673abd105d8f99766dfc388d1e31190c479edca8eb6b119e907af93b37e5cb0014cdbbebc87413aeac34e88f5a5f660df6400e9d353b34319a2594d8079cb842acddae78126d465f07f9a455045c1462ef603c95c01f79332649cee470758d2ba26047c4ed3350a75d27911a6dfce316f57cd3d82828d116fec62b527c885865ab8d31ab72650709d2c63b839a34288efe9d4fd4cf25cd4fced35d37e590e64d3a68033e9ca10aa76892ad58dc4b7aa706b6d67acc1e5addcf309a59eaf4153233a3b78fd164f877a4126d2bf5ed4ea0aed1502140ffeff6ea981e4aa41ae9d05fe3eda28333ec2fe2208e74c6b6fb83e6ac8530fbfd556c203277ef6d4fb44c22cd356353be9e992ef1cfa0cb71244552188d22c2412216665af4d0a1a472bf33a541576420b59002b0390c5855506d5b9593a5a42644021249c45ced1e18fcb9a97cfe44202e0d8caaadce8b5c83938515286dd91ac332aed019f2186b1ccb6522062d8ec3190a8550e7762e8229153c285d137e274aca99dcf7271edae15819c79dbc83b3cdb72717e7a7190fc34f2580ea54376f739764b012ed83c71c9330bc258b5a0cd5b6efbb7c3946d3142d374e8e49d1eb1f1e68d10e27542f357604a5e53600759e5edbb731ac6dca869cf69e6a2adc64051ed74b4a80ebcd85a41b611d03cdf52e2f053d660fac3de58992fc534025c6a6e2f2b9f1ec6508a0b9c915e5f972de99aa08f3f3c9e5786dd2e83284f8c08c311cef4f3b91460e78fe116024c97e1ba5410cd15a953458a47d1d3f2faf939651d16f1e079f6f2b46fd592da164f0b06197b0ef51da1d7be59e20959ad2ef9d316f4c914453f69a50725450872f703af32fc51ef3c96631a0e460b23784d8c14677ca3908c4126579916a71edde4f082c56a49a6ca4897f12ea4aaf806edbd558b51181d01f79d36b8b6e080c013ce838072f8384f75076903e692fcb2febb6e22e7d986e49e7fcddb4162b7c06b0131b447bde8c81de2a24a4eec2fe36539a35184781ad0927d2fcffdfcfb74696db6d06b17f00aaf81c77bc26e1397b33f5ef0c6b32c8e3773f1098685291667afd2e658fbea6ca7f7029a3ba9255eaa488b2e5ec5f8e9be8a8536e5a3aef6e9cd84d5e4be653a248bcc09541e66a61687e735ec613ed24d1bf047aa33a42af5baf84a7fbcc51ec8b04aefedd8e000426e1acf9da41bd5add7956b352174c22f790a3c073c0c4eeeb93fd24fd5876e2ad50633a91373d9c19c1aad242fa1a3898add3640fb62cc2e63eaaacbf95f4787eaefb2910ff74c6664b31ddde3bdc58a1d58cf3a1b7dcb206c4c4aa78d3d7de1010c3735dadb9fdd8d1f297313a9fcaaa3b5fa9462dacadcacd690f2527227f7999f94e4c71d08c359f3ea9739ade6fe8bfdcc2b7d4e4f49d1cc8d725b0f8acdc3e905106b0b28c7cb37e91cb7211e0778bd77fa1e5a9ab164c185f6c2bfd663b56bc81d22a81e211aa78b39bbe99df8f4a1b1196a7376f5e66c5b04c53f2f02b87b3ca1284de62b39e2c4f2405a5bf3915d309ae2ab1fa63bbed62a9d83345d22ba6217f80603f9653eb2f09f45e16e0743f90a5c5570b5199596bb42322a81c318f71365130ff73c5d41800e51a6c2f911d14ae80e1011ec218bc72f0f823e5025f7c540d456b28ccbd098058bbb0a234ed817f1cb0eaf4425d585e41400ff58e14e62c6eb7473474c4ceb6195688bde13459aedc1eeac2668957a912df2d4de4d91c4cd1a80cfd99f100795c3bfcfb2c4faed082c74db1cc69050135f1a09b56838fd09c48fa03e4d984af39f0d6f58e0804e6fcd33f9b380b476c191d4870b3da1e1a73128abb7a6cdec437439b2b6374101afd5db4f7c59028b5c78c0266530393e49eb964edc937ff4bb643025e24dbeaea4906c2b67442dc99b9243f2c300d4caf4003947141809ad227126af58111e3cce455ef58e66f94483191e364466bd4d03b85be7615279586b2faf6f2e6b955e0f1cbcfce1b9deaf380779cb435e3161146422c304260d8f906a94362f2493f14478f3537e223e124458df17b7f3cc5c3ba12b9dfe800dbefeff887b2cc75fb4347e8857262b55d7487227cd2448f85d1c56695df65ae0f5f3138b78b6ece0e9ce8ea4ecb50aae2272e1253624ceca36c7ad00671dcd7df7a1a094e6cd53261681e8b6e8755f10815c42599599ece7eb45f2faa1ff7d5203484d9640e1bebb0f36b547ccab7b2f280e711a9398149524f75630c688284cebb4014c228c8dfca0fa9b2a66220f5675704f9f1e8e55aea58b86c1a7b3198043c8c2acf4a9949cc9eb2fe69a5a073eb994adbdafd899610377dee54ba2999ad92f0d6337dae2520c446575dd2e880203497636f2e5f2cf2813a6732183c47371164eb49e05ee038377a46e00d8dea48db6d59ae8d562547bc7c9218133d26a8c302df88beee1b2e1b54895451ac21b30f186e54ee33ff0d8263d3979f7e9284f93844655294daa9198e95ede7f42602c77ecb4a3c1b84abb90f38e3ff7e401c8713381b5423c0da5d3000322d987ae564849873c3edbeb4b608fbb65d32496465368126d6811c261869fb46b207762c4368fd4129c8935a5386e494d4553e273c4fecf2ace4a20a030058aa26a3104b7f6059ba4dcbd8961029594c76814a85edf5fab896f0988b37b79bc6f9d8e5f70c0e862e5a449ec12bb9b2b19f0d471097adcf5bd386aa9e604e66743ca1db7abf693325f26df647874cc599ce3956c3324c62169051a31728fa2fec1303af6ec82c22981caa5fcba9e337b1b74d9c7679f180caf0fdfaaa6fe345c8c935716ca5b04f17416e1ad9e58ab41f53e37ac4e832f034c157c1e2ae1f50cd976d3210d078626d37cf0febaee5ea0d9582e1c06ea86fbb3ad567177018c85f40b6f38ccada664606ccfbde7d68cb7a1c38850ca3311cd4648f4b5f60b9ecd68f801025edda7e053dd3219ff9f0e5bd772bb1f624e8dfd7af7dd062bd0db38d314074fd6871ce6c492fb9373e75d80596a4ddbb020f34bc95415fde44060a01b1fee9d16b8dff2792097b186639db49b6a87a18a88da7f6de5a163e63c5e2e69dc612cd887ef27cfb5b06997fbe71392a176947f265498a7758de9889220330609c0fd2ec956ca74a49154393186629b65d965f214b44884ef0e426e5b76d5ef3c1336288a54ef79e2c5d396bae5629e3e8f78eb0a72c59221f3136beb0881f1b48b122acb04a7b01ff7ec30778db92a562f46d22f2c33f83e5fd864f3e4cdd8de00ea93cb1854af2aa499e95fed7ab68d52836e6b5f2fb696d60a00d665b15933a19fa1c93ff381af1dd1042741a7f360b57fffdf1c290f30331f4538eef3015c7b6d26921149f5898349915606803882b0a88ea56b0ed69bfad2475c1fd73c0e27c88ba6eee767f91e09e9ba247c46f3075def39f95f1404d767a250e44aa73a39942135dfb6dc8311fc83d6759f7732188dc38d3669e73d42b16498885cfba61aa75105c13711cebcbaf549a172b5e0efda4708f684b3ae2349a7d627bdd652117959af5eb6556a662989ac0c5be0502c0ab5839595053bf29445142f5a72a64e4a8db641d5e4e449f485b4436082538ba45ee6e3dcd0f9114d209cc40e0ea03d3c0167584769ec40f102e09b320e7d732922e746421d2582ee38bd981c56c2ea367bd35c9dcc22cb9250d1583765111177d878e8b64b2e845f70fdeac2e266697dd62c8991b46038dee2700f3db11500e39f36909bfb86d4ea887c7b375b04c8f85c4c054cdcfcc09264ea3b16444c320b490cbb6759e7a18c7d0d6ff5c4a273fc14a15fccf6575035d07b663cafd5428d01091426e6e56e3a7d1504bc79fb3d023672ea6a9ee61178d1d11fd1d5abebc087ad087d759aa5e2ec69c03cf8509af42199ea3ec7b7aec7e1e20fa4dfc7f7ed726ff8b3a6e2d816e5844b5c30184f702d066ad67cc793598c315ed0e3c01e5b52358f59c2f35be6c5f8d65b9f1d54aa1aec29dc5c9465c23a720ac713ae4aa082a5cf97e2b901f2c6d9ad047a05c1e8e48a2dc3957afe15655ef39966c1c67df6af827100eb5b85a7e053ff25cdfc77faf80cddf53035337c0ee0474dd6f52f92f270a8f57e068a5d7bd54d169cae1ed5de987c7f30aebb8800c8a7315eb1939282937033bb7b105de7f3684d514f51d8cf12b9dc1b6bc8943719a041b6f79cea8fdd34de32e1b6f8179edd7a0327aeda9e8807d11e4dd6fb42323459b1b60614045689131a571b4c50948d89522bfed1dad2d92369e950cf7389e43498b82a7f2a810b8c8eebd8b88c727930c254fdb080371c44c1dcf3f33c3ee4a300f63ad70c2be3ca652deb5fe13bc38ce8f2b40386793671b9a8214d25e911f4f3e42fd8ef55cc27182234f137058e9796a797e5ccad829acc015565c7945a602dbb4ed09f87df83fcd79d71a3fa569f37298bfc9fe21230e614c126ab3ed488350f34b10f99b777393d296cdaf620652c78b60be99e8f26c721130511c73ea45579c71e54ee259109c4304f40679be5158b40026743de8774e9c53ade31e1a1903de74315682b57adbd02af0aa12ba3a0a694ced214831c3472474574514f8acef4ce38cd6b52e9c0ca2d6b6295bac1c39e06cb525d8b5f17309e0516ef02c6b902db25d972331d0775c234ae48c3096719830d23c662fe7f3ec51df115b503bbf35ca3f48b2942a8d9e26a7a0ca9d745d7cf764c306c476a1f4e35ef0bd518be4f91451a71c2b266408ffb57639d99d55eac4084710b78227b06d1b1227f01e0efd8395cc68b7e59bd488ca86264955cffdc1aed4a110e3841c8d8b2ef6da829a591a30d9300bcd7aedde7dcc350d86237ebdf6b310a41798b64bb22faa0e4383f01748096600dc0382a2f771446c3ad0c24bf50ed814c9043a857f1eb73c50e420a1936cbe0a14e5a0b9e4016696b5a2f65ef51e0de5d6fd87c459fb0aaec9fdf740330911f7cd5888422b02d9d949c3e34db4d1d35ec9d64300556bb65dd8d7d468bf91cf7ced54f54b0c14a8a4b5e552acd193bd0206bbd060e528124073fb18e1946501ef97349e4e47b3be917d412d3bc8f07fcad263c2ec2f846e629eae96e898000565f4d7de747603156a00cc5575a863a2a08028f1afe194a55ff51da5a85d5541dfec5e4a310f2d2867fb896ea70d1dfeafcf9ea865aba5fe719cd19c28f817492db7d027f5428d70b4525d73803a009fcb933ad74d57524792da64aa29656db0a6869abf618a57bafd28ea7253cdce76455477aad47991f782bbdd90fc7ba9213d8ff1b6bdf7a0dcbc8d34373c185bc558c651b3cf7d6356c448ff3dc21161f1dacb46238b725c2380757c9b9be9b4a4c439667c95aa9c8aac6a5f23a1c5cfb093451739f862b0f7f8f1879fd47e3ace3b00645cffcc9eae7e51d0cbce24d8c47faf358b84ea1699fee37564498a8f6e0a44d1e68f42625e5c943872c09db543227fa060d49eff3357245c1bf18632ef12a8d4ef686dd2d21dc9d9038993ab195ca93d3a81058eff0ca4afdd134c21efe0df388517b48f444fd10a375eb30528bb5055aef174691bf9cc930454259b452d9460a5637011e35eff4c1aa86935a7cc65a40a03762172ce64624788bee3532946ce0b65cb2fc95f1b7667e30298edf3fa9395440a4fb0b529ce95f2d650999dfaa97e29de4238cb729945abd298c29411cd4363abd81da603c744f9a19f8fc95f9d9b11ed891655a718624afc88dc0311cec62a87a7166c2413d3b45b3d667ea97310418ceadad65ef1d9241e3e23aa8c037e63416157d76b7c47598768399dcdc68cd51dc788ce86026b38ace1534b364fd7df644e6768dd108bdab1b1dcb2329e780b6caba334178d61769846a1765e8dee0ffd26bdb3600088eacfb3b735efc0ff6248c8becaf3ee0fd0b72e129e4f4d73c6216a12dde7f2740074861856fca4b384c75624decc5110a68a2785af13623bce615f3d40d6c81bcfaee27f4b70aa1d73cae58d739e2c1b78c243e334ee4cad08c84c3d12acbac418be578da77a07ec8aeb91d74fd094582a5758e3146ecee8d566fdf5688b97b0d4d0c75333e5d35b81411afb6a9a7afc5af5752d8a1095b3effb5cc3eca1fa60049302dd78be0460f2ee7b9688fd9f2d92038e5b57333259d00c0bc97a8af2780171ea1395a28200553cead97bb2f9e8283fa5310a23fbb61b4e520645fca9ec8c2e65cf0bc3fdae7b5cca4bb42e1e440fd1399190f645c1f22aa218b49f72e095adc299cf74eb14fdd238f23aef5bbcfa1cb9fc61b0c305d47201898b75690cfcfba7962a01830a8a53d62d56406ad0fe17fe4471d09cfcee5e845dd8b61712ed04ed0e8eda4b79de2953b28f964202cc390abb7fd5f8b5d935df55cec1ef1aa13ba0a131069a27ae429dba5e891d8b9a2b309ff20c87d1ea25d0dfa753503f6b207dc2e6733026f9f25a70316ef13105eb994cb4af46a9deb02fc203981dac42db3d8611f612dc68a9d93ddf2338e6e73c6b6d8876db4bf5856a6c388886b32173bcafb46b3e9f8fcee8ff7c86deee2fd86f0127d04510b914390a96721506453906d890af5e3b630b069a0387ff826d75d5bdd0bd099e41448bb55bc497370bf4ba68b580e7ac5f9229f166d81cd3af9e7e464dfe9a9e1a413afb7012369419fb75e4a460b433848a4ff62add17aa12b2c87deaa5f52d607d04e1419e27bd1a9e1c9b3aabe5795778f5819002d45ce7f2afd01bf999e1ff9ce81d9cab3a0fcadc8353e1f4c6d46cebbf5a08fe8fe054c974316e7f0487b6061c0513c6028cfb052d562ba1b864c073cff55d87356802a8177b64a70f9c13f075f1d44369c77917705ce75d3b13457e09aace46fa53e3a65a5b0f2d1bbca0b071b1a90965f644fbddc491e6aeef034e551f01b28efd0e4bdcd6ed8dd6dc82feea1ecd0c00415ca4eeb97c768070fda98ee31e74d816f73dba5a42eceebe4166b47c73a400425d90b4bc9138d56294489cec4de38f02ff3861e8c37879e19968d970c648e65c5ec9e6abf2c82005b795d92ce00e707e7c69b1e1b8478d47c7113efa37453afb24af4ccebf25b2e5d69b3c99b340e620c58dbc86af2e76915046bc92bed10134727d098ab41765c22c40d106f072dc606ae4e046f16a371e1c4272932a597be38eea7449a36e8c6df6d9b91490d47471941dd03f57edaaf2519a1987be32e2226889282d56f5493facdfd6b3bca9c95a01a673d892deb74500d5a512cba725d77e33fecc48f93acb57116cbcf26d52928b8aca6f7a297e1868888323c713a79be605672d437e7427becb6705a72eb6bc7347cb4ef1bc13fec2d6f7e3c796bf621eee1883c2a418f9eda6477b14a32f400c043c77b32d517832796420212d1b5ad23b717ff0d347e3911fa421b1b0ef3b6f4d97c6025b07feb5e2ca7752e6882a75762e9a63f65c8fb7da209a9e1bed08a9d9763ee4afe3715b3afdaa503968dcc6df7168a6d18559cbfd08d21e5092eb1789e416c481532c15ed540d7579288e6e9eb1db4255167a1351fb18da447dcf74ab80d40c1ca67d3178a1a0055a06ade211b180f3f7e529078a286fb5074faf99afdb7462fb81f93dbfdece7e6fa82e28717c3774f0a6b2eb1ec4b759d00ef2daf6cdd62eb9fccd1783e4da773d7c15abccc995e6231e0b98364ccde8d7c26bccfef8e7f10e74a42c229704151f1b3188906e647f1dd80e0e402b58f716b5cb3eae2edc22e7b0481366b22f84585ccfbf44f7abf858fb5f33755a537332d09fa142478cd0662d38ca45c2fade842b4a0f0ce6fd67ca74a50eac89877ef5eea01c4feceb14bdf7b677afc1afff182220738a8e14f635ad6083d5394a82c0692950c594b02c38f1551699359b1d2a1da676415a652dc88ebffe873928b65e46cf544d347a16e7119c55254f3e0eb38bff6ae20620b24dca5a56686f6255899e26e0c1d8bc414b9c092c5119a1b0a02965db6a3c8f9c562d62156c815a379b4c3f0b800a4370c6d196d581ad584ccd1d0f117ddd9b251f5ec7bd5cb5077f1eaddc7ee69d0b44ab09c8f21938817d631db51293257ea4936056fd27dd29594e6e25c961d0cc7425cb927d3ef44301eaef1bb63740e18ed5cd370ac54375c00ca0e6c78d05ed8ebe40930916dbf17c7d8104667ff4f731cc27862c6389fa660548bc08a33ace59d5d52f32ae67897b9df3e463ad558a347e752750611fb3674c764d20bbc79a73eb302a3b0e35d82cb5653676b78c77c02cd0ea42aa5809dc61fe1325266022bd26f2e1f56e1e350bbed32b682d029b1a7fb147ae70ca3dccda8f1117ed2ce6d4a37beb5410ffd0c9eafb463606a572018a122e18c884b51b8d83261bde28c17635e503a46071742c3d325ea1103659bce2a3fc3719fd173509849acd9055cbd24c14cddc758d6e3233bb93a30ca87101ecead359f80bf8d692d4e157b76db7584167aac2204fb8cee2cabe5956d19c8e37f9814e54d467609be291afab9f927601315a85fe8cc5ab5cee091a199fa0c32b73c222d9a84170686481646f30aee3ad990daf83a97b4e794fa29f2752005668c0ea4e6aed257ff764ec626321b02b7eb57026bf4ecd999220ee9ede829e78a1fde4879be55f0d275808538500a6f4dbeb797dec2b09cff9ddc05aca8684552b4f667d20d36a49cdf42e04d624f4fb2431f2f6b1bed023ad4d395477123df77da627c0a816e600bf5218fc7325d03e76fb0081d8152039069980c8972ff93852251d89a49dd49aebd00a5aa1aecd872ed738fcf70e859db6555a271ba6c57729790828fb5af8dc2d0c9a46e7317155a36f29aad670289db4335dcaeeeafd4606f5f903715d39f239fd0392a44094e9d841d26","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

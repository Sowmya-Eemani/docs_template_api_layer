<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9040b1ab70b0a14ba390b5cd6e5b70b4ea6469dd5294f02f8fe3f19bdfc5c5aadf5b9a84ee48b425c1e7491fd9ac518e844fc2da2e6602d925aec97f6b0c3c2160c276dea832e4006f30722799c6e1c28ad56be18d686a16d683dfeb4b0630b192b912451bcf05bbfd14cf961c94f58ea92f279000bd79a84372cffcf223ccf375bc22748b342e72a29c247a82d39d72ba4c3fe8a88939d4035c411fc72e8ad36e46e794e10a5bea036d9b5dc07e355438623b29615cf29a10b49351107b6903de82ba65fdeb8a7901b743ef9a88bfb9b558b6a89264e6a1cd47258d2834444c59fd7c59a4734004caad8503c54afb59f709e97fcca233a08254b060b66deece2822be2023fb1bdec7fbdf08526c008bf6c3a9c6faeaf1f44698333803eaf89c6f78a95b280a0c1a2dc03fb59282bbb51a063f51382a72b0123a8d1c91c2be152f56096d1c1f56609a162a863e27a24bd69264fc0c67303a651d877786e5baa8698bfcc2bda72aec88aaf558e5484b3c108e0405dd94b7a943740870bb047d04715651333787af62c72127423c94a3135604b6165c098274fa2f737d444b5bb7f67e23dbd013b44313cb6aa0e66c01b11b16ddb41d1fb9271abeca2c9c7064dadca9cfdb1b840c7c21fe8c8238e430816b3ac41d93412f6f9aeebc7466c12f50760b1b5966440c1b687fccff6d56f265b0c07e3527a990febd43638203d4617a8b7db641511198bfcf3bf6e8da886b3b563657ffc2b98028aabc820de6b1c3b32fd64269b5018bcf0aa9f0fba0788a34cb79b8b972358f63268083a54f579f01b77793c201323d2aeabba4f86e4c3d7797284d454e1968bb4d1c1da574e539ee6924d12bf0397a45ead5520cb3afa0a5b87258cc2f695c4928c9418dcaef159657f759df4def51454f48c587bb2456beb22b9f250f0001074ca8d1aa46ffc09e709d061b661cde25f788dfea9ef6cbe35606fe0e8b8ea8ea507991b46c18a5cac7177d1c0e45d6cdca9b5df7d4b1ebb9825afa517fb5e00c9564f0e15310ac5381c5c396956bbf891f52418b67325c37cfc13a1da7c5c46b53e6b1e7b4abb3f8b2be23e94292696dacc5d39db01928bee3d0cfe4ef6a68b25acbc6c8c0a9349c53b9db4382c5d931cbf61e13576dbeed01e25c299a0a334253e2fb7c3c2b313f51ae34a166f409f4331e91ddb7a1720c1ba2e07902692787994c0d437ec68acbfe500213a28bdbcc28d0849f1f2072e41e44ab96a1daf8346e1f9166ef3ed4ee91064e900515b3ac257298d2b265df16eba8dc9c6be1dee3f5f9c32b431da7167df0d30641050839a9367fa3d5a970f60459124974054cc54444db437d9de75a6eeddd607da8146b1935f6266e4ff8d90296fee5c421c83be7096bfff14cb48edc8c9e533b275b0a1d057cd1fef9ac9e1d064252c0c887ebe5b20cd0451593181208e9e4a47c8e53d82d187034e173b11a65574e740b0416a41c7867b55b2615edd2e6cc20e7eff1f52b78157402f1b3d4187e67a6c322446ce70194c7b2f90c1909ec9c19d5da81bc6513e35fc204ba2350e3626285a47ea847e37192bf9453a4dbdda2ce92ef92b56049909ea28c0db24e4ddeb3ea61db94886cd47abc0a1adf4622279835cc1cc7ebe8fa79858dd08f0ddf46f34576d9ff26dc5e04c388aaca36b96ac209c4dea7fed20a8972e63fbcef9ff24c2851688b31227d7fba2510da52d51cd4c0d5b1eec09532c1d2b04e131a4e6a7eb63647d70daba19656cd943bcb89158d5a03198a3549f708f74abc4ace1fe6bd17bf389a5427e962ae12792adc3f228d7904f956eaa9940980a58f789863044a5a7d8ec8aa3772cdc34bef25d044865407a2d64ce0b5d0015c30c06ea73adb81c95170ecdbb880555e4bd327c566584800c728d64a2ae4e2d5e1f9a77715dc7c4c01e50b11d23e2a48551ec8cfad1da23a54a52022eebb9720fd4f5f9593d92414ca83db247d8af1374ae02da7bb2ef55bc34b81c4ef72392653d295bec5db930c903885d550606943ce7fdc8a2989bb8dfa3ba73de1b1b7936b4a45b615a3445d816431a812b71d69e003a67c4f214f71e14053bcca30aa9c31b474cb333d054cc0aee42770bba217b78d3d18876dd3f3981b98bc91165e3d0b5b48a20c10b75ed718cfa475f6b9e67bfb4b361b8500026d140c6eaa3bba581331c81cc45bbaa22eb4c1d8774f3d4f2d62948a042665b34638fc35d020c4f3557833328ac217fd579e0d57f4a2804f01140945ef25aca24b4f748f912e2ce16485103938dd5c4b6a3ada06f328d939f1d1c6704b3b13dcf5dfd32b14da681e712f3bab1dd96b007ab7904284350fdd62fc7748690c037d16bd0d808c5abe2d69c4b01f3b67a16d717c1238474fa03008d5647aa41c3b43be715a2bb5c69a65edc03c6288935d57e447fb04cea9cb27e46779befe4ba9474406e91dbac1207b2e86fdfc230c3d60739a5d75f11670e58c4501e7c9172f6dec5fd41b82bda94ae198aa43f13c376d9ee512a6fd00556c25439b2f3593ea1ad31851fe5b89d78ab5c9bc20ace3f09a20547e8c3b2aac3c628c2cbf1a93f6b1e15314d76dfac7e47394036e9cfc957a0550127edf91d3b7643f3ce9093b5488f212ac6b805ef297981b6d0e4dff6be64df24d6f13258e4673917ca72253e85b8d40973897a4dfd252a38c4cf9661c654a672aa6a4ae4e25207e301d40f3a7688388a215a2f165fa0e8d97a156199e060e02e971c62db2c74e9dc1d76fa91f7a02cbd5b229b6138e7b0fc43c5135d508d3fef0a44e06d2b301e252fffa8a7930011a08da1c125ab43812dbc6cbe554ee7eae075938241265ea723506464d3fd3e5f3a1f12b12e71794858700e1940357b57bad1f1fc75e80cb3e9e9a8cb897439db65453dddf68249ff8fd16256e5c881e3c7e03839b1a10add55f826393e65b4506663c8dd6d48432028a6f19454ad878d353521254e98860d2cdfa4f9fbbe3d1baf0028d230ef82ef5eecae9106d138e8e25b50b448367484e6e2fb1ec561b18e463cef90d6389c4240301d741748895ab5ae89b2deeaa5b98d4fd340173d64674732c592ff33de4400bb851c0792eef343c2a7622067ae19f83d724965f5cfe63d59f36679122009d235b8ee43b296606394d806f235c4e85257b162308274e5d7f8eb1007ba0b6326248094f113d5bcc6663e513b52c3eb018397babff556daffe9a8631e4bac24e8f62b37df39abec6d321cd644df0da905172cd8c7072452fd091d8857d2e53733ec969d6871950553ac33a60b404717f82b3aea0a6a71c77c00c44012920f3a6038c0728e1c098455d3c803078dfd35bb527fe01ec3c3aa53500cdbb8d3feff5888dac1002628a87930eed5bebd1d3d75cd32bc1446607955ebe7975800acb599d38920655c1d77771c42e24656e5a76490735fbdc3a5c950fd5c4940fcfd2ce62b35cf59687ead87e23b886d201132243caa3ecdaba61a06ec35ba5817c5a68755dba75206277fedb632ac6e2e6a5887262ec9e15a30bd7e9440cc234a9c419a348e602c68607055183aaf28f9795f768e559a07d787348b89ff194c245ac4768946fc033d4069b779298be9efbe5df66f58d835de7b49f498c9ecfe05b6cba6e60303269066f5fe7e561663c19f5c7c981265ddb03bac27fd652c8af28a3c0a3d6ebb702ddef003d06c49cff2bfd5124895f13da63d617e778aaf1dec9d1ed0388ecea78b70528c91b3e7d70a6c72678ae3b6ac115d4d10e9e31f5cbc786ae8d73b1f6a5df32fccb5d1c21e626bb8a7a002cad4545c9356082410eabdb8719505987ff3b80a6283c0d8b698ba519f55c98c6cf9a6bdea8b84c5d2eeedadb3e51f071a4c4dba5ee3d1008b55e0506337c5b43c8ccdae8548b48855dd6e36b43d7b74e88679d515b44fe25ae888691d9df5129d6ee3c3d70a5db4884e263306a3722824ae875c83609a1c36da902f9303becd2d452f1e00a830cf61061c49ac6d434c89bfb35bf1c3cb985477cabfd6ab510bfcdc1997f70ef27eb32975c3679b6bbb35236706a348857b0c62c32cc9957bdc373e740ae6c03907d51c6c664125a807287b7d4260863da53240508661c811cfcfc58116b8f402200c437cf9598c00f72c4b48d6647aa377c47d71bba43d9952006ab68607b156c1f1774a4974993b25d1a34788a5ca894b1b1633bcda468f1465ebbb32e98f35143b7ccba1a2224775f7298556f9d2fde4cc3f6881b5a6516004bf520b5b744d0de7895f8093735f1e1d50f958de09a6290e60dbf42587ed235f9375f600303e14af791eea0c0fc82fbb19d556f63e9b74d81d95911dfb063d63506a1a834c8ac23bbafceea231308b30cfbea0e1bc8ec0d2e3b014c7f4f54e1ec51a94b2b441ec9104fa07b2568f740049d8a92d65f70fa197cd29adfcc756c7b62f24f7e50dab3f6d2e7e6f7e228f8af06083e418d698e1ccdc4e6205641815aee8700f8934ae63997e27e874af4f6bb4f517a624122b13073594d9248678eb6b5c66b448b58e4536f8ed0ee1fbfccb1b04b7e97bd0c13e71977f8a8ee670c8836dbe72b6133dfbe7d03bd20c988b2bade7b67ff5b8de73605753ff4d0c6b29eca96d985f7c16693f24f7440558f1ec34473935065b0783dc592aa54ab46485206077180a933592ad35a733c34c2a9bca4bfa8570bcd0dd187b6b54e2d5dbb1df8b76dc2988a782ecd81ea594cafdf2848ad82d4aafafed51c14e7e42699e8c3556432bd3a79c900bbcda61ebf61dbf73d77abe440f60675301a38836853a41e424ac2824e0a93cea68682ecfbabbd7c4ede8967b9e644b7d11b4a4b957f56897765afd8aa72c275e2aad39fa087f375cdb986ce6cb4282d67aabd18701128ac9b685eb8f388b157976855d83e2e720429a9e3e6900cd1cd197a7ca615186c66005b205b6674676c8393d15cf1335741ff94ad7d7da08cf4d8987d209c2dd4436a3dcd75b728e623ecadefb437f82077532024a71d7b4b1ebdd8e9649bf5b945158e0ff68d174a2a652274b1431465238ea3f5fdae68e628322846e52be1fc9704c4e78a2da60a5e9267f6e2c0b9f926787b6da3aa4eeb81f5397716ae6f598489e3f0457927361847710e1846c48aaca41724b57390983cb910c6db47140a6407b1b09c7f89673a18fd07e4f1aef9a5937c430699a9197216d4688f26d39b8bda7b0983fdb7c43baefaa7a35b324dfbd68d30587100a0c5fbf3fd140603edf980eee51a18ca32b2a96f980e20bb25182173151e5e335bd669c4b8e591cfb7fc7fed2c2f2237ae27cd10c1125ec1021728366d56b5df8f504b8401ca14621e7424d7d2da9a4da0fda8a736460ee24b308cb1c8e2064384e7b0c5b5b683a820950b9441657469a4fc1a2734395e26a211e325df9a799d5362f373a260b4dc28b7d2aaa117ead723b96aea6abdf1d8a9b53d8ece2b0c0740f96c37a6be9f975ff15cfe6478a4b58818e2f53d3eeb96d35a172ef336caae3a6edf00b6943e7db8446aed56c049e4232179216302e6da433d58e042c3d28775cf8fee1edf6d455cb07a60b31137783587379a9be9c17478d4e1cc0256f2c38f76fcada865bf7dbd26b583b08091cd8e7fe1ebbf86003c7aa881fa29137449d1b731b6be6e39b16eb3bccc0b17508d022b644221c85eee14b7f86028537576e46fbe092ccfd67894827915520aee8da02e93aa34b1e1f955e93d7f56969cf2e043f8855151358855b4e022895eb5bc19dc4d1329bdbb88b144f6b5b33af9b8803c99d32cbff0594478c907e3f0fd0884a5d08bccb89ae330a9db7efce9261d7be3b20280a6887898f8f730133c6b96f5135cf4ae8e6026729021f074dacc259268fc59cf356b5c9101986a4a85261f99073b291de3c78d08b6b6c1051d2c0b7f9039ac6fb4d76b77bbcee62ea71a87d0ce840f786c59c5757f73da085c566477b6826a2d1f454ce18559db01c1c48a5f9b5f3251c7bfdb3c874858e740a2cfc95b3667f7e24ee52b85d0fb9ef9f943ba5293be70e3445172af4de496731d483634e20bd05e2b0cc28e8a348232e567ed0b21808637082d5b47bda924aa706b1e32323a72805b9a027c071af3ba02ff33eb7c973b731192cde80a52e6fa5609dd942b17b0b1488b60bc18406cb5cf653fa96f27c4a9a8c6edee604668dfd72cda8ca56873244e4718aaec7f2b408de445010a5f4bdffee221068fd4ad86bce28708066ee2bec9910f7509f684660ae06de95c4ced8cc17d5fa1f5194d6c1b7af32feb5c6770abf787bf77db112376b930b4020a82124a9ed90998c69960e165ab0ac76b0b0e780fc3e4d1224778d507cf87f0dda58467d6b14797e6eea7e5478b6f99805887791fcfa7f727982cfed7cf5fe85cc2c3b00acd0e76ac489b98b99d74d49b58702df07c1fbb85de212da29b0f71cfbf9b42d5ebf4707abe53a8edf109eec15060ba1fe5f7187196a54f637d84fba139b0f962e4c08eae773c24aded37c9cc376595c9d05635c0dcd3e36b101aa0231b29ed45f5d31659268356272a97555217f518c40970e671a8e4cda360aba5d7b3b82fa476636c1fc1add80ebc7eac35c26a63f4c8a1b775c6b14c944d9f4126b5f934db42f08e2a700b49a615eaafcd8b4eeb53ce58312ffad292ab0fb64bbc077ccfd3954d2a444c0d744f561af086d0ddc967fb0f5e3737deb9b88a3c1c068cca5e7c2082160355ab32cfbb6ef89034b38ac9d0a66a4f5b93fac9457fde690fd2daa1bdd7f5703756959afbcb5adca2b202df32cbb6fc225fa127ba4ffda65a0a7e3198a37eef9e68c302ad2349647e739c3d5dc0f7d9f6f6225e51757e2b67055abb6362ba1bcb8fa9b3812eec56128112fc02d3882592316901ec8af1decd27dcf395594f2e8ea88f5b508c30fbe060c2fa958bb459312971a207e570394664068284abe70ae36774914ad3d8790292d17f80dc5e6c905b0fb907f06e3a1a6862ef16fd7981f589b4e6411a9aad91506ca1610f0cb2b6a4da5380fd265530765a9bca13620062dfb43189e206bb24354b9210c5c869597ab788a2c42da6262fa35fb8dd25b383bdb1fa38034113a92a13cb2e1c77f38c842503b8a1fba0a5a42228a8679eb329c9221f8e58189d8b3fa93d4f94092b0bbb12501aed7acfacacf104811ebefecf892d7864776aa80e195ae03c14e506368f2112a74cfc7c6843089c77b9c3287898075b2a20e6f929df88025cc63ffe7fead81cae55e362a168bd7de831e6eef9c148cc730883a7afebe121d37b053e14ac7457a0d7ae66a5156378a0a02217a5e43a5f02f9eb52674bf3fce4a47166d0ea340e2a30f496c65e75fb05c9c693a800b1876a14f776d2c6172473eb8ffb17fb298d7a7e7646b8d2726be92cb843ad57c07fef98781093a5746ffdca16572a0bace1517a8cc15273d6b0ba5797f745bbb924c552c14e8c37357cf1ca861b863dd6d23f5554e1e4d837e5e924ce717d022c8d91b63fb35cf4cbc581a3e4f9201cd041e78bf84b19bc4e16dab41e26ed92516dcb746a95b3ce8b9083580ec660723099f1f5598da258cbcdd34758efd42a88d75aee8a615d74f00ff5a27e1fb53c4fc5f124e550ed6959c41c7060440e957681bad296fa59cccc4d6b92faf9abb9a50eac333e78f39ce9f9c98f043878b0fcc44fb57e9fa058a8882595d6064b7514ffe4c046ffeac5dde383dc421a38ab3e796ba324ba5dc4b61da6ce838e830d784b98371d35f5142a39051da24685efc0bd0e899b3ee441c6d80f536dd7359d0ebb06cfdcb09a81a5cdbd05d86339a366be3da6f07396c2f0a99ff44d5ce6ad8bd85d4fbe749ae3715e54c57b9f141c02431ff7345fc4e143cbc8c4a0577eef9454990c659d79786a5c7a25973ea70370c6e8dc441df36120f088d40852c3b6b40d985562c7cf99fbdddca8a69d6261f59e9f33fc69656832c4dbca31ac2addf65d0cabe60f722b263afed16ef32c1e4c09692584bd06b1394eca5cd26de31c0eed3daa59177a388e1ec99820ec83cfaf29bddab94faeadd0e20417d2fd4ceab5b9e8955237c0ca49ebd84a2a3cd6c64c0e40e6ac9e0867a6aae74d361346399905f298550402f926bdf37aadf2c2e0a62885bd5de182cb964c5d029131416d0fb014e3f9a6e11f67dd70e7336575f0c8d4507459b935172225bf284bc481ec1a6f6b8852089f052e2834e00758eecd2a9c8bfc08d0769bc955ba5139c34d651d3ca97cb300639b68619e8663395c02f606220b6b661b08fa19c6df120d1d7481a5055e47d924ec76c8d99a518a5f5c67e3a59e35822ad00cdba092f4c43d0e3e3eccaad6bb4dbb18fa06e5f3e2edc44579325f61837bed2d54b541261ebf74b7cff2778dc9729a3f6fc75b47ed109903bb355155a772f53786e113ac770fce7ad793f7ebd16b8b1401e7b1119808812048c407983a19ab65e3925607075d4121fe7ec661cfabe7277c01b9076d4b90954718d45ae1acdd2bf8b40851ffae7495a6d0eb1f7e00e4a62483470534826db782591cf4f2b3386fa708134736bff76343a2da46a8e2bbafef8f345fe7ca418ecc8792d17e2adeb5194e114c40ce29395fbe639618117f61ddbbfa987ddf35ff9420cc42ccffca304a89b901def7ce709a8a7634c4cf2dc74211c9a396bb5a8721e2b7469fae82923e6785f1ba1203fe98e5bfb92b64d16357a2d7ac1c1f3c97e0f53b4a3f32e93c3ab7644d51b145c28552bc6276411eb0b3df42679d07d5c8b4f3bab516a4e6aa6bce1d0e9f9626808b617ac4f482632e8255532d4206485f01e1feec47b98af8f499982bb9649ab24f15654e2e308370699fd0b80f65e9364af054cc12353601e3b03fb5d290fb917e2e60c51b4776dae3ca5a8307e56878488c535b36b69ef565c50c093aeb178672beb9e94d57c38e4de027c366045d741f4dc74733f9385beb06656a51c2f444c8616cae3d34497181354e07e636c165c35d31161d341b3d2eb4800077e0e836cd4e2de5a7b41470355bbbdc8c7324bd0ef725ae655fcb544519ce68ac67b79c619510dbd866e9a51da156d45b3768bfcfc9ad0b7230de1b0e934d030c00606d010f7c7dc88ade3b5734515f94ff704feac10d9de5d6da68d67bcc9a9600160bee6d9e395f7eeb7d608cbc66035b2b833ebdb591d749b1ed0fac74c0d2e10679d7b7ba14ef07b85a4bbf1ea07f0ee9ab0dc05db6dee18523cbb683e97f41ffd35c76d23606f2e0eaf9f2925b8c54a89580bc1719ced0a00f171dc4e059c67ca87f347a0eb0a56db464d6c5c5547ee15d1f8db16a7583a556a1f922f194d6f88a707774284a8e2faf69add9976588231814dc2518569cdea26ad3ae84898474e1d1558445e85b0d0a8b9490624794e420f78e35a14c7c95f9a5ca665de1d8a16cf5269ddbc654eb036dbd96c2a2e38bef592207cf89d1e3eaaaea3978563c643718e2c27f98887a508133dd588782b8bb40ff2f0f004cfa130f1958ba0fb3b62a72c5f993f11ff47a2c3eeea8a8a0b96e96d6abc732cffd12376beaa19e2805c91b2329082626edf90273be445dfb22c61f15309590b41a4d8dcbb1dacdc331b6650c8e570423266e9f9ee13180805b2840ac306496beeb3eb0f9e14935f06181d1ca459b3b2cfa88222c2d9b53f5215a4addb8845cae99e0da36f23ef2694f4a2f348366cc9e4df04e05ba1aa7f001e0216754a356a66370eb56c7942be0018abe80a041a050855e513e411fbcab274c4aff00582309da8a8041802f3d2a414458c5409eeb4391f277a36430380db66c37e2cb778480a4d9b276c393cc83a9f76786aaf279370b196e187eef99a7b4950362f49d97f100b944c6d5133565e9743870110674daa7b8f3bcc1592865038b32dba707bda67f042ecf4d9195e888291c1cbf7e5fef210f94de5eee62a64f8e188ca29b0ba0f0d384b04e3697baed9b7e7ba824a57aa5c57419ffb31e26899e989951fccb91ef47656fb107b5b8038721cf985d12cc64fb7032d6a1a9159084592bf87caa2f7434003e6dd6efaebc5379d3ea95ba6bc2677f7baf0c9d420e9d77012b9682cae7748d1c655540b5f95cc906e57d4161f0caa80ba35993ce6bff6d4519dad9057419ba921d164cc9cb20d6c13b8c3e92a2f311e7d5511e69c5c2ad9cf139ddaa653aa1dc793d79992002daec57cb8fe1e2bf93905e94ea722e3ecfb3743567a9574bc92f65bd65149b246d9f1835fea78a2a496b9028cb245421c4c7b4051953009dcfa5e1ff177598bc4b0e83ac1c6f82a21c5fccdc2551a9bc4326c352cb6f7a9b36b716b9d0b22026e38e37446d5b7beb0c3fb785550757dfaa2192ad54cbafd076cb3f1a5faa4f80099bac6b939a4dbd6049b36d721e1de6e6e9a16c8200bcf316aa5d541187054e9efc5a2f433a23969d2c2a6806b98bbc509e9232b4335e8e3ec5c4f6e7217a6e1e0749624674b3fe9baf04c999a7030a988829663e5e777b9bb1c2e5a6654cd96ebf23c1c29c0f4ffecda3c4b8fb949337698d128e11a68dce1aa0cd3efaa07b482fc5102849ca8406ed6e00bcde75c45176fefa7b8918860d5f86e76127fc84ab77671f08db945e86e9badfe48b37368b70e60c24078e053f67d3707cf1c17b4715681997ca3e358d54cba46c4cdbf5712cc6b2bf2586faaea74470126cb302f1ddbde4e88a1890cef36e148cc2af180e1194c695aa976aaef5e8b1b49d60e1e646004d51c782e619284e71c0317829372dd80338b6df980241c4c64404b055137a682ab880afd99f2a721f2032efad60e7a19495d5bd31839067df48215c7a159ba891e2af1c1429eece7dd50064c40fbe76fe1df1dd7a84ca1446b06469da9cef0715f706f3dd6e47cac8f2422ad77e62421d100af1c0e6758a1d6af5548ecd1a748a33af5a68221082d5dea44cfaa0702d6a465e87a3607a1d179c25950fc3fd8a161fccaca3fe30261e884ccb7031991e70f2be0555c8da1d9ab93a23a0ebd24d1ea31863cc58ab151389d584c28384e72c6f2d3bb3b8d7058c0db9f55955be44d2b5a0981fdb0211df3f2a3ec7af7d727eee1055bcf64e6731f27c402b4534cd7bb4e11cbca27916cd6928c3d8b86968706c39b327662876260f8b53d89d296cca9627b2b7c3a7a5991d3c0fc1223c336b05dbe98bc8e5c9f9208325ffdc1312edab52874760baa765bb746be663b4f75b21ab823c9e16d938e40042613d4d8d6904da09dfe81f1b21abf598d236e374ee5934ad856d17bc0c5ed10b62b663934f175e1491ecd81dd5ccc1fb86875fabed6791950e68584a226a51edc700beae8ee576999866ab7fc665de8670d0f6a5cde1a9fa80212fec0d2f79036297b3281b01e222150b6294ef46be31837c1b4f778c42fe32ca5963098294b117208a3558892ddb12ac34e4eb7123150149b3a4c5caab6774dd17d25fef75c921160efec27096645e418cfe4d082e0b78c8448bba84538501bb471bcca5aa896578b32a2e458635fa8c7311e1551b1a565b47b9e05e013094b85b021aeca8979a3f4bb11855f2eafa50ee4bd530324db688bcc2ed0b41ad369dff9234cf2a8ea758aef477fec2411601213788850e5cce7e83ba3caaa98c504721723530017d268b9ade0a4859ea05d05ec94c2c774347b244c6069891ecdeeac9791944070f29ebbb8e31ddf46a1b20173d7f30d9eba66f266441a1e83b1dde0438851c9236bf3985536db42618982aaae16991cd428f1eec9b3983b86525ae3be1e26c020ed3f6c1a3f6129483ee8dd7a769ff5b73a6909989b6fdcd4d556769adb11f33b0bb305208252df1127b56da83442cada9cd1c37ce3c5aefcea86a1cb2773016d8b7182f10ba383c5b6bc0e673103e575428190aec6d256d98da61745417a27157656ed6fd8216a151db1c4d528074ccd1f32a513440d1430a75a2463b7319b3f9cf84e071008cd18f4887c6dd481871f19e01387b8a86a914a66c0e09ba04b3002c871c1bb348477ddd9cd8e53284a82406507a47330fc13d05a6074302cccdf2a8bf8edc6c4e6207dfa3772704dfb7461c0a8dd4bc46642d4f55f261b7c36e77c29471585b5bf78355d5e0703bdda559c98369ccdcd3b2cd9bbb6b2fb69331a6984352eff0ec710644a1961b494734fc5620acbcbf2e24f0bc5e591f18b0ff7028d1ac985462f10d02d0671e668c309896a2f60cb4f367f99511c048eeebb2a4759587ce5cb5994c563e06b482ec5f5e80b8298e32d12ae8408f6c301edd0826fe76ee0077ca6d766ccf95fc26861e0cae85539b81e69a91d0d8f68c3b3b16431d0c9e18aaa3088027ea82dacc90040a79aa3b48e1331f6cb44dd9884c79a2042c27bf2a73118daff140ce12d7fd9459b2695cca07874688aeafd8d144174487f2ae41c1ea24e251e9aae805b9ddcfe7174f6a1852bb0f4f9bfd7292a7531013c6387fc7fc1a3e3f549886fa3223e45b198082eac6addb6bd960994f0136efa5b495c60194bb0ed6b5b39a0a097e6ea2c1927435706ce4c0c9be5a729aa1c3ec4fb030a3d9f166f21fd08f393fa5874e3e5301297d115797257464138e459bd513c3b97338f43e7d9aa6f0641ab516f007b8a2349f1523ea48f5976bb9032b6ad34190a22b11a28ed5be5811628786aba3fb5d151c9eee3bbeea0ad6cf973ea809184bdfe363bd88909d30dfdf8f5ef139e50117c17ce3e5831449e11b7c70e5214382b2071358fac0fcb812b4ccd44b44b2210089672ea3f63f3e093a2abd7a3fb9d501188bd1b94e742e1bb9a9236b87b3b7a2755601304444e4aa09c2fa2156f8feb3ea4b7641ca7e6d919778d669e80e59df59ad418aa6dec8f5f41e3e16bf102e8e8f46f11ce1f8023526f76bb94740f4ddd161453ae1487c773a4409eeffdc7483faea03aa2be6ade795aebd779e4f7f7f97485361f28dace2e20eeee962da70a4e2319c312cb253d4a10a0ed5b07417a114a2f48ddb87469fed5314573e77e96859dff507349267db0ac69aca71d045bf28e4e778ca740acad2bb8e4d6472bf88f4b9e9e12488a67ff34f90cf43010d172a400cc50f8b5b0f4e2074f823ccbe12fc7dde3b54a19d5f1a8f69a3ff1944b04c11bbb6dce28a85e86651cb6a21632aedb94033093841624f85db366d08af408a7caeea682e3a59efea2d3ce5783ff14660cfb38c8bf5f10b904de4da45362cd2885ee151aac93641a4e715ef9ce62c8dc87d337683b950cb21cfe326945547a1b7d32b0b07839f9b745f6674db1140a51bf752","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

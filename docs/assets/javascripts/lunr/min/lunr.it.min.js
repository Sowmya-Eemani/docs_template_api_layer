<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7d4cabab23c134746b271982ddad9204cc8f80c9d25528985036d3be3693f5e14f641fc66934a464e00cbc0a380d1d11e4bfffab446d018e0e941db6e03e63bdd4e15399226f6a284c4b6ccd5b9ff865bfbcf6624d20f8734f8d13a4ba35218264ca552815b1ebd5fcbd36874b6490186e3f0cafadfa9964aa837703be2c20e986f9e52c57990bb16178c8e497cb475ac57f1f1a6fab61f77f3508116e98893f71a19aed9903d71d015700eb25aa3c525274ed046b9829f70e6aff14fcd5266b7e55fab634c36046a529e91a999783e1ce8f92ce1bc1f8748a18edfdeaffa1ab2fc0d0652dd6f7b7f8b234e4e7cfb9bd4a90a4290f28708b0d3d831a39e8bf3e4a653bb9a628e0de793d2ce5b86bebb56e54e3b1961478a66352ccf036a4f5eb8fb116c2453c55bcff0b8abed34c5a5ff4150419bf863a793150df230e6493eba55934f46ad9f0a509cfc0ef621be5affbb5ef60e4fe738a72b0c92af42940acb71538b2cd89b757a4da34dfd88e2b547048dea32bfc966d82b9e0b72e378d1e708bbb118df75c0c9a0d5c851ba7807b363b9824dcdb341709815350e78331f234400a13a3965402302e8e53abfe3e5da87dd5183645f2251a0754e55f6a49e2c63787877603eda1e6844d6185599dd7a4590a33fa8c9415cb5be3df8cce5c300ce02bdb23d3a1b24e5102510d310c7691e25842d907c9f22bad43327c6a845b1ee5847fba099784f552dd8c1ebbd0d6826c1b47536e632b10e79d19deadc3ee3f9dd59949d0bf271d5f4848fae45e757873cf1395f024f6133a1f827e2d79682937a6634827afad6e3471b01f2c92880ea914a4fedc256331daa2fda3a85cb7b0e860dffcdb91ca1540d2f184c152c3bd5c970a1c11c2ec055aad1249c9ac6a5f05660477a9bf4e9367aff606737ac31f9c5e006fdf350c1e8d8288baa581c8570f97af44936de73a7d4032691a3c6d9ad0a752a8b18c6898eafb2870bbcb8eb4fff816647e284b6f28feeacaf7d3e234f9782494ba41619703505672cfba5463f3533969ffebde14831d15b157866cd5ef6ff469c72aabfd1d0516ecbba1f2c11c74bc0a2063a50382d1a4b25b3c2eb3d54f4e178f8f54b7477c16c0942df8f78e60dbc0997c921799840a7e81314c3df96dd91b3d3f3736877e55f822e5249b08e3205c752a8ac940105077d11c8411d30c5cf17398d561b3826627af4af223679b1dab30bb05996ea2c17d722d50b51ea7f8cdb3e342a5ef370de5fd7e108c1babe1b8d854f8bf30673a4620ca54680b787186c106670c6bf318d57f732a6bf7e0445bbe04a3d47ab291fe268d462463a4591cb5b7f7d79854e0b503aea4804c01fe4191befe54d28afe555c525a19aa67b8040b9d3b44cedf592b717d3b5d0a871331f693f5bdfffe4ae84a085b124c08677a62461836963c09b8805d4ee7d4a41e25b6170d696422232bd15b3291a1fad467dc2cd17dffc84b6824539e00c619966bd28516bdc00a0e50b85af166ebb7aa068035d9d538c8a8fbbf1d8887c4e0bb596293bc8cd48a97823c42fe32203788b7072060a823f0c1fa04de3ff2d38add7206146fce13a21071762c1cb7befddb78956d1e796b34929e29d1d9126f4e5b6b6030ab3b2d0d50fe42c3134e746ae4738024fd84220ebfbd647392704dcedfcff00de6608e56112a1d6f53bb1ed448409d515c439800efc9f843602f6aef9efd8ca2a34c33399bd4f843eae1826a436da2f273a248c7f40b82ed57d2b71be93b2936c25a0129518afb62cc62520e3be825349ad7503e55267e1418934dba148e8c694f97e9c2526d45436c096f5565a60974311369d6a417f643c7e18caaebb9a8a9fd48e6cd56ab22d1de192cd0fb5643d5017f9b65352914d154e23b5238d27b4b1589d90716f7c45348bcc260f9a9a77fb6d9c368d1286a0fde7f04e7c4627197980015095245191ca19a1fed78a6a5455493ca0d514e8755ea4a49b9daa084f19b1c43d58f2cbc7b80e6ee6190696af692a19a9e6bf2aac5346454444bb34cdfad253d69a420336e527084b0a0dc280f904596d588a2f0ea082d8b46528f4fc6148d48b6ff5579ab5c45489ecf216a6bafd600178d5f6b368d56ebd0fbddc734f7a0bc39d6a382f4bd83e14f195cb2f664cb559576a45dfcf39370927e107fe163872eb6cbb08d202a5dd4869da35d63c14a9193b905dc415034b077b5710990af148ee57283d3fc7a0dd735e44f5005620e19c3df2e50ae3c63c37cb98c24846471b0c96e8e1dd119b5fa39f3b54a4d1bf1e44331ba7235d34f91ab2e21b3e92c479d59e915fb0d82ed9516da82c92a8a96c0e23185b5ec74dd9241c4dd5e9157b19853cfe2060e28b59fbc231226506e1551ca0de72110be57862414c68fa8e0e6bab7506ccac0e942b59440887783ae092f6973ac1f7a2b5cc31e079355ff1ae292e0425d2925da5b2301b33606e8faff62c58dac72c2a73cb58f9ad5178d2927719e58a4d1ce48bfdf34a34f46377a77223e872fdc8101b41e8e73168ace73a8c36e860e77b03fbdd85444110e279cdcfa3645c22e94214bb6a1da5cbf8ee811f896930f969fd98ff9fa7a1097883cb101344fdeeb77eb0e0184f0497dc9e8d85eaff53fd01e82269250b188ae6a5edaa75c46df2a759c35f86474ddc085bfe3cab4d3e9cdfda19c19be0513ec9d3aa9640dae1a9236cf4382bca3db7ac9689771b22adb2a50dcc31bb75e7e4fbae2f59331b46a8f37dfce3aa1d75a7e5eb88976337c4d45ea5274d939992ebb03e010f3c5429d8d8c8425ebd9e79c177819cf8a4f0dcb1748379af823a9f523b6052b007b25d2074f28779bcee7ae091294b902048a681f094a2836ebe9f342407874ede96b6749502c306de2b568aa31d96742af3ac2e9428d0887968c8ab64303344dfa2365d27ed1f770c4c0f38ee73d50b72e18c17a7eab708dff3243a924194ae08000b23d22e24485c7ccb76c23001f99b07989ead6761445eb324ddf7804d4bb260f047bd7a9159168ce43344288d7c619f5ce453a3ef49cceabb5841628c355e772b62a029811c6030692fbd342285814b6ec1d7ba71de1c9e1037689631a5c92de4df210ec066075b2e0d195cc991ccb4deddbb90b87c717f7404c0c5be14a9b22f1bc6abf762861bec69b8f9cebabea88f1f7afc680e0500c3fc03d295d58f1da150c40812a00ccd006fee45466f78f8ea0304f599b05523fa5dcd9dfe26913d6962b400358f76e45e3bbe96d9634f58f43a616eea96d55a40593b00e9d129fb09f4fbb92b10fadc41a588e4a355b34939fd8a8cc652525d9781e659bf5ddcba45e5d79bab610cc1e7f0b11ef23587f68cd0680a14b8de4437a22ecc50eee41f0110cf2a3f2891e3643cb1ef0302eb6411a610a4f10f341d2ac337640bb0ba8c52acaf8acc0f1975032cd1c714e012fde8e095d4a5d777ce7e9f15a77a6ac69d59cc7fb480b6f304163e28f06ffd20e65505c0d80aee44e24017cb42e6eead4bb03339d37b78f3732557468f4378e50e23a3b17502bef833931ce97a8e0399886b2588dadc826b033d9010d7753e3233993f5ee602aeffc3e2d7580dcc49285d65dbe0e7f4518e0340c21812fb8c093df5f7e77a3ef3566382ba1698a2b0f5b0f8ff38f63c2af3740c20beb99e4d0fecd901a65613c5f997774e180ed8907bdcc0541a00df4d6b408ae6d6f42a7ce7117850b304c2e127bbe65d383f1d5672a11e298f63b5c0ebc4456121ba8f1858a589bc24e4fb03673387037bf095c7d0137a4139603308f512d4328f2616aa0f32d96785ce1930043bb36b00c14cb434f2f05c40e2f0e9a43f5ae494b56b6adb88134a2590289b361c430fb68e52d5b9e5a6f2513e553d3e4425d489b2e5503077b4fdab5fb55008b1392834bc52576b0760ff234b7a068285ab00cf20587cf37212ec93d6b21bad81d0fa153a9e65fd1b679cdd2151d0230431db6428f7659eb1f3c7d3820a04a947ebbf17bffa66b5cb0a423332238c4127182846bcd8a2b8a1ebb0970a421dedad89e4c4f6c930a4c7928f2b9eb57f64355ed73e591e722bf28799a6f9dee723c53e456e91dc63512beb13da115a2ce88bb5738c7dc20cee68f297407764842d7bf7f8ae8e76d51d28327aaff3ee1addb04fb8dbb9ea0d57d8777926a7435a38932a355998942ea9acbd988796a09322c683d4e014edd72944dffd0c301a651b9860ab1ba0feda9b4f25205a612d8d528e478483d902eb203a5d68a82daa40c6a698ca296fdab6d8642ba5d3aab317c11e358d02778b06998e231e38aff39578d1373604b5f73589af245c83876ce76aa51a72afc42e88757cab8aefd1faa5ab450fb570808a358f799b70ce78d57dc990e34dfb7c6aeb99e640ad7266ff0d4d43b62674dda8f4bccda1dbcf315e7f11ea12b25736cf0c8be8dcf007775802c71e008a9963cea76a9324197e087b4c30db2eb6fee9a17e94fe92339dcb8dbe25a61597582d255115cd72c6bf357ad16c6c8c58455b7f77dd2d021d9bc9f74e3e9595ebd4800e6b49bf4d19465c140ee1312e5fa9a4f5cd8914780b7a9eb2a798cab37d49b40a5b66bf6abf260757380c8fb145e923af1a132b740163388260acf7065a8007371a0d35ca9b243cf89638ed4e0b8cd88e7196d7a1c8541f4765672ad514d73cdb7d54ecac87b0613578fb0375f842fa362a517c2164b98f3911bb49d53e621336b5a2460d74f8e05bcdcd9134ac1a43865d47fa6262fc00024c2e9eeb38ad9ab8de20c02e9cd3d0c1b5cdbe1bee6fccb8816ed5658c6fa931955c59665dcf048304331f4848fadf2ca7b20571953fe492bc4a5d115d629674727922d8b58a41e8480065739748af4fd495f2a3049dff317059fc4230f9063d71d1435f666d595a2540ae9030bafc37fb8461ce1c09e3faa72ddc0690c391b2ba135821f1faee8e9caad6aa01e85eb5e258125444a89c29a87a85362756f3f2ded7c9da080975d0db5cb5c4cdd6872ac21cb3ff3816c0a9aa7361056fd4b9c91a2e146bb7477e008b3d7772407b29d941fe49035a5faf61ee9e529968345529884fbafd4f56cff2377f6ddb34ef25aee4663aec938081115c42f5209b6e5f407f95fd3acac96f4d18538bcaca085ef335be5e173a6e3e7a1bad2f5e5ffb9f80272b683a51f7feb754da8937755967f7c7b6773b6d6b30baec06add9dec3663e3f3e8c8bad72bd8dd68562d427109676076585755d8c40cccb41c2f143547ca7a25ce8ab9edb39136e44f4adfe72f0efbd9e8b09e5c1ac7f9721431c7417f9b752ba3acb4bcb68c97bd15000c6ea2ab036c75c19c1b94aef47904889d09e209998dcb31fcfaccc0cd70fa65bf444d33844db766cb37723c4ff9b97df47fab15f7d3bd9e12ba97ec4ea938a43e96b0fd0724543b77ec24d07e02ba1e3c281339d83aeb2d1f81b49430b732425a1a34a57936124b02b1b6fff0144fe1cd55f24af5b1cdad054a9e8e5cec71b59cf3853ce1b4e7c09a39a8f5cd37c40bd7b37ba15e0f77cc900235d7f0fedb3022d01165c360da02bcbcbeb1f11a51c9089334061c85808793b10b6fb43558ae8950efcf768a0fc627815fb526d1d4f7ccce3b0ab2a1789504c4c891bb1729ccdba57e71b4e802b3b1b1a07e61cccb8402450f148e6fb0306965118d818ab9c9591f6471f8f6b0d5446ebc1be6fa93cf7f4883767e35f917efd34d15879da67ad384ffbe688581b9630917130bf367e2ea11278be17e4d0ff9d571563273ebdf32f6fce49f5a90d81fb4ea09c2c93c00b70e1cfca50eed69553d969fffaa5aa4f7f1890c66131a75112d2dfe261078a86a1ea5bb9481ca2be89fa0b624a69626de832289508837071bbd6ffc0bd35bba963e2af92b56c26e6512dff17ed14ee1cc9d4c874787c27d9a61685c8d1de16a9ee11c622a5f68fd08992d884e9f6e71a4155505ab1c1f40ff23f5dd62024096a761ddfce19657d59343ee058cb9f4402d063192349fcae58715275b7e9845ebb1f8235e8ea8bf9b588df80d11c7bf32c372d75bfe794df4c163838b70c66d63dcb87d0563a0d0900846d6675a7d072232c55084ff975099b15c3778e67ced2e9ae47e5b627c9554298e9127523cb712133f3a426f0d930e1ed73eca0fb7079ae3a67897a544b9b61e17f09f0c181c1fc071e43769de81da7b54578a1cb1031886dbdd208b5a143efc3f567e9cfeb1f92a1b3a6fa8e86b89edd4826a749ce627e7eb70e4ef604f969c68bf73fc9ff27a56afd906987eebf445f41f10d91570e629bea839616132a513d6f3a3aaace6605fdbd15ae7e73d04781f98cf8fdf59ee17585f8c310642141ccc8eeb60644e622c42d4fe060d2296a80420ffabc20d2aaa3d59196c3a5f9e3dca5a262ec33d43d44f6dcf8e3f21c3d8e2c9c341aae72d9653280249721f17f77b358e18e75cf4dce86a91c5fb25ff093fd3e56d7ddfc93a9b592d605c67827c16b17d856cb7a3cf8b61c14f685c06309c9b45f6814ca97a3cf5e646d5ccea739a59966cb237b65710fb60a832eb2312c5a1161ed4df2d45ec7a9af4d59a3ab401c641510b4e87df01419d4fa85e85c8038b76a27d6256445cbc898ed95c02709e1e7fe3a230f20dee47084ffc5f9da339b891adc169291c58815e10688ee2aa41d32f2f6954166cbc1aaecb698b7aee4477728042ef686bde902930d82fd8329090b5e0c866200ca8079760bcf293b11eaa0d3f73e110cc60116ba901d0b913ec08576de2ca5573183c3047fbccd51236c337ec05ef756dd708844ea012f317bd74b9f038c1ed81a9102b7da780bd8c435c56b785f9a0bb9e8551486d685fbadaa2ebdae3a480dcd4a47b40c62cbd0353aa736b6097838188a1378cb6bfb4c14c7dc8c1ac9b5a6d7c35a87be74157ba58e6da55e536720f51e7283dd3f438a13e2114ef25bf0122a11635621a66649f279131509caf06127262f3abda44ddb817fefcfb2ff51fdb5391b9d5c8f6dc22c2666b334a674cf383188b4748c8fb22acca656c603ef37ec911a100b99bfb494ec49e475a1ac00085ed9fc8274caca2f19747e77450610b687ef696c3bd4516e0ec2c969a1924686d1ccbacb9ab67956d239e8995d20ae4377d597377133779b16537715ca69cb52461caadb80b7c1d834f9247467dae15e108ec8ce58e0efb0709b0bd7241e2dfd4177006aa9f13491473115208b14145de1664229eddb98d729ea19b582fc559db16a287932c248d214b7328ff64b66a91cf95e3e577b3f4c4f78095b01b396b0cd9e557f4df3f2d271e582f8a6450fa58619a690f3539971727973f3b6c4f466d021ea045a15a9d415dbe5ed17740d7f7f2375cb2a04a421b3c64bd00154ae5e1b7044cafdc8cf7f73a3317b3538995809159490751e436ef6019e3b4dbd98b5b33474607bbff5473dc8f508fd9fa3f7268f893c62c7e04a46fc886c4e9dd59cf00dc873f3367cfd8dc49a42b1c6ae64bd4cea0161d4073a467cc11b6b54b9ccd01082bac75a9039eb31bb99755ce8f3feaecffce4db577bd1d7cf0befc2d5060847ff354b29151f7fd9e8969d34cd70a054c2bf5a528d4d17efcdccd4f5281cc49c5b7474df71db4ee50f043d62b052cb5a66be3e073996ab8d8ae449dbf670d57fa2d5257800f8dc2598b6923a9269e4d27d0f5effd958ae7af2f7240e2bc1d719031b6027fd67a1d034872dbeaf309654e6da4d3b3b0b27b00b65eae35e9404c02de8246e8861fb65a52eb5cdcdab362c427157c7d5671654705410a3f74d278e24d265c9bdb78223f1e3ea657aab555afaf29c319602e9d659600aa7c939fd0856a819c8c191459d260ed39bd67b89cf7d95ff48a2a02edee9f9c0a9746c053ec4d72c7b25f9f48594df31cc42fa617f71edbfcede9513d4d1dc7bf5fe8a97c7d9f0c5e7f83cd0b16c1d6753e00d03492fecc02d1a80aee9a5ccb3c0b62531263b461a048d9436fbec1ce79d3c320d21556e676414ad9179e4871884aca60396c2cd4c8a6da3db9d7aa04b4d5b21a856b5629d9112609881eb4e0110cf6557133cb470f27c55a19d99269d150e8d23aef13b83c30f171b902fb39380516cc0b8785a00cac5100472366c2fbdc16705e1a5d6e8b4b9b516b7dbb6983b393ff5c9f71603f929be7604e9d87a89da0e3de78bcfc0b44753a311667a96ea10f71924d3395f61dda62a4748615cbf8a7ca9f1b77e5d36a03a5637c0c37ffd08e5af1a744aa1280ac9c6113259d3605579bfdc88ca4fb7f2480a0104d274d253b55a7bbdabc25cb22d8c0113b909e7c631840576b21f9ba092d3c6e9bc99eb95a6d9f19c14e51da945773be3535d2bcddbb166b1d8ee3b1d6a72eb5a14efdfbe97f30f0223cf563de385101544801386d19a14e08b4d805d6af6a9bb3ac5ef0e51802328b741650204922aa31e7155a7a37fd898ee2cd701f56f4cc94945de08bd0c9d3c12703c5af03738baf4c52e9a7fa4470ebfb9ccacc0a6d82b266b4b486f0f8d33571a7039cf7af324a224ab41e4b06510f1be9eacb4c3bb4367076e82239e8b96203133b5641e408ffc15d42e333b876870dbe74606de96bf3a3d94b7ecf032bcd240dbfe0cade1c18ea87747368338718b430e47172cda86d921492a4fbac3764e009bae23ebd0a3ec493f0cc372e96903f41b3f92728f2012994fff7c47fed3f4c46a2574e178822cdfc8e5e62deac1e19ecffb3aaa7045507f02bc95e4107bc5414a5562926374a2561a705dbe017b0a3ed4c9a69acc32768a85b4c9c3166a522538736fdc391494cc4c85d2ec56213cac0f9506861d3bd6f297973579be719cdcec47762ba7cc0c8de6ef97c232dd2e58526e49ecc10243bfc535dd47e53f4140368d12b317ce24e646d0ffe6e281bd48dfb192e7d086cdc18656d38a8c4690e08303ff02f8fd231b9855b0b5571cc46aed77c5c1927d93a387bcd8edfbb91b486f3af4db423802b8a01afd12e657d52c620db05243e1dcd26d9cff4930507a127f6e930e78cfead504ff203a50d3eea66403678a05a769379aecdabb5d6d657be7a9b51a32a1d1e953d41fc4ee6f18cf24b0add7091232e073d0612025099d792f910f449af750d49aec6c8556a8a9b59b8e9739dc6d12be69ddd9575d33f7c9868f0b62bf04852bd3a9b24bf3ade9219120c8d7eadc1836b4d0e653e0cb97f376d943c771cdf422cfd17816fa991b599eb35fe419bb2e4fade2209bf80e17fc7faaf1122d75882e9e3cddfa174938a2c8ab345e0817b9070cc4293288ad8c90f51f422155c59d994335cb4ae1da81a43b9307ff01f6035ed6003e9005b55e2a1665e3970d9c9b2cd38c837e1086f06f9054402110a4d3765c64190c587738157dd484e0f40714a146ae5dba4b42a17819f72c48e4f7c6f27b9025d262f1434cbf85fb9e3773011d2fa1aae6dfbd6da49c6d3085b2cf99758b1f3ee71a2cfc7f82a6038f50d72be011dd42bf1147f16d7a62a88052a41c44adb29ac350d772d62fd2f216a5a9d17f9e8deb7ee5d49c8b1846c5205b2d49e5543ae95c75d8e89d5440b60a6407feca50ecf5d3286d9c985e74d15b1f0a1aaaa0433e16aec167be0d716f2e4ad771523b1955d2d0dd72ac5f53e1bba69c96634ba580323d2776e4d914bb54e6471860d181b28d38f8f51ea1d628f5ce8afca07216b1dbc2c18db8d802588962ca2c0841704a151b5603b84202f0cc971bc44284ec5cc7d8d7dfda9e06cb5661e7e3c2a0b4e96420456ffb8707287d09b946baa4b6ec784a33e6eaa2c616b348ef3be99f20915b2203df8f17f992d4d0d5088415d0a9452c803108604e8600a54a99ec2f43e8f3eccef5da361a5285651875070a90e177241cf48f9aeed19c36008e83be3ac26243177622e7827bbf1242aed7bbaa171660b0450dfab8e96daa4d3e1e24bc84f026fa9a0565c24b263259608f79d73ba4a52d40a5f612ab0b7e45888b56e54f1b022b09b64852d68f0f29820761ebf7566ca9a58c58db1746bfcd359e480c554c83c65be0cd1ddafbf24c91620aef87f84cb752afec9d198b66e203713f9635b84efda74183c04a40eff5e8ccbe09210f915a7d28fea72ea1bcd45040af6d0baca8388b7c25e68760c0394c4a2fedd4701209765958f032e892483861c7e783265f96be4d3e0f0e81ba84efba422a53be0b90db618f08a89be2e4531b15f5c7ad041b1edfd410322b36571333760764bd8f16f9e6b1069cfbb67f6cd8dcfe412b35d12039a1ba9a96f3864bdb784ee072ceeafb8ae11d32abb9126e12487c359e50b77c6847c30eac36210acc12e2697747a658596e88ad8954a11f343968db8c9a4789fb074b00ed0583c5c9c9cdf3050653eabb4cce14130e99f880c162edaaf6595c348838ed05a401adbbf3c7d3ff6a536c0e3b60bce924156572593ada8ec1eeb2836bf8fef7664bf5bf46d9d44c83555a7bbd182a396415a1348317267eba91c864e43d7ac1b8fd39d4dba20a3d8e667da1f72414963c820911cb9ca438f62225f60ed1a4780596b59dfb5237355c31462f59f54c498f390f3ca953fec632f05b821f157266f422974f7931faccd9eab1d815d9129e92b6f7eeccf2840e93d6d876eee857f362d81539fd045f4ae693a901a165105e914fedc5d9c0dcdd80df4f27dd4864cf8c190b9b09025596a6e1b6180a3d5f5b0b9be15f83db4d7c722b6f005500bc8366143fcd5a5d2905c63ed2d25ac5178a65ffbeceff00ddd9c683967ffb0d0b8167ab0958fe51432b10da3c18112d6b0b4aa5580eda9050b228a77c22bcbcdde97fc467d2fed7a60eb9114feb419eb0db215c8d9a0e83d1aeae7de4e6117209fdcd66024c458788287032c18de2e4cbe0cec144ad663fcd50138e2bf7b84b9a0b6053ae5bd8c4524f01e18445b54a5d52013fab9151de0fabf4a2c24db3345c59b1bd717fe4834f081844bcf45345dd753a683e826884c85e2b32adbfd81c9cc1c519ba49e3d5ed577a82cfe8f53338266ad6992d86fb2f2400cfb1cb0b9dc44d302d547e00c985218b5dcb62ad290ab8b3d1304c4856afaf8f3d386d8824edabde2de96b389d3216a0dd976732e1ed69cd38a070f3d29f53b8aa5189c3ee5c5f0160b9cd80cd9f3f906bc01ce901b4d62b1be6a8bd26d1f72fff4106b4a38b2d5ac0043a60e0c3a9a62c5449ea781950fee6d5e263df3b3763fdd3daa994cdc88a033b9dba88e349a0c267e1614bb5be2f02d5aed5029d9468fdb8f7307b77553a4b72132ac521343b89d18fe80ef3718d50c89425f13e2c0136831b87d8e9774c5ff26858c0b7d2fbc8a8a1ea4419f63da4696124d5f5922a2723b8887281a85c81d45d8bf7fe74fc2a1f71c47cb8db3a24599b1d8062152fdc68362e0b9f39c707c449e855da0e07d1bfc58dad16a473bbb6216f39d449dda557f704d3f91f1243b0406abbdd7369f7704c67e6f36fb57997a1065a5f2affec1c9c5e46a62a7e35c5e8e362beee2c14723a76ff22e2802dabbe977cf7c171295143e3a0206408801a197bafb81e15a00dcde82c8efd3f5aa2ac87b6924d2bd4483bacc6f1011ad2cf6ae471ce610289d897b63122a41f7140ecbfb225e709d082154e868a6fdc35ca0bf4f987d35da0fe77f4f3458092d25eeac78d1622b6d6866e6d9ed69b10f8dff0a97a5dfca51251fc9afa8f7184ecf8630a59375c6d1a9276721c18227868bd56514612d87c711a25496e45511124fcf7c4e6a007e1f510b2667d8811b7e01dc71ee5c25225736e0dfe49ecdae6276f27611f78d0923d196269c4ddf8c545aa6a6821b2f127fa2fffc1b381c310063c7c57f8af30a862c5a3c297fd99b90e6ea5ec6d5764dc50e1bc88d5f5c37a84b8d278133ef321cbb6fc753c288ab6bc569ebac0286571ba7084fb1afc39ce9c5ff1d04bf06e7e96e753d6fa74a264ebbc89b11c1572a6039a10703fed1484a7373f78a6af7016bc4b762c98797b5be9c9e0a641e6739ec0ae3a2310d5943871933534a318ddfa0879d5780a57b07b73fe282b8b4a5669f0ab2d787d4008bcbb101f07dde539706478ab2aa91d8e04a90b51cc90d14cf9370d5fe1a3701ed23d266c6c36c863a2b48eaa5c21a6c3d2b44ad81ea137cf8aac969998525f5288a53a59896f76c6d8a8b6d67d8c896b3f6fef751c2ce0b99952d65d73682817d94f8cf69b7b4f30d5e6d05cbb028f427f134b52b2de1920c0b6162fb3f08230943d085d51f70151a751becda72688ad86560c52a4def20f4739c9b6a71755e21a7adf94f37c944206bc7b88405245a2b9d5f88c1034895b5d4b3cc3f286fb283b31e8bb17bb92791d70b01b4f1b83f5f630d57dc554805141d68999f40d3f11f075423c0b1bee4e0915ab93116852371082b2d7b87e242851adb104a50690f0b8f9016e388586657bfdbbc18aaf302ecc9d1f60997cc2f3b1c317047ae9ecf9bd67121a082e6c849528cf9d124ca88bb0aceb04a5e701bff46d41d80acf3839d2b74092536ab7a0bffd31cce117a1dd5cf9d2984a9e583b2899b590cb94d9ad1d04cb37d4bb1e7254eb5324019bcae8b15ea898b37aea5c7a78217090a2f7820e3f91db99245257b2e8a72d3246d3badbb0ce4ac5c88e066c5b2adabbe06e030133176027ca3053e4b0e6c467a126577b3ec416ff34ef2678b5877ce5d05a3b66aef338e172ce90ac7896fd7e36dfd4700476128349aef1501b1fe402e626dfd71933ed8ad9cce09fcf54cf2615bc709f21eb3efdb08e59d77bc6dd928f2e29f8c3ed396462a211bbc8e4ada8dbb842484a972e8fd585efece48726ed8e90389d4a3694fd693ea413b1ffaa4d3671595d3857bb72b71a00a379928716107c2e606a0037d4d91148b363afab3fc57b19f1aa0158e80e76ee0269750ebe5d3b39a6f6c6555728f49c411b81be6c71b1551bea3d02e2b590cfcc4814a796f0b829b3108c1a5fcca6ce21b4877cb7fccdea272e6c98751fb1583e251452f3703ae2afb328036959c7255ca6a54b1f6165b2464854a00ad726a9b8062f0ee007ae7ee952cb589bb77a9419dea1cf1c39e1e099959844de9782d32bc55e53d5e52a80d6aaa2de83a09dad1e0bc02fa3651fabc709dd72d05959a3d9db5f6f7aa233350bc6765d8b3c9922d85176cec61939518e3b1553a68c5a5179a8412ec1d75bfdfdb6ac85470446f26408bd0c3fa6eefd9acec53aca19bc329366dcbec0f2e9f277d4c096d4178d15920f615d4e4802bb2cf345456d0460666c3cf777635c3a8d2c75f43362b42c09db143ec1e5ed2d965062673d1ab88df52731c4dc60767533f7f8807badbec303e3d14c74fbec77895a622f774d0e1241c1c9c49954147223aeda1f6f98135220134df6b62281284a75fc43a89d5944fb2c08a0b36283c4c33b204bc945259591dc80f81bbdb5384c0b18e364a05371fbb6b2af26a7e8e21ccc20c13ef9821b976450a848745f1df263a2aa009680af028dc4f1d84b46b137e88e44e0aabfedb2550e913769d98c847ee055bb5c96d90adba65d1230488c34654d26b40bf91a4e5a68756dc6f72810ef16e5b4f51f46d1a1673b9d27ae5568ec2e400a376d09a967fd35e87a6fa47fdfea98bc0b88c880e91966cb7b5d70ae8d3979aa671e2b41e5004be4b01ca1a7b23919f2661ed4793ee46fcf1a5e9de835a497352267fcb66ac4788d4bf2b3616c176f1356e77132616ce27f384fb20672136bad3de07bb53bccea21c6f630df04603e9eadb737ee99e0d010d19ee692877cb612aad4fd2e8bd1cf425d2c0100dc3518d5ce7762b217f73c51e58b8cc75522d4d5d231ce7842e67b9e1a059f9606300215ebb666eb42d530974c5fa778e218e5c35e2e3ab1acda855678000bae90dcca4507426a6bed473969bc4df7891c996bacd78b7b232dd2c7ed0536a07e2e093fb5df76afe1e73f3625df085cce5d1eb7b6f2deacd32ef35f81591dc30a8746844188a1c61d624eba788896d519430187336faa2090a6342c79c9ee59b025952b6cb367e33898b552257aed09de6f452ae13b0d199e96a57ab72322c7a33ff068c39627b368804287bcb97b22e4bc1c8cd2d502d195c6165cbd177d2cdfc6f525a9d2954c40f40cec64742c11603ad97d12ba9bfcc13ee1a252f4f3eb16f67dfbad16e8333101e38f25f71ca6dd38c6561f72150b5821f55b54708c4037c49bc451eb6ed812a25e22f5efe9cec3b5824d4bae2540df852a8ce080ac2a630a4d4d43d231c5b0b64b1772899a3a4a3a4350e633a64f4cc2b8b4681558f5c461feb3171bd2fdd820284645fe66af1ff0242d6aa90ee9ccdf87dc0818fc90fb66dac098d6378c67d214c220c77a629c3f0f7cca58393d15c34be4ad4e0adce8a493f5fd6af38497565c4d6444359b2f966466563da4e61b1bdcf8f7a45bf251af3bd9581b1570fdc8308a277f43ecea660e77e640c724805850f167f056a8eeca83d528cb6e83409b697ec6ae07d1b973bf0a70dec56b3647d1629e5095e9dcbfd7f446e51a01d1bf8c512a956953a25b8a40bb79d2afdcc7980fc2a58f76808516994f9a09b4d0193fc67107154667a6be17ab1043767113c114d72ec850fed39271d64d5215cd7d1e2a470d8d4129bf456cc94521bfb8b7bfdd5729f4de12a79788e5a0fe2a774ee0992e227fe5d6659712cb68c3682ff30e67cc73b7b683e10e3865e77cf080cfda173c270234a7e99a63ffbb2231f87c8798a817669e5f104ce256f67f3090ea457a53e7f08b9179584a814dae2634188177f555a86c7cc490c74ffdd05825408dd98ae592f44fdca09965b6383d94f299c1733d1f858d21c663806b529a418019a033c982bfa1a0518d860efe9fcb4bce16e4b838822487459d2348b4fc623a3bf4beea3c8c14bb1b4a20f0365e73f27b7bff3688c76128d680bbbbbf1422759ceeb05c00786fa5840226382f6b629bd97f40027df8cf87a86c1f6d8a638e63ef105534373c631e92c79f6992c96c9eb536934f1f6a7855fbcc6cee55c238f38985ba3953f3ab602e8043df7c87f1b43e332a6f54ef6722c4e75abdc5ffe4847be83a574e352ed457a87d44a585c05962eb4975cea3598a904f4750becf8bc06f13327076dcb5598ec04c331339eba6fbd7877558cc9c95518ae6073ee5083dbbb25a4cb35b084fafb33933712f1b4f9a62b93eafbc7ee3f587c772ff6a73227551c186c2c2542edcba9354de1587352d31cdc1ddfec8c5ad0b1554425005ed03675184019b65c5df4d20df63501461569febf578ef17bb526f1662ae272104a3064aa159eadd65c421885e2da6e8563d6a0b59275f85d3526b6a0a964017d3e842a7f15ee2c463a8befaf79a87970f7b3ce377db0d99d75befb4b979e826d45f3f0db87a49a24c83492c6f4b64c4fdaba05c251b6cb74bb6d5fcdaa6e92a38324b95b4fd6818e401ebe01f284f707c84da0e5670afab960d130f0a830d7b0c89b15f3f4b26f71319933a8d6a31704514f64cb016db409057e1c963172da3f9d3ac4d43f523bee2a8d484daa79ea143d25a021fed4cc0ab69e96510ed4f505c5500bdd9c2cdbdf4bfa9a840889583a71f7bfaabb5f783f3cd0a36b0600473bb00584670e510516375d45eb255da55e96f735aa7f8936aaf41df0a22cc0428bb52a4534665cb720c4aa3098cb5f6535fe976ea8194e7cc36a361417496c0c9c168b54ae4dc48a9148acb0a0a4d5c453aca66378882858b3333457da2223fba8ca8dbc4f3dc9d205c3255b45cba3d7c3342d0b877f418b63f9968f5f39229f35abab7e1dc9cdd1c39d4c94a17aed871fc532612bbece0a3d512d114e99edf8452c20ff84ac7ac3cd6c962e71b73d2eb461e9a9ceaa700fd8ca0eeb8387a5fab46ace75435afed817ac0f0e15e4853fe3cf374de5e60f6bf214c4a751edf6615a4f2bd2fea18fffcf898ae5743b64dd33ab","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

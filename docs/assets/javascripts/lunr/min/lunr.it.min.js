<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8f81ab1c20181dce49d9821a6ac797d5b09da474c5fb790028f569c74823215784b580f27507387be18dcdbbdc59be90099bc319720465b824e58a4ee83632f3ae2f6d0931aa462ee01cce2ee98f543452207be1b9ab150ae68646bd05262b8fdce637e909546e908f5ce38b101342bc0db251e1cbf6a7ab1cdbea0ea85ddccf2bb937cf898f73bb3d605c44b7dc6a9074e6510e91a221d0e2ba492c193f05eeeb9cbc253cbbf0af3bcc11e6b172458b46f3af9c963d19ddb8f47eefd7c78f67da8fc1e7b3080c40896ddf6e38c00921666fc76d4f763d7ed9ffb5cf61978dbcc2efce0b676ff4a290825c27f541dd18768c664bdbc95fc1665931d737f3306d867f8579fe89e45c860a973a3cbe6967b212697482893f20b4b8df4ff1f5e602c51da32ec92abfa8c04fec54daf66460faa989f8e427a0e6906c20eb24bb5a04c65984d905c37629f1329a907b968815ffeaea4a6e8b0cdc535df7a2954c71b572d6310fe26ecceb7a6e8d53545c3ea423518e3ec9b7738c9483a3eca3e4bfc80a7fe981b40a44adf02f1b38560591c6b29244c14b26f7bcc032de7f39c2ff6a330562cebf2886b76b6a8678f7968f565eabae7090e4209f1d003dfbea74d9dcc1be745e4ce9e41389e2b7e40ddd1b04a19fd30aee399a539a13098164e47c579e341c89aca1ddcfbd68263760cc021b134043d1bb5b51b55a3292a18703e48bac9af73a40e88a5ebc19801e810e82c48b4ceb64fe3baa3fb8b40390067740fe711d92231cf62ba13942df35c24752638fb857b27a45fc8358b47aac965e3f97e2c63192832c9727dda36808f6ff91727e7aac7582f1ad94f2ec2f5f6526ee50c05ba02818ac3a9092fff0e906c1e010b509bc8dcbc37bf953ed2505024749db2a6bf0b6402e1f7f4ea6e99e57b8c1244ac0d61a1b7de2a0ba722834571add677161462a28888200315777a49bf13e2fb0a75512308254bd327600d6df208f38fb33ebefc9fc00d5770935e0be1d9422e4cf6563c80767a2e11f64b478d417c6bdfd6cb020f2c54894dde0b7a6459f7ee7fe0124a6b79812b36715d51afa2a0c6e76d20aeca054db38d2dd6ce73c357535852f79c2d249d4568f977f6036163221263ab698487c22d8345be69de173d915b63ec6d2490faa7a513df7f0617636e3d74c3cdc37c1937d470d9a3523fdc3da5a5cb11fae2d83100c528c1ccd54f41804dc2382eab1222be759035051f52b215de14d0cc9cffa1fc229b61d89f841a54171b5ecfb6b5006e1c343cf0080daaf9ec99247bb7f6f18205470c058ac6e92f32e8fe86d6c773f4e4b23d6984b891ccdf3c985fb5aa149d6f910c9ee616de9c5717c10d6a0314bcb3c20a4d222da57adae711b02620a3f7cb993c87132768f0018a85479e9e0998fea3dcf94f95eb21e39fee2707a7f8093fc3a51cb308c2985b70c4dc6e7782b201b506df3cce0052093cbb70c45f35ff8da440c4f82fbe070aba1c412d04261a7a9deaa67f844b35aa12814406d3a5f70355f7f26dd43ba5b75917df1cb8c11973f632d4dbea7486cbeaf0f712069a6654d331d1cb9c5bea6f5ed1be8080c9ae3b7414f6b945067789e0d13c51e343f442e1c8c57cf7bac47aec0dc67eb064a19ae59947eb7377d930bea349ca921abfdc65c95abe2dac3508c753c27513cd84428c9a0071f39480dad1c01b2663a1679287c6dc3db9251c940cb96ffe3e60190ae18d1c49c5726a403e826515ed51446f4b2590bc2fa518f1c68d75f2fb1127adef654e753939428ec3da8ec240269b141520dd47d9a965075088ea3926bdc8a73db6d279ce814260f6fc204b4d92aacd0e8d28f4454faaeadc4be659000b70e61d1692eccd29399ab3811f8965348b38f5bcb9db557d25075fc6f066ca2dee03b8dd34174e3c415e626e75140b86e2f5ec929070b5cfae792cdb57af0c27dc5ef48a135cc7790625b35238d98d9e506efc5436b9ace1f03eb458dfd2eabccc4bf09c4754608105fc370c15463b48c2449a650d488f5a582ba8f98ad20a4fdb58299790ebd857eb3a71933ce3a5d1f3c7e892bd7f1c67bd796bb3414c873fcaf27dd7952150f107476364884d033eaf5e75b4205475db517d3c85b2aeaa903363cae1c6263b03b69dbc8f450558be953c71a2011fb0e943c774fdf7343b74e07b8bfff7767cc4beab943bf3d98ced88d1acf9043bd6e7a54e1402935eecd2cec546a74cdde451dec1d4c25d8f6d47dfb5f39b7c4fee15a286541cc1e4242e6447228995d10d0c61d3805566612abdaec96dece5b0958ee332f779edd7a78b98437af393a4be6532f2f4409ee88173f155f1b2103a94b9bc6f2cd2f374cf33f270f78882011da5f9d2109f197e772ce284ceaa85491dbb53d446e651ddb87f6e06acc6e056a044008d8404021cad90b4f5422c13ea48020e25e3405ae3e7318577f2beae3f75e3589f5e82a945bbfc74256791daa0e296651b4bb250537d2c11ac0f21d0fd0ffa05a1564359e881e3ad75783d83c84ed33b04b69323afd34baaa613ead174369e98cba94c7bf5cc3000c00913b50b1cb364047b597cdb9c087d8aa0a66fe1ff8e842044070036b194e509dc25ac1b2145262ed6ddcfa8b8903b586ab921561ad3779d9c5c51e0895a2360560593da2e960147b87b914f4e1d0afda2452b500dabf507953b7e9d36824345624e8cc03419ca1137734e437a003d9ff90035f90d3be5c1be0f426885c76495175e6347ddfb49262e4b613a57c7aa3e53054b4afbe98f9134b6e47c8e0a4f82f1f515ad6435fee5f8642804968075c23bf6f11430d9ad032e165567c2979b4971fd61cdba9131f9af9e768a4c9c90ecb62542db5b1ef76d694dfdbf59b81c7308daee2245cfa98b9639eba80ca2d4de9395ef2dd8ec9dd93ccb2c3ef0686f20144aa2ff46dd8ebc6dcc2d24cfa97c3fec5f3f37b079acc3e9c33619985713b94e393e173d405f8dcc04e5f7fd203cea6beefbc409b3b2d9bdaa67c68d26d5c567972b5c3b907befa502719f2dc296fe1a2f650c05ee66faef6c80b083abe4f995601418aae5e340dcfe8ee5efac7f1fa87230ba2c3e69ceb1730bc5f60f8bb9201474cd4ca9d2c7a1273f9e603425a5e46da27124beb86c60a13d40f261daa7303a3a50be729dee0cc4c3d48b56a311477f7346b9d7a5fab12886bf6e9542a1ca7fae4bd4aff362a16533a02fafbcabdb91306541b51241168082ad0528988d3d3db54786bf3899da439383a4df14f1299d7e99b2004f85b9ca9595adbfb77b800335a7eb9d6b8253d9d7787b8929366f325dd83d57a8d25c0c59f079103271014ec4524a2110d9a45617aa2ba2b449b0385f630e3fca174c236ff746af5dda4fe0f1d7bbbe7bbc4d06426812281aa220a67ec74e46c463b11693d5cca23e179cb2a6d57331103ec0e9a0f09ee3c4afde9469dabfca4146165e649dc30ddab9c02bded01f1a644a9f5619660e064f8b8323fdb264a64216d1710cb47bdb6d0828fa2f6e3236f6e37798fd4840f3de74883d51df19958355d926402075411cea43d05706e5ab632fb8783f3829e346708fa6d28003b4ca5ab4fc692bda3c6c3b937fbeadc20a01ab69f5e1dfed15fc6ccfb6a52dd2bb9c875ddf8a186d76cdd92a5f13520320bd8822b6d7df17b32ba0e7f57ae040fd96a1f04588a852fd64ddd7a2e99ebbd182b817135e7dc5839d8aa1104ccedade7a06c49b9e42b1469514dc3d78787959bbb3511582c178a1696cdacae67e38c3a9d9c4ccd11d757a181baabfa9636b7fdb3b978dc362a2b20751709eb56d6da8ef458580ae2afc6c1279edbc1631caeabd7250261f7f5f36ca9f3960bb00d37d789dc4f29709b7444440d74af0bf007d6afb7bffc9531ba9d3a497c64fe4dcc46120c56ae45d343beea939883fd23f128d81e9ffb4596144abf9a1376c6ed38aa4835f267c51c17d1f2a5330a5fa52a1e20c9f838219d985133fb56b207ac92877dce12a07f742793516b5127f014519b2c23d893dfe3e80cd15a8099ab9a7cddb8180dab01caf43e9305b656f3a29c7ab5b1674b822878c380715a44519b7869991ed80bd25d4d114d304b69b919785281f296ae057d5ab49ca277c42378e14998bddeb030a045562c436579eb0301eadf91ff4a31167fef406d9e1d75779e9ef4374eabebec7fe3bb369c0ee34cc430448dfc5c10025667beff739bdb459e8ca2b3a309b6f739f0d8324238a515e761e18a58311009c2e8985e113ee9fc5213653892d342c0a9343aa629465225a247a89ed6bf41bdcb7a5af57f8fcd303ae6b62099c8ee3ea62cf0a4d333cbd72e88e7811e3e54b59fda9db7f405ebed8d699abe8584c627dafc24a5986eca75fb6948ec4753fb6a0c5558189752fbc644f1053666adca06ca534d3abbda6cd1d1bf73ed24461715bd3889c114779272f41fb7ce2649b3c647ad0a119c984b97e1dc9196bc5ca72599233ba056fda2ff7e42d0acf5af2c8c1f0121a17af340a6565a984aea414e6e78da88b3327c9f3fc21f7e316075da5031cdfcba89d20005704e4b6891590407f7f0a0bae72245cbf39ae8708a643a6f304a3be104626e6512a48d3e93d865c1e34d9af622e48f532ea0135d721b44c35667a6d0adbc651742f7c4062fd0b8c572c9c566fcf556a906596030f93c3707c873a4c46062954de690bac1ad45a8540f9febcf7a709b9f2e0e91a4a66deaa62adb3943f4650fa55f09f9a9e9e6f1d3d0ca863930f4ec85c92d176e84cd5fbaa40df40993db62abf6cfc93bd768c1d9f641d820641d615cb90a086ba2cbb6b9fa204d5a861788331a37aa01a9cac9033e1b5df0bcefcdf378fdb29bd6c2eece7496d8d7932b7dc6ea85c59189ce2c57042ed868d23d4453049ed554dfac12354094deb2b07e0f6eae1edde1753bf8bd5ff1ca32b309e7572b7faf1a40856706d0abf9d97a9f9a294635342c2416f40f3806dd51321e96869a61f0b2857422acb5f46cfafb10960ecd68753e76c994189335390c0c7ab257d686486c4555df41409873b3009731c5ddec1696a364e16cbad550f6d18a2d3b5ec9ca33818dc447a0ebfe1e929b25fdf019934e764d7a4a205dcb057ea568830782ab8f541001aea4024476e3277833667d2af85faddde004e41518fc6015c0e93115d21f4270964e8ba2b5f79352a8be5aefde320d6a0c4c50fa8afa42075ca2d9fe8f829ce27f7f540350c9cbb3003a8c4bab93a183e314d67cfe618dcf4e17e7270f3ebc25944b8fa5d010e4a26966be0eea5ee9675703363400222ae75b9ed35dbde2604cbce723129a701cd3b4760b5aa5e25f1c8b1bec65c9c329b958e892f441b9488cb674548f5623a27f2a7d89a504b911fa5310fc45a838beb381a2f05d83cd7de4f82b266d3b9d31b44963f98fc5e14375eea1cf3e30188d77d4edae172972e807641d75a1b387e0b146dfa50d7946203721402111a9745f6c176721f27c47f4cc15f68d6cc813c59066060a446ca7d5977fd8c6e062a8747df716a9f1518b0380efaf9cf580367e4d46ab2e819048b3ed0f6f37d252ce0b8a93732927ea856d3671c2b5da8b6734a328c19a5c70db4579dff2281ebea6557de970322b464cc8a85891658cb0dc682446ea6f372ffaf2b1081a00ca093675de194779f8e5103846055b50bcf6484fd916a7293314113cda780c750986f9985f3c6569940bb6e8b708b9189a8d256ac3a9582af73c1329ca58502bdb53eeb3488324c57798668d78c523877e879e97212b74403496e79324e2f412dbee3d1bb9fa19cdbd2e6859939dc35241e74d22671620196d56cfbc5f59a3aafd5c991accf3439bbd46d33df5819138199a1f2111640ab9957194654c5768e9fa263c2048627b0900e8abd0bd637ae4efe62b78d95a4c8d4edc8d8be0ec5bfd7fa737e42535ac64f978ff0583c25d0195affc08204e3bf1109552caaad79d7f13488ebba916318f044fc63cb4bc43536d3f6220a59a54631c0b2fece2fc9a2e628a99168f74b248e37e7db675cc6aa8612a2b64b21bd2e7efceb75ecf6babd02b5329ad9259847a6189a3e8f68add71641b1ee3412817e34a02e3a71ae8aace9d3cbae8f06b2eb5b1940b94dfc7094874444b0be1ab06907d0e2fc9d1859b7db81c837cd2b067435a5e3f1c0b5ffa3fd4e299a2fac2103093b747ff7cfa3c7307505b931f7cd1c59292a1c9722f7609bbf3a47f23effacfe7d3b5da43f1c1078bd1acd8b61261cfb8f691603ed573277fbfade5992ac8c280b0a79204380f2738202611a644308ec31e0e307af5f6a588169d60e47db7e6c56cca77407e01b24ea63d7d6dcaa2059f5b08fd38785f511ed6c36b490f9b5c28de06560ad7ab3f300bbcee2a923a637f2eefe11e737da09875488c9a56cf53bfada120cac16c46a24fe620a381c763c5fff66405595d712bcdbd88ff0a0dbe6741c86887a371466c79264d88f2f40bf9cdaf36cb470807c476dcffbf2d332036f23f297192df8c56c307f35553aa7f6dbbddc3327df49fd47d6e101afa698bfd145fe9fcffa6ff1ce7cca82364026965ec1d78584f4107ee2a28eee239b76881e1dd9c5b15f9e7fe9247759e999b4927d8a70d473960e21d8bd62180261df45cccd50333ad7fe9c5041fb0abb9cbcb95c020167934bdd64307ec30817ee249c549a01201f6cb7e554e2c590b3b543e49c6ffe555ae093553e6b47da6551f6aab24d9665b17c53de6d73e60edca856209f1cd1fcd0ff1a98ac0771a3feab6b70bbc151b2e6f84b14c1122f295119fac46f4470a109c4200258799ab3c82cd87348a1e29673fdc53227962ef824260438b9bfbbefccdd585a0b210b0f114a80cf029db72568fe09f01aae680225b967cbacd450ae84205d638b58d14cc1528dfee83e6f9e16cc7cf032968aca9487b3389119df8e98f5f5bf3a8c5d2c0f58e4785d55081068c61db5c1f044f9dea5153bbfa79ed6b24b918309b747f96df91a4229529e6db42b8e1c5e3dbcbc0710ce6910840c6a17d9d45de872bd40e31079ed625a31def516b500e7b360b77782f6e5479efc5a69714a3202d7d55dc5c928d7466254dc85eabc84c5e327abf7a432a85ea38b106270b1545257c41c05a3517564e6abc1ccbe68188efdb8904f97054b425d52de8dfdfda27b3d7227e420863d295bb4f916e566fceebd3f1b876a1707f7be68ac01330e2de1bbb40463191bdf37f4ae47fb76ce829b840aa1510b9202be86949a334f7cf1e301d2ff34dc13d77f3f117755427d0e5672052303516dea209cc15a494ea6c14416845266e9e95b157fa1c8867e340bbe02def8f7075940d684b55c49de5bd545c2a38b9cd194805fbc5c27489c4d9bc238cc699c334e316b5b2d00746e106deb241ecc697058822d1011a0fcb143d8f0a0021d11a608ad91f3e13dc1da68018bc195c3638bba5695961c5557f5a1bf4d11b65097fa131c51857c8498e8daabc29272c783b3a325380079d07448c4323b78162a272533bfd82ff5cab93204c782327bbb2c4a79408894809c19a1c6c33a2fa120870fcc941ffd2e884b469ae83c9309f436b3bd9e40781869e09ad69dcea4e234a8d19d24c5ec6bad5357604f876a97424dc05c82a267dfba981cde1d7b1c4a738181bf9f83e72305584cc1322cbc066a7f01ec120a76d17295103ea5a780b7fac8b95812bcb51d8a1a9c392bdd4c93de5d5e1c5ff272628bf73251e119ae8145b18a9a13b3b26f58a767607b2ef78d3ec941f0e6aafa3b977bd9c42caf0ce28c48083bea4a261228610ac097af97ae15880939f75c1afa3942da52112474337ba68c0ab84b4220334c58f9df6df2d43fbdff2dd92241d3e17b6f967350c2ceada67ba2f2aa13105af153b9190071c7cb05d3ae3dffca90e7a7629be8539364cf5dc2e08460a7590310f2ff8238ea373f94edb4862160f817040269b1c756ba82755f61537d7d3cd2bdeafd823e80ca12ffce93f4f2c3b10bee816939b67cebdfe280550f34a44aad95ed1961347387621b6e0039e962f9f65800d1b7f73aeaf4825057df656de3ee68f94815e80e4695e6c26192fdaf2a761217f0f111d512e1505cbc7c1e64780218c51b6f38d8b4ec8cd920b144a9f1c36acd331221e1be5418d3db944b6f1f6ed382198c290fd11724840920bd6ef7c4631c4cf083141afef6f559950e4bf9018a87c47da7c31fa25235d545cf257100bcf1485345aa9837be7785494e95e8e4b29010a209f738c211484b5168dc392f40a099f246e6bf3d6d703d8a054163f96965b34aa5b16aa54b61ffc40ca7c604ca596c486ff245359ebd123dc105b4e4381e279eff58e09c36e085c66d006b381aa9a5be46cbe6dc881356598ce3b33432e4795385fcc652509e409af46ff2d4268bbb499df72d7fb29ea00bb63d8461ce4eda11fcfdf077642243c535b59dd103f150a14f5f2f1554157a0e26d8517ceb116e42c3fcd78fa6c38d1733a998008b652f2c2a938130e77eff297fbc353c7fe7a69efc9884ddcf1a5ab628b4f7b7d5af88052a081207c2b868848d38c5e5295f659535fc7bb70e71fa382143cef288fd940600240c75b599ef7143090ba407ff36bc325cad3dbb38e15a1b85fc732c395d950ce39b3cc0a55d4ac0dffaea0b298e615b126e7ff725212b4acec653796bf8f05fb24fc354ef3bd321e6682f872e8774d96fcf694bd83e8f56c4868d4dd3013efdf865b106f4cf6c0d6400dff27a418499ea609771dadcee4673d357f59d317137f7ed2a25ec1acce218ce17edc6a5f51e4bc61e511419104c01895c640c5dffe83db36ac5eb2901790ad294194f8355f0d44d0ae426a94fe318b5e7be6cfc0be55adc8c02d46801e892ece422505c12b46613372f27ac6818d4d9f2a545db3bf7694b8ce23e30fd7c5bae790e93a92ca1eeaa1eb9a920f7f9ecd23f70035ab75db3ba5b08ffb9f271055eb9acccde001a310245ea8ec1e0dfc080c3a96afa7f1bc948f98e93f55383129b240e5c24eb6c668656878b0023bf9aef4342da70c6b9adfccf6771191c994965230ccb53cea60ef488efe3b31e12052d55bca48740387c55d0262c269f5b2b68fcfdf4d873c5d3f7deaeef855daff87e160252ded6d19ad56590bc6e5499b92fe5d349290b0f2147ef21ef1977179a977c727c2b7b0769c1aa2d91abe3a5cab93edd1d6847f232d357589d22e6c79d49aa82cbdc23dfdc7d0fb0879661b4e226dbcd5cac792c9a31d400ec64b51fbecc513f46550a25cc743773aae22d80967535a7287012e4a9f25a15d84ef98d041e59ea492f1f6fc45ddcf954f167fdb8d3c7d3993da832c7743d74bd878131f6f0960acbe5154b4ed32790979f21e46d75e12ecb886c69757f01f69e946445e07a234eb1d0de32b9d3f5ee39c15847e4289c029be3bf6cfc86b87cc2208dc7916c3b4f0233976626ef1a672d2c5bb32a6c77ace2f6be6f0586498a995e93ededa4796166d93a2bb3d62a729288d82d3841ae4159a9f3298daf7e48ba4858650b7ba51c01c35330fa51743c8cb40ed4057ba0a77679fec0cb740914ff707c72bbcbe33f6cc030581cb6693fda37f192b6c852084481f2129c597f9317d222348f50df4b06a51766c99a0546ac47bd838da5f975813e34ba679471e62f7ea827dca43fc1337aee520bba5ca0492909ebf0fdf29d6d9929007b05ce099232ff927790d111e73e0f36e6cdae32a342a39d58ee556ed828b8e3fbbed228b49d899dcdbbd8d213abcc47b67aa9994f2f3d7081a3af402099da925a35c63f7b7b590cb3eb6de7bb493d21321338971e07e197a6f529b7813e2c79b75ec85bc15d0bdb6a6654c1d00f439c7d9d6e8faa35daabf262c1617150709ba311a49dd8e94daca0b8cbf8ac96b0d936dc61a372a1dfb14fbb30983997ff538798061b57c06d11b77259ce3e087a9cb4407d975e0d514764b3a71f202731d312bc04a1778fe20f433c58226f051f62e1d8d777edd20e6d9e1b3ef8251ee1e5bfa87f6a78f1d13ab400a0ce6fba23fc98bbc4d03b6178dbfb4ab5e5dddcda59cb7985ca1cc10c5b816e412867081469c31e4787c74829413fdd60fb87f351f63ea59f18361006004a63a955674530a520fbc18ac9635261bf76323350717e39c99b17b6571115c2a91107f366aa1e05b636c4f197aac60bf1979d12acefeeb59bcc64a1c85dabdda48db86be5b1cccdb9ee1ab3b92c91057d39c843c365fb8f31f5e9e7c196a467e2404500576441ece3b08f83a565cf3dd86b22269d46cf3c20fd8215f59cb162f35619c694530d3f8a206a2f5fd3dc1d7a176ffcf9c88cfb91f2a5c8b26eaffd42464ce8f8c81ab144614091908bd417de2b01c6314bb01cbe7c0560334e98f538035f7cd7c4320cbc85bb35adf32cf84cd5e2890af1b0d47461fbe438d4f17fd905dce50a890cfb5140cfe867b1f54833237cc389c79926c26e2f9bea698e881aecb37491a5986ae2e791e4af70c9b7f1dac1636c1b2e0099787855826760e85f4f0911b84a468ad29e68cadb74466d7aeb7dab7174df2b0759b77db4b21468cbeafb981720ac1e223fc001f638bd36328937e844f4c5b116ca86aa59fdfdde6373164e9246b05484d85258220543f8af402ec3b8bb7c7c3bd896814cc64caaf373a634fc7cdb15bf8c9bb00c24fd8021c83dc115b332d86724b0814f5db6ef24fc87f3806c824bfc8fe7b37d4aa4359a472405bcd87ae9eda46c199191415549f5fcf66e838edd70395f272e5549f8a7c2bd7b267aec998b195d5960cfb988db52126550dba5704dc48c8f5f58f71e22b5bf8b35a869d278dc584ae07a88c279022dec4d29c45a7b1ccd51739a92790c302be32ecbb94ad7eeac6469b4d282d387cd6083a1c722fdad3feba3ea9fe6b7460cc4b7ee3fbf9efd934afd3f6a89a3971b06accd7ef179e6e34d2676a983820a30b7c7bb86e269020dccd95dfa76494ba46af96b3d3e72e9760cbd2a6fd9069843143e097911c40b806648d5af69599fd366f31324bedc2b62931909ba504df88b6ba357b730efe5f6cb84bade15a0cdcec315ffd1f0a6d784c78babeb45ff92e72f13db2d110d471a2b7bb0a811abeb97942ec26c928b8ba704e102e7ab2bfd7daec8e0158b0c44b7a02662c21fc0222f7494a631cedb5c8146eb8f9a1e755aa79c52a5015b0459faea86c558e2665217fdf2ef72e2bf4af7609874d728f79b2db958d9424dd1f0b864ea79520454fca0d7caae4e2a3afca33d8245ec5f9d11dcd1abb63bb0d3b224caa6cd392135f907e77bf23378eeb35f80918eb2435f56c030530d900df61e13fbca07cd325e38c02eb281bee9e5b9c383c9441a99454d9f68fb1765e270725925bd36954da89435ea72a3c60e81471fd3e01b2ad336d356b0628630a7100adbe63c8d17eae198cfc1dcbeb84b3ba790a90a054ded86a680612d43000cc3b48b2787f09639c075bf0153c9e8ba8a45651dde3c5d3cefa54c8f962de5429d66e87cd702181098921710e10d8935acf64804747c3680c7226a5d2e61c4e906cf40709e3b0dee13127199a15d24781d0e5272f47ec72f9fc1d2b2122f52f109043bb0196ca92d7f58c1d4f5be7e24e3c3a3c5f0dd179e12e177edfda61b4e9a750808a9fea0904409696f966b355eaffa4749f9509c0776bb3690c295f61a73bbe12221c16b6ca68ff939c29271c9f29a811805ed39f6a8270062da4d3b9bc8015f0319f67a08b834b3feff50415495ef785dd522981283427cf1746f02f760bf013e7765bbf90482116103656f33a07d6a9c45ae2cce96ffd986a13ca291fa0b8904cd46c0f68b6073aba2006ac8fdc0eb3895f8e64057e6cedcd92bde600e99075eafee3bb887d52c0d7ebd9e5acae8a9b198e7d2f5a9845aae6bc62aa7360e7ce6c23e4e7498688a41721b0627d9ca49ddeb4c449cf31dd4f4c1a4524f5c528cc5514981e488a07f78bcdcc52ae7ae1ffdf88485709a2a1bea6b9e41ef14be96c278bd945de01419c3921d045d5ab8771bfc37a8bd73abc5a9e8a55cf34c9c54686ea3b882bc124422d58da9b7a085ccaaf71ebf3a749023960c13685ddafb1e7d1aff7d430e55dbeda272754eddbbe04fbdc0513e6750c34a2d74bf965728abf651609e8de54360c4b0972c0753e075b5fa022d873938dfa34677c5c0b4b34dd7622ac51e19818428bf0a48ba7a7a2c3c2bbeebc7b339851aa6861a0f6481bcc02162b9eeefe13857027d6a3c3eb00af486bc3604ce997762937a854843e744d8a1cb91fc550408de3456145118030b1c015c248348a19d74a9f6ee79a7dfc943f6045e0af9aae07f1b31e8fe967078c3c9e71893aca5773130448b525e5f2daa4c1ae93fb12269ea41532cfd61ff3ec5d0c9f7da339c5c77790588d631096e57b3c8a5b1d977a18f7a1713211fb41cd38fc5db2092d7e21992c3dd0877dc153e76056099ff718d3e8b50adc25dbe73667f48b1c2eaaf2ad5642679bfa51f7c7c9e754c99ff28aa24f73b80bc9ac7c165d73d53fcef7ffd709dc6bd2bb67e7533d3775c00a641551e4e506b68343a31386e2790ac2b2606793a309b47c077aab1edbc386b02243083a17916bb81c659f92bb24a7fcbdc7068a3e21805c4e3dbae081fda89a9227fc50c9dcd06fad3f429a4b1e61beb895a27a54e121e51251a835894e3d10412aa159311dc7559077859f63e870588a8afb4c600e69e0f7870bd8fcbeddce2414c48254e6b23b7e124d804a374303752c1d87c467beb0ea1215baa226f4e34e48f2eb9009cb52919cc819ad9d0e3a9bb25d2c2cad41a810a2ba1523a0a48ee4ddaf4ea6218c5c1d64280898f1fba5d0241573c4bf04e83da692cfeb065868080de6604b3ef096f1520818a23f442907b352791f7e32f42ce53fe0c56a7d1ed8fa3b205fc8d326c1f7785ce8ee458305facdd08c8ad5f086946cc5bb8e689147f9d1e791f46ceac308b2e5b66c56fbe00d7033e63b0c98f4b5d50570222a7716b99bb16c21fb666d1d0605c46b12c9df6c20a06b2910b7dfec7e4587e5e40edf50c372bf3c23ae8d0814fa68ca3031a387b383f07e5b170d65c0b661ece8847271ed6887f0ddfcff8f81dcd91167eb6a8877952177310594e0d110b860af78a1c4d5fa0a41a4df4997de53787c6c3db7af85087e7f3e92c2e27ba379b4f2b7023c64075dffa44858887026d949d55c432a685487d92b3c039a2365863a936cea4af0ca511d2a2a4dbaffa14628adbd79059f06cfc8620c705c07886270d2d2f20f6fa265627b707af423443a6b4457307c780c8e047b79ea7ca2b57f4530690836a38ef9859bc1a24d8006f1135c17f401bf1531052125130260a216f4077649df5751d9ff6ddcdfaed239fde3f0cf7ec0a9070dc8f3cd65a86bba6d36e31c0df32c5059a13240d584d1d1a6f1d2a392f9629a414056c28e249f5ea8f09950ffc3bcacb75161281fdbe9dbf6a7a6d739bd459e586bc815de808c5b91b62096b0b012df67788c1062950a29bcb774fc7ea75d18f0c02ee2547b2096635d91d27ab1f816457eb289a6c84053229cc3b810fc9315cc8c9598b0c8d88d054af66bb60e219dba503cb5097e1386f97563ac41a0482984681852271fafaaa576aaa4bca19d0bb25e8e9871bcbb2929af4ff6c74cadc45efa9d7564a0694da99feb19f587d26b59aa03b123005b874c99c7869c60e672280e1d1869c88ec94c8e4e07b72fbe7e27cf38a9b025c9df37632a3dd174f02c78292ac43ce59b7b066ee359ba44c7aed8dbbdf3582a37d3d9cab39e018c283b2e9d3cb9374625dc820fb7670387068f030ff53d2a298465a85f217bc8659bdb9b17fc16f899289c82b7cf596781a62cfd3fab4178898bb60db4fd56b4fc1dce56cfffe61047778e1d96ac7b28eb35630d1d0472369a08edf7e8d19180ecb85ee06651663fb439c133b496cded34b3cba82c38104fb02f12496bf4d2a56f109c390988cd39ba170a226dee8f70d13ef93e25569a164b6c7de31aadb8343fdea24ad873c718bb825ea87a6674f452c93f5e2273cbb72cb0c1545fc085821fb8d1577614ec3be868f387c24d15e4c50d46aa7a0a30641cff4b721d154177982363916855c8450c3abc5fdf62fd19b42b00effc4a5a668c64e9a6c940042d2e37f95386385e2e45cec3177b992206c55dd8959f36882460c293b87d62054810b5c7bc7302f2a012906560c87520a26581a167d9fdd1c3fc93ab49cc1ea3eecfb88582f5431c08bb1d7b3b8a83a1e23f903d23ff11c87c7657bbceee26d5b6836b8720c8bd45455a7a0940c430bf9e5977c97d7955412880ff1be026cc7510f5615a1c0c4d9bbdcc7c1019fd026b75cc8fb64a5402cb7c90151792b8031fe4ea2f29fa05f05d87026bb6ee478e6215cef36f9d7ca809f11b5fd929f97c31a9a17a97ebeed6518544793f6f0d6d25888c018c5de64f5c1df5028fbc791b5151b6460c04356445f5b4dbec0408f0bedff1293bbd0aa4cd4dbe9672ad0d6df29503c1ad784601bec553b819f65fba9add4d8357c710e1d7fdb21b10531916a53b155cfcd3554edc1f021ad7f59a9b8aca5df30da15cadc9f233e48bc806b6fca5df37223c67dbe7f8f8f325e0317d27cc581d0bb59f60dc816e705a03bea521e0fc62f8d9dedc63fe01ba62132b5ccbd3940f4fd407ca6f8ea52796fcc2f2f3692d3c15be4d903b2f5dc405a2e95be8e5c660ec8b5af6792b1f7fb0bf4ff65577f1fb7d8882f91cc1d31e7ff324965c36800b32b7afdede6ec54d3901bc42a1cd650404e34cd69bceecb6df4e16d1f18a82abe3c3a45e71c84e98e8bee6af79574cccd94525ebfa7490cb58d5e54d98de8f6a586a3d0d453366d152399e589486cdd4bb353721199eb48942bdd7ef9848bfcb4bfd94491f474d27f13f52fc3e722780cd3ae9f3a0137802e29e82cc558a54d71ae77473ff104c52e1968c83af3ed5d5cf5b85e4357c828efa216392d3a7142a6f0994712a7cb29358c48ea2a56dd186770cb88249f464ce7a72cfc23a7193d27fa0dfe9ae102d7fde7e7cad5cdccba270d52f33ca4feb865e5f73c81af1eda1aae268ca33e26f83e75b8c2023e1447379018164344a26d0c3c94c4d9e29d0aada025460b70df075c7ba3e8275859835982498dfd4b422187d4e5dede1810a7dec50344ae8c59323662ba7739a9301c110fe324dcb4f0f42fee10fe4e7d358170bc6ea5d1d1dc40114a62a9ca4d996235a1fdeb8504023dd26069f57bbcde437ebafb020f77cb0e2a4dadbb6f82387d57e2a78afab5035b2e4c12677f0a50a78d457a03807a5bb5ce32f4886c6064e2de7ba97a23b96af98a2a3d02845f72ebcc2f1e6a15e4d00250b3b8c02cc2ffb53ec0ac392857667d00269f108cf27e46200faa20d7462a91ac57db084bb2955bfc186ae2667b0e65ccfc51e38cfb9f58bda6a14e0fff2a5a474a8f95a62771adef052470fba2853242d5abfa961d4613cedc352f868f0516afcca4b6a7710156a51e285f8a249a6f01e38d0bd794be84ecd8142f1a6ac6287479fbd90ff82785bc03b4fe52d946af8f0497d5425a4c9770229f0886abf161f27e9f405c9862880b7e5c2df5000a45a6dac4a5d32f9e5ad3f0cae65bce1c43600212dac16c654b257568a5dfaf1804df7be9efe66565a01ffbf4f9a0157f56dc5a8477c9366edef64e5f52bbda06b60b6b445dcb5b241a84d52801dee30843b8a4cfab2eb46c01b73215f8150144092256eb0a1737dc6cc69b298ab71623780dfa843c748f8132a1d7b080d4e4d5618bd3ca23be1a2a4df548af90ccb64c0c9e1697d812e0aae8599e0b1975d547bdb3075e03720e8ee74d946a87e894a6a9374631f44f369cb5134ba1acceef1f61e65ead7a3c9832692506b04d7021ed95c31b09f5ef5c3d0c33ea8d0a5b66f92d7b558","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

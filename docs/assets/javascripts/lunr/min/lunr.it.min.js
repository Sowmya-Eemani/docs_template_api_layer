<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"848ddfec4604665a25836870ca48f9ac8b5a263cffda3489d144087492b724817de5538eff9229d69f0619b959e649dad736f09fcdb379be256428fa5f56ce787ce0622015a18fdabb74d13bd1b31dcf709a84140f523763f93f58b1df0ff939de9b7adcbedcfde5c485ef0fb5146d2eac2b12fd88c4ff999f291c2e70324cd89ffe42bbebf8ef4dab348ba7e766ddc54224493e531bd6f3140f48e1a92e70ba0a393e0431fb2ae4e41fb660e125a04259cc3ce6d1b00ef5bbc6ce61c3c780ec40db95c2b2c9d42996ca19760cd08a5f9cc691de98a88b691deb3154221ef65bc3912ea199c7365887a63e7a440d8fd43a6b5663bc38a90aa83b35ffe9997131ec7ef195842895e08cfb911c39ca56e05fea0352f7c17cc24732de05a7d7f23b7f4a596f482c58c76b7a9741270a29317179d8be7291ddfbf624d8eeff9d82842c9b1500c9d8fd58b5374d682c3e7c682f8037d79d69b4fa50bd8aa9726f12300b69574baa3463cb7a995297e6752804fb5504f6b4cf444330e8aa7da61959f32e4378030d78a8188fc963cba1a1fe8c75b99be75ff505f910a1542834bb25d9211f30dfa41b830c01844cf3b0f24b000536e0caa78ae7af5fb6dd7356dab85539133984daeb44825ccd247705d2caff059c3842a06592ff3e06495c0e82ae108f28917e00cae7f876c2b1f9f2fcc21ee0dd33ea1f20755bcf3ce6fc111218dbdcdd84d29ffe2ae43a34279f8464f07a7dea7e0c9e06b2092013b382f58879c6474c3103b3d1cc538b43e54a41f99624a66c41aa07012fe16a29a1d19b30e130659f27293e86520b3e72bd1eb07edbf1f62e1a13836cd2547ca04c81d485668facd6ca8ba2cea106f4c1e8d4d1f612dabed80a9ca910710c5ed7a57e121fdc4561e33fdfc38d184746ace7970554460c3340ed21fbab43e9c11d86b1158a71704fabbd1925a3f57ad46b43ae8b581253699bcdba6688a84e2913fd9f95e1a85195708e61c008f84b3b30612a9889d68e6daa487fbe1084a0be776685ba3cb13d93db522e91d955d0b5e44089f628d289d8a0dcfdfd72d0b05dcdd50302d6196b1e4c739d4af008aec1a146dc8d154f3cb76657686bbfc4be707ab059639b26d296102b95dfc5e71e7a56d257ba683f84898273706585dbe3eb203ef9f1b7151273b14acbb9cce436d72a2cf40467b3cef5e5c80f88452a0a7a37350323088395ef0539f1cfe048b7d9c625596606f4ca14f9eef27ca5838b352fe7b21271fe7f05c595170064feb8339299e68c7078a96930767071f4e51b0531ed50eb11c8cb5ecde38e8f31dbda7d6d19fdcced3f8aea8e568fc932e82246078765983e1f0ae9f88b4045e51999df0b8f20e2688fc5988144145ec2a11cda21354aec77ebfa61373f73f7bada18518bf8676c61e9da910a97b23bb1f3c721f9f01baa66cb72c976cd97fcdc3226a2d8b26bce1af777f713589698f690be68505a5a605810a00f93e24e43c7cbe7b80f6946451a082073eb2056df7fb323095f63b7d23c339f9a968a51db6e4101d6562ff2524ecbeaa5497aa5e4ffe65305670057c6809970b22a37e9f8003e41e811ac1092d435782299a7963b32553a5c8a8697a9fcede41dbaaf42bed34e958228dbbadd4bd4d8a8eb33047ecbb08fb68eb9f202ac3d57f348e945e3e34ede3831dd2d29854f3bddde93132793c4b4c2590dd49c091d5fdfe468193444993a43bbc6c1e85ea139105d6b966261839a468d7e8d083d15cdbc576dfefff0f19c144a9baebff7c74a647daea109f871c89671cb7b97f1903685df915f00270d28b9c77eefe269c4c562d915261f2d9a5cdc4a29fb979c4c6ad4f857d37a03833f1520de828646bc8c6643762240743de3141ef9ff224f97b24dc52fbac5b60e89b3181a4cd701fa86153f4c3563a14c0b74eda62f73e8adfabf9e5a5f80b8649e07b2ba25e88bfc24680ee78dbd5c1c506e89a006b852af417272f902209feec5279e96932fbec518390ad81279048c1670c1686dda1be0a44892ffaa919bd7d3694cd894a2f243b7d766ba1fd75aa41451063ad687e60fe5adb92c2dcaac095514edfb99c8b09d769fc4193da1e2c2d27f11990c21efabb1a912d795bf1d20759371035d8f4bb41ea5282e4dbfe8cddff754e140124100493ce855732ce82f3533a1f932018c2155968f8f9ece7fea46128b6f3d388821cff278cd30e9d3a949e74419c3c7d7ec0a17dee15381a408caeb96ad9603c00b81275094a6d9c7476fd0aad3166fa969ef011460c254435cba134ba39f8caa89c8f99555f8aac2c3c00abe895f51ee83ab61e90f43d075adfab62eaba7c839ae90d1f3e1064a85d5e8e1bb142fad133a51a037c9a1ac6ab5f0482f2871b27395a9c5c9d8fed0fee6f7b94dd6e46395f69ddfbf86cef6ae59143512f2cc54152d15090f97246bee72f17af9db16e97b5a85d796e6c675c043b07492a110ac379650fb0f54cc3d416145d1438bd1a7d842a38b895ec04795c8f459790a3be23e5c5a7d28a120e50b36224ec7bc2c921761d6b9368ccd32efcf12c9a263bfa61750eb03bc6f6d0323d6b698021d589d2f241cf7a5e76fc1ec26b374c442ef7d0a2f5460fb732dd1dc5ab28e7e1f8dfefee599481de53f40eaf413d57a4a88cf2909096824fe3f441c618dc067872bc17cd18a1e7778a23801d4765ab576d786aa5e7c0b5fba5b403bf3d4bc5d7d8527a207b35c5abdc64808783315a9cb242a83161615f9e50ef56e194c2596063bd38cbcfb21aa31ce4dba248e5e4fe48963a89cc6eaa591a5ae5d023d939db6dec1ad5b05c8087db35b67af6a03d1baf618dac2346db2e82031330d0a1513248a463fdfab9e7915cb5d2b6367ac01fd2f0bab3e6cbff9bc57c040552eb1234b1738fab1db5797357d4d624415e2fe7cb41102f18ba33770f30f3d8612233d7bfeb428f5048a4f1285ac03a133b3f4d9dc8d6999396cbe5b095c1e18c566a008d1ad36786bded09c3d0e7221abbec1444ca42f3f275384b3ca69cb8dcd79f75939be367a5e0ed9136df2af8a41aead9d4084f88b7411c88ab8502889255da3140cea544b855fdaf0c40d7c1648b2d0ced75188a588c5bc322216a781afacbf1371896bd9ac0e98ed6bc2edf83a9a3ab0133c7a8bab1fe5d24b59bb4482e4c781dc162a087f2bed1196b29d5fb89376d0bf5a009d0ffbdb27bce9089aa66148ad29122ec45a2f94cea8bd8f05feaba69224488a15923e8f9c59e76c2b606981201a92ce2d9e2dc77d9e2a3464deeaf27df95b16cc4757f5cdd78438d6240a1754a7bcee5576a56bde803d3ba9de9b2276bc5fb1221d5de002d51e1db6b7f3cdf9cc78b0962e9dc093a476f839bdc78b48ddc47dcd61c5eac22a88e6a8bd519abff0c0707f3e158dad19847d3be1748ab6eda4336b838e10233989b9e8ce6be5f50bd91467e64ed4d4846f9d2fd2f3afb97d60b398a6540b2ae6405408c1f5036fc752c8f55b3a2b8f9361ec514a1c03733db9e36038654147d4d411b1f88704ff8fdaaced4d7e0517334433bbf54f91f99283a02b84b74175497b5b555e01cb133b925e9b5876bf53533770c6d7980748f8139f535cb7d3bfd3e51e9c7a6f07c04fe4b30bb686c2fd59786083b8fdf161cd0132f4194e3ba568461fb85fc3acc99b8b3a1c4bc51fcc5aef801e1c4e04b5e438da1f2b80be1d2f427c2c2e80ed858180f961ec41032750ff00c4002faba8b598953d248de88788799dc52ad6578418cebbfc614be0df17c9a997eb00642a6305b4ab2e2c3a5a7fe4f8e15d3ef318185dc0f57f8dc5436237e85c86e9a6ce7ec5924a15c659578cdf21e8d1ac41f8b3b5fe88d851a33299b5260cf5094a132055f0ca92bda6b64f269f584623f08232b0185f2c793bf5bbbefa259013e8f751fe5e67e16f2ca307a6ceee72c46486ef2b0ca8476a575fb1827c9f130c52977005261986bccd8f382d07bb56f76d7b4c8a1ea93c3bb464c48b5b64fdeee22b888ba266ade0a555092511228dc0a4fadc2458d0d51d53e0001a419030317530e007e6943a41aa6083889e6476de9e4741c2f82c715bc295af2d77c86afe6c6a7aff1525eca424cbee6672bff9d0000dcdd398fa19d16e736bdbda57f468be2b893e2530726649bf94c2be7ce17da193286fb2b9e9eba5948265757e6d77923424772072e24a5010980a86d32f15755eae1595a14852158a9e449dfb7743e8b2ac06d91312ef8b7caf6df65324c067e6c0e5d6b079a4398846f9ac25ede518a0c34ab27971f20d215e353abe37726abcf1cf4db0b4067b1313173c9f0d2e2e9f5cd55aa791171a1cba15ffacf468bda07a4b6d029f0865532e535fd771b71f156272bdaafa0c2cec48d8bf8dd6dc1de7dea23151caf3e3f3bf011252f782bbc63dd8a41763ea1e1248c99bbe36dc02c1e77d6834af8cb5256fc2f7ac0ab9aac6c02858012bcb25f690e8c7d76824b6e996f226d6ee1fa1ceb52e00901ff3c6d2342f2a0ec584af62d71b1383d3d6b89bdd1c58c1225f6a5a107d1de6fe7eef7e44ecb19b0764368e1a8afa30b4f93d65e6fdb27288003b6c7ac717852d6ac018cbd7e7119b97b50cc74112c3b586eebacc6d812dcbeaf17ad012c98f534ded93d5047d791443788fe86aacf60fa530d918b773fa1f163a4a7d8e5c35177a1e848a616717078169b128d5ef05a848999b3690c10ae24aa4fd6fea3357d943b66efc82ab213cc9bdd1003cc27627526e651e9921e7b1f802b972d56e3801bdcecf2f1613fbd4b65e5ec9333a519791c2029332b8f7ed5a608a54ea104a598539583bb9af891ad72b80c8b15271c95d0035e1143c2c335f1d1b1788928a0883417bdb74264c7038874c10e73890ca5587a489dccae54f831063f12c0e5b6a995216c8a1c75bd5b5d50b7fd18f9a3746bbe670f6bbc9492849d18b4737483df86d4f00f401142b8e7a690c8e72cd26312a107f095f3237f114ee00b179e0fcf8ed46cfe3b38fb58702e7e0e8292b26d59e24ba289c6a128622f8dda52feb7ccfbad4af7e47e394fce6a0b26ac93fda97178c2dbfb3fd1d80e09f85e79336648cf225ce16f8e856b51f4d5c3dba382229d29f2e45f77b583e254a7124a50657f571ab35e9ef9dd07dc4b71e15c820c12492b9abfa1d13f9e91a8a7e63645b15ee7c6c067f5d27691b92fc819caad23df6539a343a984d15fc23ed47769364e2837c95ebfa53322ac05bb3257034081abd4c7908dfd3ce5102dcad49d94ece9d24c79f371bc35b66b6a9395ce4b498ac3c4e17bbcea9f0f8417814d073fda145f7fce08c3281072b16c434dc39e68f6b1b4cce54a80c0546b1558606caa4233b4675b5f519f95cdaf31642d63bd7f08cc0421480269036ef8c5d267c203a3285097185a0e1c9ec85a9915428d5ccc3680b6bf88c503df9eef75c3ece48e8d942fa2972a093d2ff0e08dfdbdd44a99fca07a6563f1b3647ecc5a9c11e80d191f293481bfc53ff4d28971bd77b71bf25804b5600a4e2a6176138bad63a34d617a0464db647ff43573be811a27e7b65402b61821df28b426d13ed5778493bee3bdd06379dd671dd45de0cc0e030aee59b8d639071f364c7670c33cf4160cf38e9e271e0440c61fb106e8f5916ebcc791448171c315561b3f476e951de1617cc8c488a0a1c1c855287593ad80e95e8cbeff2122122891be130ccda6e93677da0eb616de50e89743ef8a00427f1150a2fc1c3f8f0300777c223241cb39a7a9adaa580628ff4508d619aebffddfcc9c1464a04ce8c1b8ab9bc69dd4c0f72c9a7d07f72e9becf152c562152b9c180cd95f530bb2505ce04384cfee549b364209af1a9425bdf99bf02629b0f33e8389c05615ea7e891dc158d487e6956c471995075cddc77b6f6216ad20894564d6f1ce686b75cf0b1ca34b061e7e97399077d057ea92f5f3b58532a12859595676ea1c58f91f092f10bc7f75ba7368e00351371398383dd64e76834c089f5a5117c39b322de7059957a481f7ded26b7ef32996bcd71473463099434ee67ca32e3ce850bf9e52d435f81e82dcb927dcba1620a25279eefee7512a6a999934c2249f772d50423c72c77428ebbf2a7fa88d01cb5bbaa11730e0dfef59fa214e34fc33b8937c0d59da4161512a2b3bee7dd3363fa5017c64fb743c87fa531801dd90ae8d43a799826d2663d79a97628bb363b14038f42f80d42aa3e88ffe97e802db32fb6704e844b805b8b9dc5bf310794c1ac867a1bb111bd2f07551415f6c9e1f5c2aeeccd3c53603b9f9306b08340f144a1a73d0d42eb7a09c37e6dcaeeb75fbba3c76391131656863e7f27379aaf4ba2c18620e6cfb88f398bad1cb57e95d1074727833e0b09d4a0845daba0c0a4e91f3d8d4a18e979f8f569e3892ec9e2a1e1e0b2673490809bb15dc05713c37d8e6308e2a10ae6abbedcd613f4794ec1153a7842e60459149299ba58b9ca3d5a5481d5bcaed7f17d326b9816087a54173b0725e725929f2f0076a4361d9f45442647e2255ad60049c10bf85ef22f4a9486673473243689cfe93882e6f0d48249d45578666adaa0e4398c56437b552de3ae1afa043b445d0e4ea3618e3b9ae20497a5a597fabb0ff968115fa0a229d62f5aaef0d263febae28fd49eaf42e4917b0eddf055108c663bd81407fcbed1297917da72b0a27e998fc7de74e0f202c222ad5e0ee842d9800e95f80098cbc5f279adc7029e85aaa043662b833094bfe43bd33eb662ea6a8764016001478e5d5dcb7c10a96caa2c44016bdd2763b9ee98d8faa711252bdd6c119a48ac25bd1dc5ddb98b7b719a88e03f3d178b85ac2fe0703bb2708942b873ba30c52cafddbd504cc7c220055fa889792955c0f1a656592746b61d664272ac5fd424c7c83216de1518c9b2b2da23abbcd0d48e01a969806997c8d6fc5d7d806ca93d06fb23872ade977e6d05888589759f7529637aa94fff9d8e36318b93bd9495c97cb47f8d1720dc86e4f3864af84a9c63be8734271b4cdc610bcf309403880f1e4d3e9864e80093f800b217fbf3b19fea08c3aa4089d7752808f67210ec7a73c7ede18312911b219953543b87635f84edd1eb7b50dfb152731c66e3aa811b31934aba03f82af4ea57764037b874440ecb97f8f4dadd9b1d228ceea98f6f286e3bc61a49de2e1b8a266c5c7bbf666cc98f5fbebf5968933763d5785e6476698c48c070bedb03da61e69888446e9f6e4084ae0a793caebd2fa0d419cd9bd127d8eee2be9fbfc5cb7b4e13cf87aa94e3ee12f5494c4eb32482803aad76f658dd5c7022f589a53ae860d2e62c6a74f788760b77a11fd8f39b16e16ee5b77abf53308e0d0ed42058a91e453936cd54de9f417e0f1cb2b72ff5604e60bd00c8490c54441292ad5f26290a231a315e88d427f642683e4440128e3bb7f36b3691a9595f9a8d6d6b38fb2355043041975ef0aff35ed86255f4dcd2bec5e9e3287a6a97d0fab585e642bfe18c73a33e140bb9bd9d2488ec2bc4c3daa6a792d7e2a60b91e028d09eb507e920f9066475c1b70f494f0614f6239c78c67e15a8a10e4ffeabe3554dd1faac988700d0750393bc5b405ec336f683d2476299e2849e3a5c59dd1b915597be2b42ec51490053ff15ef48f338bf5c889fbdf0835c2d2cd9ab6fdce618a6b46f9ab80af45bbfda6ff58fe65ee9e27188af1185c865513f2a135389c49b687d6b75b6eda3412ee7d680893528296f3ff7d6bbac1070b0c7b3e55d7513c967258bd78d27671fc886fe0f631408d700ba84e9364311bffe6840810126fc4fe04cb0fcff1859945ba1966b6cc5e5bb6287ecf2374d7daa3a6c0b71d5527ddb6ba877279e5e376887bccb7073761cccd1d544814916e847cb16db8a9da34073a8f5d0ec6a5f92d47c89516a64f74239fa5d018ed167fe0533ce52ffcd980f60bfa1c13ffee21efce657600279f1b075da4185ce0462c4cc52818f1cb86002efa01072d855726bda51a9adef442c35069c7c721b3aca501a555c83f1b22deb097f33b437bb21f8c74c2908e04172d9e2e050024b08103cb3f6d159aaa9917d94847f7b881eb69bef455260f8c2c298fe68bdc8ee18cffe1926d2d28bcfc9de766aa9a0c9e3085bb24a12adc1e8af2163156ea8367cbc8cbe0277a264ff3568567a03f7649def25bda260da933d9472a0a89a25a0eeb86005bcaf84fd4cf58096e4193c29e8e1a2b6a89a248cbb40e77285dec976e618943fb10dcb84ddad7518175c730e4d880afcf11dedf5447dfd8c4df76f077d9a888019501c325ba50f649f7b8ba7a1f9ce7fa09388f2dc44f85a1e8ad95e2cd4c44286492291296ed066746c69890aeb6254cee91f2e1f81bcc3b478fe65346572d86d46aab2e9a7190d2bf23095d1200b840ed07839c9f9590f61f072c50209cf5386f2cef93b76a2c33b04de19fe1fd14d764b8bb80d65477ab166b844d06b65a1a0cbb63adc5a150e99a380ac8189648160f48c0f8e98f621fc4d46b07282761f3a2d762f5d39c6b79b23ac041e91fef630ad32297ebc92e15f289521cc65de82898d68b76066195c3880304b21a67d07239f50457e5440850d080eade466853bd03d7a15c26bccb700daea365793d4908dd7608e9c7c7ab09656e713491099c908f90ee2d7d0d42bea5279292a21ffb1bb79b008a2104b36beb0cd938cb77309bc9533c803a0afd82f4d3b436f31b33cc3c54a11c9708ba378f7194fb85113529cad2523624d4ec7f5ea5bed7a42fea7e36f812944937cb8a6344a8a4068d744c0a02ad9f43800cc0e526b23e1295386d39b147e6601290d4a74ad6223fa4d10649cac7a8debdee3dc13727a8ecb242983282770775920d7692635abfef543c403a3214f1d94f27b32209128fd4df32e728de7dd798ff622bbf5e9755bf2c59dc1c9e2bef9894e63db9343ec661452c73cd88bebc86d3a0fc104522506d38b7d4617c486f4a6a6bb2d9ae4f6d756e914994bd7a991d13f6827ee6593e4084c733a462c8377012301b04525a48369b243e223780b38c0b01fe07838e723168e4b8f6891744c945ad8741249adb50c33a668199d7880611955a86eac505e387f96a61e209932858cbc19b2a130b7928f497c7eb17c91dba9c696d60c181a748e5dce002bc93d1b913f9ed13434d4d91e77ec21184e5481ec7cb8a5e6568460ab2702825836c6c6f3d740f17ddd87daf2df7b76a670723a72833c1997ec0e56bf5e808d1172c7a404d189a95ddd4b02ad6ede0ef4f1813e91f2ff4b0e7296e661a84ef91198e01610626d0b15856fa21880d9884af2b6d229667fae00c44a2793c61f8521e8738e8aaeab5d742cc091323f2f11925b7806a53649bd2181843bc7448ad4abff9b89dd0c80c689510f07b4a8aa4b5726f5a27ad32799e7815dd67e0a72786e1b9f15d7a6f5eb47cfad411234ab1b85aae3aeb3e4425e57b9bcfd349c88036db80fe15ad880a4042fedf30b8099d6ee894c1397db425b81df8e007f3a643c564840b66fb5201aa5d5c95b522155d3a0701fac0111eccb683fc41b19d8f94072b256e5e8ac4edc7dc7d1336f229d376cae1b4ff7c0ed4684045673a9e33563640e0b57a6efcd1fe50e6ca8f96a31419aa1a5e266a38bf499a49d442e730d504c8eda6ed5bd95aadede6d5e2e4bcdb90cdb9879767c9fb370b4bbb04057c2f3722e86ac6bb4335f5a9a7edbacf27e7176e0326bb7643749bfcb0af5721b2c246163fa9c6a5e6e69a3cb17b8190062f156429415bd224608c87e01a7f5c44025a27e4926955e78e518a68cbd4c8fbac6cd1c18629e1def5de1d97f08d987276eec05e0d2bebd0a7f108d5e73e78c4eb783f59f92bdf3ec9a5c28bf24b0ac44b165b6de53ad818f345397322f5096e0e1ee153ca5f7f08468a893d340532833532d36cbc4a545533f23111c9ccfd26e8661cec270300f1547f1c7101bbcb06058a1f9257e564b01eea775319dc0964fdf07f334719e0c313c3530af3266009e0669fea14812d0bb0434861d50030aa58e60991d7e6d1f4d3e55d512facbbd268c051bd2268e7100da425f4843d2ec56299c5f065430e3a18b7412a2645f8f595e18f8fa8600eb07b04a03736b9f518cfa3e08323b46aa3ab7ce642ece5f0de8824648318ef05fb739840d7c032a041d518327ac2db3a69f7fb83159cdc94e6287f69713d3b8b9393053ed77bdf08a09131eb6bd8d1a6564446c9a567f259db681bbb51c89546e4ecd9c944b8029de928baaff26b934c07dcfb601f4caf5334e73317486c329633e3b2738234a1f6f14b43182dd58d30d4f2f5ec520fbbf2787d61a15057f5fa1a0bc0d9acac48140565fb0c348e966302cd2212bbd0d72dd5fe2a81d9f7654b415fa1eff5534bb19c8b5c426ba397b4eddd844d1e4567e19e45a9356ca15b11eba4610f414b805fcdeae8642d39e0d1f5cdf61c67e253b1a88a32f159d2f91c72dd81d66dba529db171062ae0ca54d43ff54a97d7dda25c495c4531eeabbbe95a55b8b88275df68fefa6c204ffcca1a985a87db30c1ea1d92d3391952f7deb41e2a544c089adaa3582e683f6f6fbafd420d0c7ed2d532a8eb8ca6b8634548c802b9d81fcc3260124b082c7743102ad531708e8af00f0a1f84a9d1352a4a90008fec8a999b92ccc6f5002a849deaeceeeecb487d0214eb1512599d0a56ea104ea6fd75be3415f13202774d12217a180a2188e8b2c82d9e822c9a054e843f8c2916925d8d58c44ba9694caad56ac30142692c39c7f7fe5a5c8544a715a8a2729e501b6c5874cfe0ae893499acc052cc044e5ed528a274e6bef37aea0b94abcb3759ef3bd785871c17e26020ed6b5ee9ad25822cfb653c7b6a0dd65c1549d1b1e87afbe719db5f721fff967c6c282a32b76d7b2343da08a6048319cc4da038b397dd65055549b67654cc49fd2265fad7d0d9e00c08e38d31d76cb92abd9d54f5de40c6a808890e08a1547009efeb1c84882fc35b9d37eb6bd4be991f899d1508655aa03390d9a56256bfe495aeb5074e2be2f9eea1aa4c2afb2c44fc36e1368f2c9d6981ab93b6c6d527bab08ba8f56f428eb62fd5debacecba3cf62dd81f9df32b6990c7f8b2b9efa10d112861d47eb8fe5e06b98e5f246b0426444a13719ee38aab872ac9be795a36bfc3a4475da4b5d4da88dd563c0027622a16645bf222cc55f97ed1c3f2748fc4e4592843dd76be7e0a6f131725ba92690d5c3d69567facad41c0a680c0ef6054de10b5583c4644301d2a1f7715916578a1fdfcdb7f2fdc44b01a3d852dd18a944a2c4d3ab299b93655d7113ae0256e76368c9bac412ad125090eaca50533d0a802774c797b9c8d0c3af85929dbe36ff38552ad864281925fc479b749d6db8c3034bf2b2eebe71b0a6cf8c05ca3bfc5edc73b6a0d57116a8d9087b5c965d57bab9225d0007592af1bef0dcb138e7b6b272570710b431aa89c452f5907f0b39123bd4da665ce93138327e1ee3572c46592e836d800b364ce35130aa11f60eaa39a970a496a5601db1e1eb0e6cf85f73bed4b9fc207e4d2941e88f8382763011c5f840e4893ea04bfc76554229da2b9ac5ee89dc1fe86a6e980d2a853c2ab77aee2d32b2c62b420f8f67a07467f8115f8fe91cfdf36e595c4724c111d9452f3dc60a7984f9865e3a3b8b79a7b4869c5fafcdb63460820adf987d51a61090ae6fef5aa45fe6b8c1d02cf4e271bd654ebeb202381f41b4141e474b4c6bc2151e3fd87bb76df5554d4e2649c55c7245406ebc646ea76fb5b13518be4021f2e613ccfc27ee6bc44d67880cc890f623b6563c1bacd2d3596416fb183c2aba5c9ea746153102051107025711aabffc7315443525132072cd05374b7d002f2e07ddfa0538f64e1fa9a1310c096d9821227d99aaba58618a251404a5457350399c038181e2d6d583adc73ab703d176641f3cf41bc717faf35184250c1f9ad9394f7144ca8b11a14d01b7b5f05783ff9720f87c4e04522284e0e4b879909b6188cf4cd6045d4d3d5b8a852b7ddbea8e61d7ea8297182bcd1b3490b6605e41687308bc343698e4d2777876fd60b0d3feaad0531c8a8c6a98f9b6c64b81259e71630c6672258fa3d936637565d1bee00cabf158f217cb82f0bcad96e834e7d9a86b87f6e956ea9112461b28c6efcdeb28955fa24b3048c379206779fb676ce8040d129a46f39a387ad32a32f9bd4beb5777ed1c4c053d53206a29cc5cc9a520d7ee60cfbb87d2fec8e364ed0f78d3a367a515828e472e8148c28a5ed47d6f9ff5f6761d49e7ea1ce2fba274f43674f914996a95b01bdc12a34e0580d109e0587748ea3c6ce941ad46c83ce0a0e0e2be98e1d2b37758b83d474d46fbbfa93f87733a89f846b621617a3482b838074be7016e2e0bf85c88f49768523b3e42960f2c955c77dd9ef90601451e0d5dfd910e65fef77608b6709133b5059d7067d092d3839bb85bd42e5ccde252bdd6d8af0dea863cb46400e4f8a7c7508a249e606b7a25a99923d45e03c82a8d78d0e795c0e08da30a7e0476089d1081be6c0eb8b2fea88938aa49098e96e9f0df5f2544ff7858a08759910f04a2b629018986256e444f835c3a0624f456f04f227a4956022b438927f64584f15414c114581a3c37a7bd2a874927a8a70937f66110b85087cb76bfe2fceaf1fe19174ed06ee9352131a177f0680681444eedff06b794d887dd59af8d5fffe1fa525598f90f7eb4ec9654b5986e180b56d5d3a9cb056a060f124b7c060fc79b2eabda9b0f58905b8411a2a0827357c4271dfab6f72e817c060acc59116857672cb0f9b2b68e11545c7d92fde73a9d4ca0afeee84b19b8ac5ca4d801c5b14e4eb5658a91b4d8de200b41ab619121c56fff47d0ddffb6b8d090955c4780b2a6460b8437564eab95df5029f9c82e56d9af1ca565fea7350ca0989e6b1676a480dd038cdc01e790f0154404f91e21613fcc34624ad2c9597f37a142dcec1f180ace2b56fd31ee373602a065ae94b4518fb72aaa0410aacd3cca55659ac8d8568b305dad8fdd21db343c2544ee7ef0f70cad6e03f2836d638ac1697a612cf653c3cb9902f82aec49c9a44179d9442cd81a61d84a15db5a93f01857f3a5745de79e467ec4a57c1d356e6d9ed0331ba83ef57696fd4cc283a1a25ad57af00eb458336ce2a97ea5929574a46657e92ba16d79f91ab9fe43b55416d60175aacb60a24abe97f0412e59fdc8ea5381b26d940438dce74598cfb05baea1edca286f0bd7e1c7f75ebf779c291d1f28d749daf2fbfb7345faaf65736d4ab2fe1f00eb304977ef4169181482a1682f6ff6b5830570b1a02138fb51566f4afd6141e32557ff6293bcfdbb98acd42516c017a77a5e59a9f6d887e67f2b770df7e20f24f136b7c21a9ec006394d069c8f1c73b802e491f2d2c185ce4d35b6a602184ef3238caa5934edf40455bd1bfe86ada92c8634b2e6593651180f9726255cd97e2faa0831cd92e284aea0e1d0a03b615ee9a925151e3c25b9ee11c75abae9799a04a8643d69f9748e841d2864cab2c263a7cfef936b904a0ee5cf813693d8a4a9152e64fe2ae6f063305e820d402080f7789b7775aba55ee680ee853f9f5bf2ccdab8c06fe6a4d884b5bcc4fa82dac8f56b5f707d77c1f4c3b80b8055be0331dc956e54503e247dffc6bf5a84fc583865f249581af6f8d554e11c54393cae026a5ee93edaa0825f9dd2b986c84b4460d9729d0332d56e6b7b073a02aef4e7df07a5749f8f0a951523bd7dc16615f73327022a8d73f916694775053a73113d1674a3321cc28aa1fbc0370b16f72091b02042247cd8ad350a3efaffd5f1d707ca04246f4e773e9a473efe2c127e3fb1e09552976c8b25e181d677fe7955f8acc3316b4f5e235083161532d475742ae3dbd7e2edf068f783dfa86deb54b127b38c8bd6ac494b8125555f0009472b72541787ada0d1016829257c3d8dabdd1ef64d40fbbbc7ec66de0ef9d778120db54c2ff3d88fdfa17aec5f3ca0ffb3cdfb5f0c12973a51c0c6f469f18de4e49d95034da152527dbdb8fd80832f6f4474edde8ef8c737227a9e93da2408f0861508154498e101f4829f44701d55b38d55c854e5040fb4b3d46b6df60621549e67ddc40d0288b843e3daf5a7dfbf9b11354af209c23b0a88dd41696552db2a3f6bf254af8bee1282be46c1360e540a4eae9e811c2c56f29388eaa2bd16d1892b32e78b50fc183693ada7df2e9732a410e41652b33892a1c9eb45575f6e86eb27febd8ab5b36cde2c94dfdb8945c9b9e698a223f59b3ef1966101d2a21c43646f00a635c288188993531ce589ee6400da73ce284ae5cac1a985c9086112d4e1b8a2464b71ec12ec2bb31e2e972be564ed7f68c186eaca247e4113b3c7287cf9504360f8a4cb65d4837d55743f6d14a51a540688da34eb63dbfa195bd7dfaba0395dd8e1a2e4e57c2bd812a50b7c1de9d1b9d15b614e1ab6341b4c6beb6055c49ad5f72cd616554308eeb57b772e32d7d90f2326e60df6d9349f182176ba1b5cbf7a93312f1868c6fba41ae93a36528a0a1ad1fa8294394f258ba1d2bc7f30e9ae20687328e59cf7e1088a2c8abd7cdad5bd3fd17b9b5643283acc27391fb66dec68b53b6c54cc7c334d1ef47d882fec2da9cee289c639845c8dd58584f4103e59c786c815b42f31d6599685eb553a481a0fa1814e48840d04b6f0a03ea989841cd6fe942e7628338520504e242d366d0a45ab979727109e41fa8338225e11b971b7c703efcf453e53201df92f7deb94bcedd65a9ec40f9b3a21ce401376ce60c4759795ed8400a8c7cfbe5f8c566889ea6da4164f276c0c09f823705c667c123369e8a8271a3a76dbb5bae277ba051fe2913eac81219bd95d3b6dceeaf2dcd174339a6eff65ebf5f42e2fb566aee290733f25ea338ce9dee658ca7dd6bfd3218d6cfaab943373f3738771f7fd58f6f22e2762e4dd0003f4141aac153e1d786202905ecd9762037dd8553abb8a8f0e1e8c4708f2eb470dab97b663e2c97df9e14846bb04d8df991b82d869b2a534886127d0c8b8c07ff981b2c854c124f82c62abedf789e87bbec5c2b20877499036a6c3e3fa1f5477dde96f2a79a0c9880e8fbd68d05dc91454ed31e63a5fd448bdf8d08dc7f85cd419160e2142e6cf1c74f24d962793067e3284eac021a6a685f788e96e52bccf1183cbfce7b32354742297a86dd0a608e80ead63c8fb81b63c297be3d972fb103702f37e4833b8a8e3212e8c282f2497c45c793bae0588c178fd128a1f3207057f0a83b652e20a9736484c88c3caad170bc6ada1b201de3a12cf1d6455201d8b6274dc469da00c97303c89144c005eb38d3a8e9b6173b1d8f30c2da258c3406dcceafded0f00c433c90e2fe8ab221b966cb81351b8b3cba464cb7acbfefd2f2e31fbc33bf07e9f0a5eedf38016718aaf533e7d4e3ccf4e6ff8f68549f66748d9a3e8b3ec8578b04e863a931af51e38ab7063e3220b0b431a2c7c57f543d9f67f1c63169386c7c17be986be57dcd2dbcffb669e73ec30d390555f79e6df1baf2173376770ef0d5c9a4d02079b4e4a1bc23c9a97198090158b1be6a61cd613b1b823b5755dbfaa4a1fa00a54e1ba2399554bcd787dda3be0c8fd1f2d7b4be264dd5c27ea4c00e119ab0148b7496adec6a02f744323926e74066376567318926e9c35bba0715c4ba8c43c48c93c06f89086dbd8a91e4cf0fb84a044690441a25c4780b2114ce638848938d2361c553936892412d1a374198ba8b19fb5a71868ade6b3c6770b44b4fada726c1cc8178e49227d521ceb8c1c6a3d4b10211142eb487d26e8762504e7970328f9878073c80914ba89f201290fe4740032bf0bc9fbd66b4742527d90748879add29130c14930287aac52c4c0835becb34c8de16cd167321d14f06ae5492c3c4c50149755d22a2b6d38dad9d26","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

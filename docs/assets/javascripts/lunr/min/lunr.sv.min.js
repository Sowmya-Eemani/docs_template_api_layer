<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bcd274b30d6295a4d3ee614bd7ff414647891df0b62831c22489ca44ee78e770903bbb5103788727af9b3e734374045dad5c07b1b421bae2083f5c4c4bd4d2a0a33251462060bb397ad6a01d0d62e8769521887694f055c7cfc2554bc1ecad7946a71e5e3be38dfe84f112bc641c96381fbe6f28a66afeff5bd1a14785dbf5299ae32a13f7d4ecd35a84ab743a8cd8c9bc5b29fd843659a51763b5af25d515b3f0f596d0aa31584e5efc1efdac58a0fa5cef0f0349553c11ca63a40cbc145a0d9e105fa783cbe3dcdac9252e08302727261d9f749909db45601b39218121aea194dcc904fc829e1c4c211349340c0b9a6d4d9fb1710ac63c39c4fb620f072f853f50d3d5688ebe5c2422d48d20508efd3c9dbd1c96601614c130e23432ad7c379779cb41b62ce8ad9f74bba3d9047f223ae871e328256b8b12658618a448e832f076c3efb4d84470ac9130ebdc68464d5a8a6723f03815a2a871f503d19a1d07612868e99fcfa9b97d8b0faa1dc073acf4d86104364fb961d300be0de4f51bfe873851d0c0d8541dc9cf5eecb6cfdf674f1f655e29dc08bada408b4ea9315d1e696009d3e72e3493fb6c6b6cc69ca23407103c048cddcb322819c23f9307bc96d9068aff88475d247d54b27de3c0bb2145b24b92703ca8b5fff264d81880b82df944de0d87177cdcac01cb06318cb33397e8a1064b0b2390c9ade1d504f14d8540f36e2b0357085eb266584656f9173549b225481e64e6b24414d25da8e74431d75b21a1c0fb5843024f6b2ccd68a53a7829911d89db54d63114c823f0474afa9ed885b40364b81ad54a558b06b09d9f75625159b8c8448867b9d0db131a8f76121c70f6a1bf67fa80a33955f94a9b5b5cf7e1303893cec256532e5e28be51d4f019b4c5610ea3f556b60a405bf6ffbd3cded722860b3cfb28a96b8f92bb19a35d8f4fcda7ee4935f15309e998dd2ff45ef09b46c6da5209ac7284d2a06b1fb698c425a8882b167189d31af86cb1e7991559847b76ca4034408e14d82a8ed9ce222b2898bc43544c2306b2da27f678debb4ae063262f63c59ad1e95dc50031bdb4ccce8161af3cc36d238503ad7b0ea032a91b276e86a736df344407c5d8f2000533533384c8163b276c49c2877d2b0c5fbc623e798271a5998f52b6536860905019c27c0a3c4a5a2f01ebba033c689e07b01e01cd8e9e8632d681cf6fe6acdef7113de6c4c05320d7c6bcc58ad597a0914059ebed358c7f8f1d6837135d9bb8e53145c9a65160b5675c45cb6cd32e67a82b8bffc81b06cdb27544aff235e4cc63826fffb4e232f74aa1b3058e43f053b0a791a452658511814a15a04dea62fcea322e10bef47538dd6211f63d8c7eceeddd1945fc3b7cf56a80628eb35ab22f606fc80c6d1a83b384d32c1ca8d053580367b2b2f0124f60ca69525711ae9e39d771888dba858c2dbb02949b6eda63713c57987ffde4782d732f689c5d5dd45d9403a5332af0b104686451ddb7e02233e0fcc844f5891555e57493c42c7c8d6ec4505854bd5994fbe15d9a067ab99c913af699d6a07e43c2d5787a84b4e602b7e2f2eb25082e5d6c129ccdb5f5ca7de2f08a703af6c8df56b49bf8160f6ad6bce05d4ad0d461bdb7ea42739183d35888ab81e1b7e5f8a54645f24b33eb1257765e218b8c9b6b345d9c85f613e82fa2bfadc7894a80c9947ebf30e5d43472fe34c0cf7f7ef6b8c05349d99aa14806ffa5a61839a208e4f7455632283a78183eba31cc840ed8ec6a83e4ae4389f5929c6647069782e0191c157cc74adc1a17a5823bd267237446beb5037359afeed457af2f644fa9a45a423c88f439423cbb4c7904706a6cf7cc63c6b8c5531fdb055d58e089102c5c546b4db4df89c590d753968afa5e7bf912c64cf2018c22166542c18f7f300b0d61022bba564d987e2725b6cd84737d4d933d14150107d42d57ad2ebd80a8f07f988f0e91381d0d4a0cf0e94ae214416f1c7eea3c6f6e1f919a555866d147f15928f9542f4648d607d943f6f169aeacb6548c3202f1c928018c456d49f3b35e6c15528f860d774e812e4246cf9c17b487ec49b119510be32b1cd867f09b4f297874d1fb3813a4fb47e1e10649018b8174f39555da787672493e7eeb319d39bd685090120a875a1db936b15c11a502f3f804c0632ae3e4a6484e069054f6b4dce7d1d13dea1bcaf387692ce4ab70391e108f0082246af58ab7225805a300f4b645c117f1d33be7fda81d5af81cb7988bf1ddc84e85043b58b78ce7d39659710bfa8ec833d5dd29c011c36282620bba41cd084ad29e03c0c650b81c8023912bf37038cf92d6a14e59a9f705e68fcf446756c00c4bd4705b429ca6a5c7a8a895583db2b97f54c483f8582a7c44a7989b31b77daf496b88e96ef2741dab4253b9998f982ce8804b1aaa1b9fd43c92579abe5aa42174ac94d0c4a8365407704397d27ffdfa7e16196effa1c5b37f7d079d0d2102e08995a10f3165e486574270fea9f45fb19d24a3595fae534cc618747219128f4294a786af726adf2b820a246507b018ef4a541b0882ed1941d153102bcd359c3a8104ea67e4801b787b3230df36af11dd2adc917f817139856b17f7c3b7eb684d99e3154758bbc329ea1dc1019e3b8108f19104ada9a05779081b6b22301fc2a0c74a91d938ef0abd9709f6a4743a959982657eaaaf3aa2a0444ea7e71556ff656d541624d2bd1c968f7870f06784754d640dbf74a07f0beb8e8f955fe4031e929090784b4a839eda65ac5f6a01bee3331471ed37edf623ba0868e56a616a864b8aa5f82c5774addd9ec75646ec87e3a5a11c2b55f1d0cc91c63b8fdaffb09477c2609c24f98adadfc0dcdc7395fc2f1bbbddf538686cf5c3a27a80133d0da58e5a824fb1e165c9917c1953d404e262ccd9f326cad42cd597e66afd3e5ae6e66d16e1654a6a3f03950bf00344d7d427c188de0615fd1ae49d6dd11166a098e5666f3aafc4ddc46e2fc6204f22946b435268ca3880884e584d9205b1d53992e3d1677191876bfa1605db59e7738fbbb835694c478ba65ecf95b9f9012d599633990962ae1b977a4ac051ec71a8d7504a9997d127691188a66a301b2801e703ff00aec2fc7fb75529f295311e693c8a4ea0a6a2494bdbd08cc7a0d5acb9667b0e473066b4592d8bfd7afcfadb5633f613974ad830948681e411c8d41fbe33771749c7619a3ee1f5e771fc97952dc8c5d5488ae8652117d6a7df64131756dd0c603c315925ca8cd01f4ea58d65566d3855034390ffacf3c13f929a75871f8ef4197a720edcfb99a0bf28aa310dd56aa07d2363cfacd5ddcbaec8eed9deb3560706a22cda4a8de9ddee6910d1952ae1af09f90a9abb1b51b9a7e088d7b0092ed5ca7f19aa07d09347aa18e223b9e0c3ccbfb3c43909f2b83665ebb8ae130f5903c89e5490f8cf3ce49463202229c4ae2b744686172ed8bc6ebd650e56d2978da13d388d828f529414b116e9acf35f112910bb77a83d5bc94a1e9e2c8120a1e83daecf3a25c2404de9e94fd28af45d9b4e12826d80b6b7f7f29003be7047baa89eb788761179e7a68d8a327fcdb11c0eb266f9cc75e7d8cb5a7cf30b39b7d760d5cd65e865232cbc7b5ab84df2e5315b7fc87d2436a288e9b69a2a0c1a469b197c19a800264c65e724269df1da941156dcb787415b79c28a47ee780f3fee5562617e07f23f43a4959c7c002a4b2aecaa0195352e64b47ced022ad0f2e044f9d88dda849a5a266f6795a06e9a7a4319bd6a357b8d01c77933caf511e2c4e709cc5f12f24a9440bd09d4fd6d4037d866b8465ef53d8e05614e30b740beed5974363bae31c871dee1f92041552fba40da77015f864aa7cdd8e01358d5759cef32c49d5de00fdb56400268c603c994aee86f1aeae78a21a13f78acbf60dd58babb067eae5330f26e43e214bdbc1b3f89a7fe5a84a9cb729d6da58108949ad2c6a3143651e5c9a20659505e3a6118b47586e93940d4017aa6634a8e72e49b561ce80bb3c17e7c886f5f83b9e760685203fb7ab127a7c2a51bfaf16507179b36af0734f7548fe26fd0f63127427adc6f024fe121b0bbc23816956540588e713013044973cd616c75b178aa6eb2186567f896e66b10143a23e41582b4819fc39619e722989bd5d654713a76592316df11c477b3b5c1dcc21465e15bc9eb8167a55576b1d03357adfb1d8fc7a65d8aace7298db3e917256eaba48bba3f1c0b1c347e23324e2e159476b8689ff7e8fa7bd87759d53f8d278421e8c2bfb732faa4c408a5b0c33fb5e59daaa633fe633647ace0bf77a88e41f75384316058164ab30791a7826da6253c0dab4e95e1ef4dda753ad45c4c6fd58fb551c634839b91836f7ac3ac8d0812a7c9559f666154e89469f1cc8f956a7ec8d54370a8b8a7a379254c031e727cf0bc6454c17683bb2c534f076cf3fa89f55cd38686c4b0fab5cfe3bb1fb02540bfde648f6097dee3f41c14cbafe94e4bb51e1082c943596563989e6c13e52584d1e88c88d8e7960b10c6113bdb3c7f1e3c0621ec14c807698ff5853e1f1bce4c4f89b9ec4b2eda5b20464839885a9411c2b31e7af0f5456b42e754aa8e53bdfc8080c6d4ef1058a29daa214a492c4dbbb8e3aba4c96d2011b0478cd83373ba5ad7e4dc275d38f722d9e4f19e8e0681bc5ab8ae273d41dc33e8b2d1a576af2287d08ef89a34102669b9c2001fc456cc3aa749fc75a6bb36a284fb08b588a18f4f2f038412761002b8fc2abb80961ca93b848a677a65f154b61c6dc38ff11b5c7fff6c392c499875fb030e60d87234029806d94f84ee1c70e5a725d5b689e1df2be7201e43f2335acbf0ecb4f7df6704ce721654fbf6bf6c0e273e777f0cc783e901bcdec038363c8446e97061e08cfdcd6f80f215238d550afac29186b3596ca1b104c6fed6e045c8473bac0ff9450b2b764032abc154d68fac2c4d8f7f40adf7f29bde7f1a11d968d8c5680c5319ab412066d8215407c8bfffb2067e94912a8c3c242f5be1937c1d47ee885e6fbaa2db920861dbb865dfada59041f2c7bcd40a79e47906d614a0816d9e355067ae5921d17c44996af8c404b91a8163bab5410511525cc46cef8b2f172b857bf5bf17fbfc862fd6245ac313ae19e4e1694ea3acdd71ed28711db73f9559cce854ecc7e2a55e23988aa9251ec8db0a3c678046cc575920dac114404b3380c2e1d912d8b4add375b1d9f7e8c5740a53c00604766e67058564ae487b040fca5cee3940e8783f47f0660b2a1a1ec1b4e9f85eb06fd435dce744cf8b34cae3ac64dc492db6c80c6cedba5db2d8355a8884531b324b784609831be18322ab5e47a6e4eea1f7008f57a72319421985597d9608f2f37d6ea07bd0abb0710fc444a824b6f349a72b3db3a471fbbab161c74c6a6b9aed64ee5e0a8965c717c5409a502274b62938106799d3137466c9dec78e8889df2121e200bde22c880d5fd3a11e037be89d0a5a2a3150708f27598622efb03e42af3401dcf01e77601e71318af765999d34c1925ca06c5bb3d5b974776d04bdeac12f6222c27e4ee74b3223f8a4409ca2cfc1f724af55c64cdfc4fd52838df2750e5d97abff9c888be8a162df37ca68c6f3cf86dee6201f150648827049e8c426df4f4edffc00b265aac4358343d47b70e22727ed34dbcb4df44828210cb8aed9e9b8a336ff29e775c472913b26168ef6b138b3bc0f79972e290796a2692fd20500d1ca8830953d3261a0ae9f94ac2a02d26734702e44253a35a1fdb9d601c4ca8e45636fe12bd25105667bd52a769738765034f8cb87fbea8b578672fd29704b80c4982e32ddfcbc4ae4be02728f66f9f9b38320e0a9af3f437b2e2fcbb24e601c28364378d31d8a52f77d8d84c2c239f789b8c8aea8a29c52d16f8a55569e8b45b686939c2ab60f828b4aa8cc6364db8d5a9ae11189ec84cf356687c5c0a8cdde2b97e458ef2ea0bbd5f3f7e48422aa123eed448ac1d27719eaccd227ecffa703e8fdabb67f88e59f5a66cbbc4c02c700d2f53a15f4d84daf7a95c0e2842baae803fd92fefd664fe2b1a01b0b2e878206be2ffb7d12067fe60fdaac377fa0c16a9e7f0dc287c44ddc9c0ad8eb68c9dc244e1c8103bb5d58c5e4f1abfc2146a0e31191befcb3fbe8ce63ef5d9ea29f3624680bad7e06491e95f95240a2a543196a8fa616f672d7a2dbdc052e8fe5596147a67c2ade2e781290f14621b94ccabb34a209bf4c736f72b8a5ef585a98511590f74f37e9e35001e0b36afa56c22a9b0953df4fe52ff993478107d88390fc5e66dd8fea684b70a346af762013dea36483f7397f66acfdf367bb76cb286703f5b0f48042ab8305c1d81fa845a35539cb046e38e68cf8feacf18306b9bba743a969a9160d00424b0c4ba4ce360311cfabe82a34e280d30fef8364146d6e30fc93257dd93cd462ac45129bd70202","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

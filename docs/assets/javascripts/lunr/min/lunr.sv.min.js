<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f91ff20fd7d84f758155fd699c36fb3f1dedd208a0444a6d2a2e2a1bf0686892cb9b7a6022f337188442cd0642af3daee26d0f431f7bc4ed0a521b5cfcdb6453f5a7265e626a8468eaef0f69ba527c8f03e9d28effb6735abf5a486e0d5d40472f4acb4de7630695fbf681c26f40da494802aa4dab5615a186096b00f7a2021c1c4c384ae746c82fea9979dc6135400bd6cd9bdf19ccdae2a03c55096c28141c59d1e6422bc6ac242e686097b75f75af92864be640deba1ba7af54ad8cc490c610218cdfb0a741dcf7dc07d8b1916c4169891b3add289e158a526fbcd1246531dc3cb97fca95c4f023345323cf09ab51585cf5618a96e0f98dda9338c924d394aa2d3e43ad404a01b4728a2c741a26018d92552246ecc8492104509222211c0f55a40c0c476f933a1820e4255abe23b96c80f6b138caabf608e5e7d304a6c3ee5a5575a41cb6f35be08273a31b14cb0aafe3c85ea25925833e6d8db22ea08a562c8b73db5e2df6a5b0552a7d247f354347f6d62b632b60971d4b7ee4bed7f483b542fca49176362f111b0164a79e6f46ea9dcf2155a3c38c15bf0c0a81b01f1b2ddc0c592c5a0570e944b647ce0648c771022160a6ceff53243a4cc6469065896f0dab7436e2ccf6be52f00c135fc71fac07b7bf7399ababaa6af87cb89c6e756a534b1e787aa9027b0e1d6ea2ca045d22b8ddfc69d84ac14448ff33926121b1d82bcaed490fa082379b0c0cdd3acb14bb529b125533617a6ef6829dd89ac79a5519f19ff8f72e44b2c2cee67aec3f9d7e0dba19444530b04033ae73eec9f233d6fd8cd8407fe65ffdc7c8691b93078cbfce73885b2461bfcf869af235a4e24d3086107f19651943c9ce5091c4cd9e8b01ecd0f3c5b93c06bce3d0d082f438aca7ddb7a5bf75a1197dbcd3ca18c64f4f5f690bb0c1929a07174cd82878938ec823151e0e50186e3d475061c7b864e1552f005a447e31179c743976fca193b996d1c1c2c5b5ec4e206bdcd8fe6c900ffad0bf3de7d1745ec8c77134c3dd9707fc8268060c3f2333b9401b8a5da6a5cb0bd8f37c87225199976d3b56723d79dcb30ed2e732e4222217250e44b98b4bd7e92af23ec0650acb9ca75497ab402593c661b412bb0f724717e9729c5e94decfb5e7412340fd1a02f69ba9d8ba29f26405eef0327d5777d350001a17f4ab636af0d9da6b27848f18681f513d894fa8c88f5d2f287b6e26e4817faf08bfe44d448ad4900926a3e46bd88138cb1fbb6a5b73b0d2c1198403959748b8691a0cc6df576eb0051b4af0e11d01a5132c7ddd4a3d0795c138fe680b8ad790745e2b6ee0024c3bc8800434b5c18a1ef8b20201e7d53b5de49e75bb52c77159e0c327faa278195630fb11548a8ed68f16bb5812adf953e0807b4aec78d5d60152a7994315d6f82a1f3568d9a3987ab6566c78214f191a352d740e54303a58267f75be35e41b255f76922a0503acdb9369d1aec7cdd8a33552357cdbef1c0e4919b71d45a32093a7c05ab2a680df08d2fac955eeb58f17bcd7c7a91a95593ea8005b068a2701df3f38115b7bb6f12282d59693217a94455f45af14c4fe837b8d6dd8602620980462309f91afbf9136fe23106e2a0c7dc463405642052d88d655e880715f92cb067658eb5bb52772ac7512e11c5659ddc1519b84bad4c2ed06745eaaaa759383dfa5ba88a59bc91e6534ee49398681bf23954cf4dd21aeab9979b42f99fd36ed9c2793f40bc9717b65c6eff42354f4d03b3fc6c5ea759820f8ddd9144199e38d123bea05d3b8abe8ecb612d8f64b8fdfb3f153bdd7113dbc6118ee78cb9ce5175278de2c7bcb924dacfd687b43da228688996ea69fe1ce9ce63f2265d3e173d5891a0afea79895efc53d882d56353da4c1b92e80f60520741a4c2f69297f584add112095463adfc00865b25aef2f29a6fd2584e361680433921d6f640ae651db058bb582124b15e48199babc500d69296fd49d288d57debe35fd5ba03bec3abae9c363678ea4a059f4e8733e0838d66dcbad034a5dd7b8aa5cf517d52ee8f8bfcd487f3a059fea221de05c579c07cc14f93844231276c30c8aee0871fc3262ed7fbabc19dec94f9359a3949fc65df8bcc96c42c506911a43c7385b13a3470e7fb6647bb4df0644bd3fde103a1f34e114211734ae6982aceefbc54f7acb98b375bdce266362f5d3270872092cde562961db40bd70899a750e01f11a2ee53b4401418762ede2b36496b9450b0dff1f1469231cb20bd667aa04c6072140606162daf03bcda08258043307006af7827eb913396bd39c6ae95ce81f66d76fa6a1fa96e11a2c24b9fef46026b850ed5d6954d1378f8c82f629f168f1ccdbf69610dddbb1abe502ebd4aa5a599489b99c991273be5b9f82b58e5573a11c89ddb52e467eb27b62ad77fcd8360304570ccf3c56e61ac15355b9274c75a0fdb975a3f993ba74cd06e0ecb4c0ac15cd16347c72a4d8d47659ff9157165cfc1b80b22b8bc643ca69375e2f6d6be519367955c299732189d3baff0ecba97be78c1b8def1847b5460bfab129484cd69c23b6aea47134e606af9d2d71e774cf6801f209fbd3895c427a483cb9e9e4a89dfaea52d54a82b6bd7b5afed8027e4c4d4eadb237e1c7bc6d59d5c56b99ab3895ce9f4d4872ba062d35ef17484ac8c80fc2489df2dae8a10883b4679f4e077979a5439713e8f01ea75ea208392fdabe660ba698f5a0da94b7cfe6abee575a191b95768a347aacac14dca833d5587fd1b1a3943e91508109344d1cfde204a75e2e9d80d8c9ba2191d6d43985a854c2130432d79caaa595ef0b254560e2f50a3862544bb1719aaed01b9f8cd2c57972786c8a2e35c63928e07a369b00172045c0d9f9a201389b6c97ff64a312d06e975b002e8a40b7316ee14379d517b357fe4fd937d2ab5cec113e3242f0d7b537d3947d15b5cde75960d1424872d96559e9402aa081c1d25441711a7b4e692a4c9a379e99f11beab6a74170b70d74e2b720289a58e8a39e7f2b9d5d2e08fbc463fb2b4701a29aac6dca3942d56199b12d1da167a33b7e4dfe76c2863828a28132e47420b1d81f0c84a97b3722cef8b80757107a24ae44edcd1241bb6e376b1c743ca34ee331d5a7fcc396078e0b97cb4490a033aadf147a631c4cf4f9d568862dd9bdd1248ddeff540538fa624e63e50d9421303fcc7b9f7c79a5c519704b5e38fdf2c6b1eeaf029c6a58587dfb23fd53c68b829e46d7a2c634552716cbcbb10948c52d91f4008cca474f3d5bea11a743b698196eeaa6d68f1363826801a1560be659c2ac2f89b32bd20eaa215c8b2362fe1a0b3be3c24bd1795c739dff1192d44156bf4cff0648a8233beb8c6d507d3a767f1a44de0440b9168f77d116a5b2fa471ec3422d3d1b698a09087284be21a897cf8c5cea335c56e3f02600eec5a0400364ba76a36b792ef081c5059d2e20728dc4ad1da0c09138cabb55cab7a40f90a6028850226e42ca8a2f4af51c10a6f170052f681596caf584853d75b1313ca6cf310c432e0b89f9ade6e90fe85522f5d92c67033d4a7441603f9900a13f6dfcf4ae6ab3db9a8201c493d43a2044a00aa3e1353978830c95aacc3c9d3fe13191d473d38cd84b0e25e967310873ad9a797e811ae57f69689ba9b09d575f9bb04b397ac9c23f7c566ee6ad4893835c992e739ab6e6df2fd6ab88790a509e269419fcd937503f2c04c53e030150aa4f2fde8158c0a0f3c1af5090c0680245679b36bbeda8a4f7ad778c57b7e7a299c35a8d0ec94d64561138681e8fbec81627abd687c647a406fa67f91f79efda126a864faaabe185399b3a853d303a489aa85f75bc2dd89a0426a186be8aeb184de62c68d94d21597df3f3f9dd76b440e2820b4ec28566a2c7519c5c2a721f391253adf6b44042d6dd2885b334d75e648facee2fff35243ea4c1dab8b0e0e605495b7a03c9e61798d85f0b7f860471ddb1aa38e493452ab94e471d521544ed992e802d82015c87ad3cfe30684b8fa808412d3fd1e1baa9d82d399b6b0c257ed3997eeeab85394d78ae2eab915729d4951f48656e1e247f569c99ed308388fb01384fae1b99adfb190e24903fab84a65bf86849f0268572d249227ea43568253ccda338133389ef4c97db5e2f81d53838e8dfc9eac199134c97f25f50d5ff401b6e86b8fa382bfaa9af587e5aadc3793437ee11713fe91dfe83c5a97d93feeae55932581368a265b1397ced4a6adb97efcf93186b32a17bc39dbb67b65a2f1c72b9019d2ba8e586768080dc0613806b196eb5061a44f75f8437ac950023de976fa813d7f55c07a541c750ed01d0a570f1373010dbc2281a11505e002967dd136d332034f0a3f3f3d4283a672393d6a003748ff7bf694f3553876cb6ec0256fd05a78d1507a30ef910983e036e343fdaeeedd7d128ecbb85491259ae42dee0659cca377adbf8f5f8c300006f344ad00b65eca480be6f63cc735d0209f3a8c6e1555ffde403e3d85f0b134cbaa0d9e479dbaf64b85134e7c3e2d15a21ec36ecec0fa77912687d30f235d9529ce2b44f483df22cd0cfb2f88b37c1f4c64bfbef50fa0ec41968650d5f3237f1b4b542fa9d063a035891129b2b40b9c4a66f9224dac5795c3d4100cc9953702beefebf2c735f9c4afe2e8e6861bb3f7cb1e5f97ccb9f87cd68a6f8e8c0691e83bf332ecc1822104a0aa8cf325327f8745143a0fa44fa69c5f94d2553e7bfc63792ab6b9c7313ca8ce47599a7039b25b74aeb0e075a40b3d76958e15b1b19d0c4053971839ac86ec8a9de10652ed92f41edac1a6580a7d69970e3a10ae434add3d441f2d717c70c00d3391d19d1c642cc26286cd232aec497078427f734ed7d25abac7e8066793d924f7e71177b7f64d3e30487782b692f36d99382c610e0b4d7c839a4d5e11bd2d2b1ca57b1eccd378dc01a7c0531f91ba060e3045646bc32ad26945102dff3ca569dbe0f474edc110f4965e8206d974a1f58b0a1cf85ebfdaa9f2bbf270eaec0ab3416360b79003700a1751e24b707f3b0631b53b102470a56c86e91c9edd07e75fc033bde1be7e7fcf261236fa7297286d8d1b25e1ecc2eb10548b76b6c3b9cd845ee897223b54c8237d4888685fe87f98dedf9746cd2d05bf9c80b4b564b0b73f74433f4013aa14bf2ce4b1db0fbd360052161553a490d3f118d5b03fe8cc2aeaaf0ed3b3944ba894a001d05d0ca26f42ff536dc1493a2985b0ca4ce68145f437647a4106da5d866fda82188cabc5bd3d3e0f8d9ac00b2c8cde2d701a559df55151ba34348708e259a887a5a90a2dbc4cb5959499ce7df971f8393b6221a3dbd169607e96d9c7430da4302dbee05f102aaa857e711e06a0618a6928658aec9b3a1c24323f422ef1b0def17e7dabd40710f67359526f689f3e1e02c0624b1292adeaaf44201a4e78acbde71b2cae8a48f2ef302acc16f3f16def16e779d0d8459f5d9e66309f1825ff48f5cbdf23fea11f99362fef0a3614db84c465c523010a8db5694bcce416696828a0fed93db6676410457ccac96b28b20f259af2322a33e2dec79007cb5b7fd5a7e89dc679b4a3f9ef7154a8bab77b50e79e5ecb438ae7e086d797b1935919a11cdf6ceae9949d63cfc9f250e9b0ad43a1608bd5fb605ad2a002ca7d65cc80f6f7fbf880d37fd5fa77bf95b8447851508c30003646c2f3c09742993f40c446656bafb767d2789b616e4c92090d4c7fef757b7f2896042a4f96b74bafbaadd55f3f230b05fe7a281a495e4ec55c7102c990d5b46c3d61d4bd43d06ff34700335b5661a8b0c3b87e71249a3c008a78ecded09cd28eff6a5a8f019f4fe6aedf72c75b2ce84958aaaa92c3849c1bc0eeab205cf1499fa493aba76cb4f30aa2bc8f08b1bc7533ec9458068e8b4cdf4c7cf00d49f360c7d61b3aa456524e29885ff88abcae8642c3190ef851a0d191c129fad04373617c021f16f95c6a7ceffd6153910598b4bbecdd145283c935f1171e25f6756e44bbedd9bc88ce09c4cb576c847b2b4bfcee6b4858de2ce5886b94d648023af595459ff4cc17327a5d5034148a9be6290bf9247c2b4e359c1061d8e1ec50efa7e4d5f13f6a1f169db0d723a02e4eb93ed2ba47e2f7818a6047d6ba0afb0477141b782a28888516fe7f9f03cd260cf7c94f822c501280de721f0bb3dceb67ff82ef6bb4ba4395e0efef1563eb74a3d0a3f76ef8fc2fae3071e8f6940ea3d87d046d17161316b1fd42f9f2df3ca932ef84457308f7f8547fbfc2a2cacf0ba574c6a76a4c4e17748b2aca567597bd59814b820041815e505ec7bb53168841b337b59685c49a308ecdd5d02ca6fda6d6d9d782afa4cba609d98f866df8ce9f83486ea463d14ecf0dd988874a26bc70956acbff10f536796afaf34cae69749ef3b31dc338532f6e3176bbf0a283fb726601ed084f0065afeced47f6952b4fb5932e73877","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dd8860cd5bc3d1136f60d56c38832b455a600be5fab233be7822dbdce73d3c9bc2986722776ee123635fe99bd4dc3c0d95ce38d4f7ffa15dafd25c58679209069fdb6614771672a89f11b85c5f96c7fe446f116a885b627e0c8b28d4ec99e009caf5285e88c9d58805d3f055eee620b6c738de3a25beb144b9dd783ce9715a4e1bf7a070aaa623843f2771de9f4dd4c53eb656e3c7ab93c2a3f9d401a018608f016483867e27b56383511d3e97970515c19b09b0d3c189f6aa241f46ab8b81e9640c33472a6f78b39368386e0a3d2e9b142cd85ee160b27e6497402a99e6d85d24ebb7310ab660ec2f8ad7034ba6cc8ba26d08cd6bc53219e105b9001e02ce922248fb739af709fa92a349f4e69a1eaf8152f68c059bf8da3d30f3a2b97e3e5cf858f5c5c702a7bc2a740182f4b5ea24b53385ed6656af54f92461b686bec0709ce8af478b1a5ef4abf95b14a4da444bc64eb7cdf46584241b919e79b857b0e6eececfdec07ed636609d968002ffe640c496becb8edcf0e0b39981c127e9a483650b9c32871730534c75f19145cc42feb19bd64867c176d71855969be60d544517ce40854216eaa02ea659d4dc8ddd7be118682e0f01fc219291f9309813b86543b45d545fb09e281f947b1e064d56de7749c89779a9480f86d1f38a2277ded7decdac3ca2b02982eba7324fc6b594c704fec8230278a4d1af2c34bccfeca046d579ead71115caa58b255f0c7707232660a57e29763a9cbcb46a6c18a05037d5b52c9c981a657af0412860e06d568ca9c6cf91741e60ed4bb6eef8991cbcc10b2d1d3d2957df938f1746e122358eee81cdb30bd9c1e0b2b31868a619fe1271dc6e95fad69bf0386b9967c613d39df06ff574008060b28ef9efc7fea60e27b9bc14ef70f0e57010ff8ecc01422a9ac4a64aab4f0a7582bd88000c3287ca8cc1808ab5579e3eb90f2e92fa5a1026ec15de2e6d8ea4df549969bb247a624ad739b59143cf5a8ffe030faa5b345270ec9dec21307881ca871e932e0ff51012226ddf42e59d9d8bf201d2d1bfe067a9e8c8750532291d2fb25cff7a778355b5c56fb7d009f555f76216041fd86356a0ebfca013788e45a3406d9aa88b4766d6484ddeb0f83a41c7f74546713ebb8bb893851e1b5146ece1257140efc40865a0c638f400eeddb037cdae996499bc6e437409784d7a7164ee6dd181c3a5955b3b431c1c0478dc478f57e1836618b9752bdb11e9e32a615ccbea8ea60e7fd9c3e7399af34ee4b7e519cc4f425528aaf8555c870347ff6f1ee4df4dd8a1ff0355d0f0013d2bfa36fa0288c69e2973729cdad795862400401af72b2902402c63771c2401fecf64811866ae7781b6dedebc2c83d522a36231dc5d4dbcb1e425a98dc9525d2a934b8613bd11febd70d0fab858094d15a4533f2aa1170311560e3b3fb33d8d7e7dafcaee41e6de2f29fd1494ec713d7e5bc5117cbb672ab7e6de31fcb1dd658349c2dac38a0870cb7c6f483520c542fefea81a4373776d0fad530bc6eccf386d047740bbb08865a70f3ad151d589beb6fa2a26cc06ab7bbb02425d385b89e0f0420a69abf14170afc92c2f15564c52e2fab420e85b896d8b2db131c6ad38cd53e97f40e54980a052916bc7464fb4a0a8c21f4394a864bc9242c433f57c753621556c02e108696024ab00d7ffd44b7e9b177dbcd9e7b62268c85f5d5a32ef8bdbd7ebf7d3b296a37f9493d1ecc29b0e5c843338a16ff6a31234b72d80354dfaed1b48c033049db8f9d526bf914a7c4be5c0bc24b9939e4c88cb2fa24594c6fa1e6811c11fb7a5b1bac60d8d8ef276d5d037a521f94a8a0d3bf57c42a98e8b897ecd548d2f82174ba1dd1034c28796a12995e65b4db6503ff41efb4a744a62da815ea9fa90a3d77ff60268c23783b2b3f501761db0da179811487682cfde6d47b58401cd35d10349ed3695391b9fdeac366d10a7ccb8aa563bf29795cf6aa2db59241eb22662c7112b94bc60e0dde1e4c0bd70fb5ab8bd44bdf1a74d87a3c69ae4d8b4a39f62a69a7092dfad0e3309c20d65805b08ddf80aa2174bc9bcacd08e4f01233dd225dfe89735f1f41a5ee641617e65d1a7b5181b3770610faf8866192e47f7d203978faf5e3b7f1a7dc82dbe6476458cbdebab67839bbc29de7d3cc0218329f4d5f4a4c13635949778508f26839cfa250cfdb932ed700a5a09b063122bafcf79767f26013458bd8cb0a2d6a99eb00c8ab76f64fe52b7555ec6d1926ffb6332d23cd7b0e868c4192f49c172e1547dea387a5514826f2751e810b627c767045c7ddf60c71d636bb65940d6d6b06ad8daa0e5aa9ff07b8b657725a9af7437c36c066dcf737c1351f46045476d70ae0d1d6e7dfce129a7fb521f7487ec75d697c5308648ec257c78c07f7a57d44ffafb6719e013729bf348722768893a539a5de98b3cf28147ff02a1d6490710ec47f768b3879f142e3b30b0e14fb383a0f71e86afd0a534892574591576e2e5827e9868a90271759cf088e13eb1d30fc54de83ceb82cecc70219effb9f0735b142d2ce29c2eb99f098779f2cb5481bd764d3c657e5b2cfef1b9f217739d0f66aab07dd1e0f8d95285e185df88d9ab820fb0b7ac4f24e269ccf09f3b9ab8c211884ca255ac83f2304cc316f96d69847ce81e8e39bc2faf17f21e7bfd87d40a8fd927a4a613b39346409729cda37c389ae3505961e539e2bc6bf273e454a507d86b3a62eb20d454030719c134de371dc136c5a2a11f4fce8ce4a78324e703f828993ce865d12d9b4ff1a458c22abcf485c3cebfd5b815d4ae17f51dc4f9eeb3b24880877a92012b702a9b556b779d6d4eaa7e57ae757324b9645b29ce88dac31c5c9515e38512a5dfeb8134aa4d52f12fc381ad65ba761b3faa038f391e15d5b26df10276a15a16c041b115e78d506a7bb0839197c0d7939bec5b82a4e8483cee8baabc59177fcf7b2320f7b3c32d12c2d631e3ef2183b22d2495709f70ec429cc547cf97e1e1e6903ae08df0be73400ed0609c923eed38620955b861f415883fc7ec136425d468959a5a65093260ad78b3b60946f43fb2cede3232dbaccc2614e9ca16dc213581ec06e43caebea22807e02b46048008ea160bb2e7f3bf67dd7ef840341abf73fcdca304bfb83bc20b2b6d66b085ab5a67545ed17629eeef4c78861b59ae74e4ee7aa321ddf27653fff89d2cef28b52efd2eefa09654978e2714307ac77340033455a638980ea4fdc94ce35f6e28b2720867159fd7530b9eae8361c9556441a71e47f8a5b933d94aaef64a8409147f9862bfd54c86dc0948ad62cb06a7757e2910af159b1f49f752cb331220b0e5bf4488cc553d2c176e6d0168bdac878fb686755b285eabc9bc3fcb628858d26762bfd9cb40336166de3ac270a9cf5642b9b560e8a650ba58c3ea5914a5a0e09b8744f686544a36b3864dc178129d3fe01b84296c21986e804e856969c0fae199feebc9dd18f129103652da5ce0170dab3799eccf127b6094ead7b2e0bdea9b7a577f6d00f06d97b478095886b47f4460feccb2033495e657dbabfcb9b76c01c919ca215b98894a5cdb4cfad2ce8a5349ce35ee4b9df9565933841fbcb3e02e9f0ed36eecbed4387f22d3774ddf7531c466391c05657e31793c5d1a0b709f410bee167a6cf9cc068e4fea4512190c2b1cebe5dfccbef496dd63da52d695f68afa0e8f09cf5b02cbe27b6f2e19be2efe029d45f2b6c0f9db3ea4ea0870692ee38f55f59fdc36249480bd08c265394756a3ee6437e6406dc2e9049b477ffae34d77c3e5eb35f1280bdb0b7e0e3aa843c2a1c08072f9826b26625d98b98b06a339aa20bb2b27f9652186b07b3c718ebc87860c8446536c57574453721f342d67a8ac75d6c7b7b6c6dfee98f697677f45542c5a2f58349cdc6c5e9c67ee01967e7b903fba9ccfac7652f88b8a7600ed014ccc6ad78ebe8e04680ce77e3524fdb06f543f44e0dcde74f172dd49743e7cc3d00b4ec9592db2b635f67c1d435964b7d9aaa331444c43a3d77203e8ec57ddf6176c3aa778c3fb1ae38ec3fbe743738bf568f4ffdf3d3a7e97ce3da9a1dd38a4605a9c128ad0f4c0325b9ff223fe0991f587c0b5144f8f4fa3575b8bc36ae333b2355bbaea1267f32c6a2fead0145cc08b2fd074a0d7122060051f6262bf2c4085116f84ed232570f928c28841e9c9d5df19ac6cb548df7004a4decfc3f1dbd7376fb456b67efa31371a56d6355c1c0328adc98f7ab4d7a501bab1560bd08a92e1e561c421786a5e071d3eb0848b2529822aef55d6f2c7bff209dce109291607045e5b6fcb8507fa3f4557cc8a81aa60d9c7fd80619ebe3cdc1a1efc3e89bdd054b9a9fca6484125b077dde03c3af865618bd0e776239d9083ec046c1bee309e98979761be1ebb21921186076494739d1107e330dd751eeb6164c6d5bdb9989a697c0c1fb5da715086b241330aa19c96fc43bb778ddc8ae26483c015531cc7274019d17522c784b74889eaddca763d3720c8ac06ef1e2bf19f498c515311120287407dde262479545b49db9d5a4ba81722ea58bb88dcbcd6490935d890c9a87dd16374d95545aefedd2c1dfad2f195a76691faf732a9a8dfad830b9d3e95bf8fc7d475bd256f53f4ed008f72658b15beffe54a57f6b0e33d1d7d00af60c0eb07a4d2185624cee078228bf403c6adac347b4db66338b70256707929060420c0c87ba25a39a940e142456d757429c1eb905afdc12ebcebd6b288b0919ca6ba241b6f77b8a31bc10d605647de162f0c49a026150514e2df7b51ca5f18c71c9a389530e57076ea511cc2d54bca92e1fb1034257b0de858ee897d0866426969eabac3eaeeb82a338a4b45e484dfa60cf67f716aed44fc1e4b95cc2c9cf3ca5d0903bbe3f0cc761d8b242d3f284b7818cf09c8e6b0a0da7cb42feab7c7fb4e02d63ba065609646cebbc2586c0a31c8a637da21fecab5f6a329b1816c955c0faba3c4a56affe85622de0c9276e128d9a1271c71d005d5d71dceb6ff85fd6df1d40295abd8ef576a85442c9fa3d09a64057c8925b29da5e5d551cddc3dfde601fe93939e6bd6d53d391958d290acf5648020c993f9d6fa9953733d805a98f8f5158268ed640eb043b88f7a73f52bbbaed68fa7276843d1a4ce5237f915887a6173391e1a557065141cb9bb93ca68754fbe36fa8d0c9ba288f2adec28e99e82b27e855d2ab8ef2fe4467020d6351c50f2a1d7278570850d90ad05bf2de7afdc9f19edab8573fcd7484e3afd3f34a7cd1c20d3c8d2325324c692193fe356c3ca9102ac74706365c99572d0eccfce0620ad01426b57c822628c714423d90eb0cbe966268be4259bf999591a9a4688a3c2a1e3ce9d60e04a787e8e846461ec21c392d4c813fbd2d1d3192684c146ff651fae12b92bda536d3d6b6ec250ee79bdb7a718324ad513c7510d70ba6f1314030ddb0cadba10574596c3a3bcb463c8a970c933376515da017b7f1b882cac4921e0cafaaa1f5e061df473bd9793dfb2f5004476a22b633d6d429b4f5a2406c5e2effbd590da10c7cee427606e42f46f561e34e45ff1a916668f42d6e98845e3a30753abc2254157fa562fe7759539f99a6a1b0b04662b358a407557ef7eee521680a1eeddb675531bf9f4e4a20157f66ec7f70abb576092e443d7026f491e5c6e006561ebbcf653ab519a1397d36effb9f42ab62201db77b7eb73b04342160f2f46bdf15eaa9c7634695e6ffe3c1d4b48e54d4d0c774ec6364cfb6b052e267432d6b3cc52f2a04b62d1b92f9a6e5a1bdda4649e94056bc3c2a1c36dcd37066edf96c775332d74eacaf369be1b2ec41b22cf7cef53da86431e0e0dd0d7d550990557bb2e46c59b5a3cdc3517f43ecf2624d362c1d25aaf6464915b07c545ee2f3292476c4f9eb545d778dbb0f6d72bd4f4a8eb5152d6e3575f21bade2392169f3392fb82ae1db8f3b717664199ba1509f1c669e9c7b7e4c676bf799fe725c553966f95510a52fa2854021256542bff2dcab89c491134a9883be93659048328d4b12c84bf62f0b3157a7a96d6ba6f9e99a693403d0d13151ecc7cacab93e7a65a67d82982b670d3cdf88a0b35c070d26220a3baa708d20636e40d6a99c156b979ea64472d8b29e2dfb66c945a0360fc2950c2a326eedd6d263c5e8daca0b8f1f9ba2784e96ee9d354301b01716801fd293206ba1be6d702d816b41c4b95483fa9fe6832fa2be08fbb767417dc4586d3e617dee47b1bbd918e7ca8d1dfbb5cdc8be727995a7dcc2734b724693d4bd55bc4dcab55f0e6958bef20301b35c73ff9a68f98ab3480d37a7664444ae039b8f275c2fda9e6d1cfacdc9c92cda194c513ec51ee59b40dd1054382f52686e04cc69ce33f2819d9deca2a13ea75162d453cd2c0575ee37cb1264e3f009a40856f104d631e9f639d20f4e440fa6cc7afa0c1daaa04ee0706f7667eea0820d78e013f38d11bf2e8e46583130be4fdbd56d86ed47f3ac5586d0ccd965fe7da751d680cb4db2d2cafc606460c033461d3ffb36dd578bfa29b2476741ab0832a887d2938cbb8366af8ea76647a5d697be5cb22f082d0269f81a0cf06d55ce4019c0dc62436ace0651f596fba237f3229e7a02ff56c66354776eb569a84a280e65c3f32e4e3db03611668015bb361712397a64df5510cf77e188bf3e69e7d23c3d2bbf5813b93660b691ee86ac1535b62ac2a6be6f97f0cf4023880843f2a083e26f20bcc0c8931e25de650db88e62a4e287ab79a054372537ac0c42645781b19af513eb1343f1752c8a050a81cf4436bfca810e790ad2d4b92aa2024a8c89e1476036e5fb4ae754304d4ffd1c4f3f60d1fca6300b6abc8be7288ffb47ada68747991b0633e0d724234e129c32458792168c95df1a0bd8ac7b063ce4b7982c45d36ef33bd074bf0dbd6fbaa73f86fc7b700998d16f56309c077b108afa0fbe9a6b21699fc62fdc7865245e45472cd4dc25ae5de7c76c98a573574282d83801bbf66018fd3502be2203292e5dd79888b7e3aec94d4b0478a714a38c5ba0649ba19089ece0be8399ad9eaeaf743a8cfd22008db7665a94c3c851a0a2ac8a260315afaa8aacce303bc9ebe273e09f48329da47c9abcb989fd757fce8a202891c35e47cade0121bb39d1c09b36a7f078df7784feb850b0c470ed0eece7127c4044f3f1df3d8c690bc77a25eb5207664d06ff2a58e47837c528a71ac946d1a1e26df745ca69cf5695d69dc9aaa9d325ea1efc1d0f36050479c12a67e39cc2a0955c422989ac3cfd26063a4697edcad2efd8e629bcb1d4a1eb569dac6792d3a5fb8754e456a81c742e64db07cad1c2e37298ebb996842a309697c600b5fcf1cd5a8c21b6954d715cc55bca85c8d4f8fbd04af80c8f6dfcaf8538009ccbfd667e583c97b3557e9d6392d260a3dfd774519c2df0486d0d0ea95d11f946f1ac184a30e0b7ac5996df7a6f3816bb78d198a121c8019ef56e67e6c004c79e5ef0dcdc29aff96c09d9860ef521a0a1199ca9fea61dc3cc1e074d272fc576e27c479bbf94c4c7005c0f5ca0cd59cec31cae5a241e76a5052d7f264c94fc22466e1480a227c7b4f98789f77249c1b11df75f50f15f27820dd5e7f30815e294d2f253a066e5efe232be8f711a494fdf8614cf7baba302ae4ccd55a2d94907062c7f87e52b72a293f8cc3813ec644ec08631cf6a815157ed2af4bc893cc6b99007792f899632f05aaeb7289358567b5d2ab19bbcdb77b52578a140948e62b0a7dd2105ae3e8ad2e5b65aad823991a2e2fb07b65d75d55419e7a0a6e041b7e727f605b398cd76acceb9bae10bcf6de5aa58561c068279a2f10053dc6c2a59ff93adca28bdfb8bf0582db660343feefdb30404fedc3adf9ad09aaa078b9ba5598d259eb40199e96bb04526030140b66e0b59589a76bd0f78dc7a40971a223b1f6315e8346695f87ce59d33e79272fd943510399a78301e738d13abad90c6a301a04a96d6d58dd00ad7e23c71cb39039125fe7bf3456a3425e311ab58bbe7897725269d36697f0c4dc437d0c074c93ab4cc955997d999656ea26c897777df097917aa2f8d4026f1a350e0dffa6259576bcf0f7ec9e99d2cc128b27183c93e656f8c87af541453585cfe4e1338ab9b5f703b6ce0e163d3ba9c66922b67f4a22037464eff95df0cc1f8d6f1386a9b02729fc621eba77ee63046891eb4e305b00c6236b51465dc3eb2ebed40520b3350611b2e6385057f16c2ef39c234edb91722de65fb492b9e1e694079e21df2af3f1a2616808a6bcdfe99228f1b8e8bb67e08d5ba44692cae9b6906cfe1c2d9af4af580f89ea3b3b1b0a87eff699852671a477522470ea47fb658a6103c41f6d5ce8e4c628800c64d7cff2afd8dd4a7111a30ccd8924ecf0f1d4687a788037a8b2a36bc4e9c4013f7ae07d689a3ee9f0b4bc24187707be20b2281d8037481765d3a420b58263fb694451457e23168e74f5974d66ceb1cd8f73cd48f5de18d9ea409742b85f6410ba1375dee4af3da77f9ee23582d24c583c0a4d42798c665e29a3d9c52aef14fbab450793ff0b4d4a9cd471c0a0b9f6af8a665022e80fabb01219a440269374503415770b7ae949c4f591d199491b84c823826c8815ce7a46d47d83b887b480f93036b68af12da996871ea72c2e67bd2339f81c6428891a8d2cdcd25ed4a1de572b4d340bcdbd0fc8c36337844a4a38a5baf07dbc732b23a18be759608c7088b2df9ea44083ff8fdda617c17e0c8c1e72bba502f2f7939c5f8ead8ce3c1e554178a3e043c010bf6143d4e32871cf9e606093d7a8ff3d21f72c574003f45d6085145201885b000ad20baca6a88b23adf983842dabe20297450c4688bc4fa4217fb1d5c4d41598c3216f0a11a14f3a86801684c21c6d28b0f91f49de31d62d0eedb3f28e571149849a37f455620928aad21bbb075628bc3f5f037b6efe6c7d970a1328f466626c966441b8e7c286194afb498aae56a7babaf6dbb2c755d3cfaf462a5103d7c8cd14121b18adf30857e3afc5947d92a74394ca975406fc44501ee8a470e6af1e48717cd7f5dd836d55853fd8adf004c39d256a1d5024c07047ecb25eb5ee9080eac3f7209e63d01862e1da2c7827f6a683d5421ad97093f574559b31862b3b60470b8ef06a043487d2bd3f0c9eb3904524e3a50d33d25e6d6d04d4440d8aeb6378e9ab983bfc12ae807d80e1ea3f76c118de02272bb761c29f4a3da41995058095780b7b7160ea3b9f75f4bbe6c3040531bd7447e3a8e4579b6a492656d8a49d18a283a10c969d4314f8ac8308585373f332600e25eced7b45ed75ebc6a689a0bbc2d3680a235dd04c06736bde14bda85d6130e723f5c5a4d18ab2d8109124f9742affbfb114aba0b7bba8254409fb86e39b0f8ccbd8b11f1a1a39fadebd8095571db05b7a2a4d4688c118a549a47b0073a4b7d8aee5269ba092b091cfebf07289d8429102572dc3e74645aae749cb49112c02d80d90b01e429e1ca64b09c26e1f0daf3fbcbb8e4e17ff64570b9b49ce5e46f312e0bd5949c1ec1eac26bc9e71a3313604725426ee3dc38a30801a36a0e2d5a3b6a206463326618f057c425a2ac5f606d7b20711ca1ad4659fa49dd23fda07749c8509bca855fbcfe690d327087abac4411c0f756d1339cad8c1888db5a23af7a4c017465a238d79870cac67e5e99e11470f2c3befa098c203351bcef6901ae45be09088b2c1f0af8e58cc0a211556db746baeeab330c7d94c7e1bed48d7bc1ae194a1be1df7db6dfe07535bd7b382c06a18bfb68d33f320eb87ca77912cf4acaefd8dcfca9ee1c739c09072528486c2f8a86f95a03b63a01079bf080639ff1e2157d5180e30fe90c2ac92ede7d27edfe5d020c7dea33412bbec90a6e4e5c92fe43cd93132880afb0d87fb12694da048cd7a8c875dd41cdb356cab24831793ac2f89285ba43bb74b8dfcfcfca1de4e59e8231283dbdfe41cf19feb35fd1dd842fe461feb6f6df7c6b6085fb42ed61e4abddaa4ed57500b73f8066d6120585646cd2e0021f1ab0c4e448759fdacf4380d9b4a234f6fc5fa954b86f9db4fc2d1b6fc16ac7b6f2dbd30506838632f41d39bca7d05bd6b118ad7840c5b05efcb81f5a47f1fa701445c242763ca9b7b01f1638d202aab9c0b107a119c1c2b96810254a5a182f615387f24f64288a75d6dc971f75c60eb94110cfda21df0f6fc26cb0bd14c6cb9c78b46ae2d0358cba3a7f0b119e2ba8e475f7405671493fc729bbe0ae52e62cefcab5c221b7b537c188000ff21ebfa8689fad8c16e725f006efe22a9f30bb217def75e8c35659b3b738f03ec8b73376bcf28252ef6cec913cbb36431f16509611b8bfdaf27bd0f6f9658996a81bb43ecb869f525b818ea0b561d4fc74d4d00c3595565c3b85a17b88fc77589490554e2bbe0cd76dd365c7b8a37e3bc63c239d73a2d31c796d74f2224ff32b0e62b4acf3c1c893e8758dd4a0d65838d9083b36efc71581ac9327ad25dbac840a2a771cf3526d16c5677c04b6cad80d658daa09d1991f755d09618c38dc1aa174ab6a11d4d0ebde44c780bbcc59bfc2dea19bb84a278e9f569455c1d58b6bd7e52a58ced7f62ad13ce444504df0f930d92d87e34819aced640d3f0afe4d4870fd2faf9882807ceb4a5d647ee8137565a230abdb619675cfbc0226b9c208dd8ee872d5d3b3bb5c227a4eb601ccc542f347019d10454c2d92e8a5f21c60820f18d8e0c16f38f7774efb752be6fd2f3f15cfcef30256502b406b65ab9fd43b9cb5c6cb466698fde192427b65fa480093fea822dd4b719f11f681500d3736bc833403708d2b1654e16ec0184f78666d4ac15680346ff72aafc2fcc049a2617f23fd64ea06c6c8cf6e67b204433fea2e831d682a73f73fa57e8493448a832d186fcf5b4eea3f34c3d7e5bd3a307e5d24fbe2960d4450c4487758eef3587ef33dcadf23561c262a8c440c0e7450327d85e0e3b618bd924989b952a6232c292683270c3f7c5ec92d59ce6eef4b39bce1dac6329d04583c4f7149905c86af4d9833afcfa8d6c10045ecbcbbac784905e9528fbc72118d6ec3ca19221514b834714b9e78ca17b31a86af95568740f62638181f672e98cbb0e38a349eeb3ef79195fb7cdc97f5345af9ecdceaf704a51e422edfd49fd1ab0f9b01ea590fcd4b85e1d52de150ce0560dc7b751d7c986b59e06fe0ef6b95c82a92bd2d1af2dc0580971de2ea15dc3f80de039184f72e5be5b91d2bbb19cada111c460e60cc9f01bfd2b4d136021a9ad70082df35d0065afac3a7e2d204e4fe3533936621f743331943843461bc1055f95dc3f8dc50d9c6d83499ff7102a55c999c49fdab8f6832a909e5e05d8fa47c5716f26690cd71ae6815c1bbdb1f73ba30bbd525d8f6755dc136af2eaf21c571b434ef8c84cb1a0c52cd24c6f07ca5252b8a5c5969659c1cac43a942d3dec387d6ea09dbb2634474bcba8890f1af20a3a9e963647aa2c91c680fa1a808cace2cacc94c7ea721e4bba80f901a968edf988f53d65e016db79753552dc688a4834abf975fb73ccd2ee6ad66494b3ce57d5debb446bb53e0b3f4d0a968e21159a0c0f3d08ae690a714d3a5893ced2f8e90fcf1116bf779d6c2f96eb3498244849d204834ba427a0ad930acf52d5a54b2a117a52298fc13bb763c20909bccbe2de40f2d4483b31bdab394871deaa4b99935a2236d361ec481464fb7e0a271f237e3ebe9161e2ae124ca7fb493ce9c1c2ddba31d311819ac0fabd009f0b8d11657eb85832dd4812b876caa4290ce91f0495f008e679032e6861a89df233bd0ae3ec3632a7f8096ddc659e9c033dc6144003dbad603595514e57444d435d084e72706f21c9a477c18538e4be0ef697438196c6daae7c1d1a79a49ce38156142db64fe3825013c3d993d3a4ee1cab7e4e3018543111c60da3c5ff07ecf6bc1b9fdff65a56e68d6af77ee30e0d6e120df449058ddba33c517df9490b0cb33e31cc09d7c09707db1a15b0e03340b185d626cee568dc522a180f4f46a9fd2935f1d85aff19bc41b961042b99d9158dca8b16354edc11972dd79a211030fe8a95c4caf66c61655ecf15c00c1f2d31ae134db6fdbd4d17b2e9137d3f8a11cdb486c14b05e221f892d287b1508ed223dd45d161b7e3f88bb111b1abbcf7ef2bfd6c30cd0ee958d7be7fdb8573a32430f732bc20170000caf0e10d511d208cf826dbd5fdc31ce5d823713c390d2d927e046bb3cb1b7a4fb40ad0964996d1c71199ef223025be61de2b8ac90b7a7989c48946d29171b9a9f12645dafbae954e0baa50b6a7c040e7495004def322ced4e5f99549c1714d878eeba86b58ec9c37f7384dec067c98731978d2760a64fb3594d45cf7eff2ea5f52928f48c76f9980d0622851ac4959127ab10885d8538e038161c125491f39f6851417311f01c6e790a2ebbbee0e554f9b742b32321fcd067c1db2b03d3fa4a1be51132d77f51fe1c31786de45c13687abf5d53365d7753b499474f10611e6d65de4d438605c956afe00ba4652fd7bb6c2e98e627218398addc4f74ddfff94885c0cecaceecbea36880231a4c61a6e9ab670458184f98633248ab6032b81b20f3fd1a97dff7f2f2b8c1c6099ead900e2acd23b71bee5858650a4a5b6a71b790cd67cf013659fbf198425814ed5a95fb9d21b7aa117f3fb51aed37102a52bc94fc7d97b7c9b04d84d6ac5548df5c9e99e5ddf686cda9af66685cff9c86ff59236cade744abc447f13d2a8abeca53eea70ad7f0aefcf0d88b4c61d13c5bec52ff92c7ef6e527fb5b265614e5479351b06d9e63a6cfd13f138652fe8e428f2b449242aab887cbc699f466d8351b361427c70f21d73be1465a288ca9a99ff563bcde12b9fa89a13265398dbe3cb321959fa69be8f425fea614093ccffef19bba698cfe697895777cf015b1488d8298c317de1aa9be3c08530d8355ac177acf829a9f921bc83ca911fb41d88f7c31502395fe3b88bcba4b9f23474f1c2c9d702336a1cda93a3d701a5bfa87d8fe0dfc7f468f4d998ecbe8589d6da884ea731e788698d72d93551126fc7f964660bd887ffb8bd0edd54343b771402c73b9dc5573203386f4e02b8ec22d1cb582da47a6d5134cc567da7e3ab4ece6b946205bf851812685ad2bdfd27b9f9da28c839e897c57dbe1fafb72d7a83896f1fae616184e17aca496a15d4c3aa39c3eefbe2c6a75344c27f65ddcdc04f6e750e95d4b6a32367a6c8fb5c7e5d00967f05a3c8ad6a67394d75d5a812bbdc9918a9023964628bc465df2c589de41374b66a9d8d555c7b542897d12c4d8b505b0ff51ee44aa2dc7c815a70f360cf1c0b4c366d8c999f4c26ee7de60fec3af3714d16d52874d6cf568f8420ae175b647c1822e1eed801896b6114e65b7598406d3874a366ae2a09682a023c62b7156984f5e53c751e7e982d32faff400ea9cf72ea860da113b61bfe3edce77de00bf3cc11dfe6d39e312a4af598ce626be1b2fa9ccf45dd90898e5b60de3f71a80194742c6da41344fb0ef674c87fe582c6b32295b38d17deb1ee301982b774982a656a5e232d7bb43d33ca2cf049050c4beccf4f13a66b21571abdd3f4ac9d1841758891bf706963b84d8f3a1eb6ce1edc1bcbdd1a004b24639dd6fd542780f32efd6c631ac75834ddff5028b55a479b3dd5ee32d648928c2507bfd084d70817098b9f7662e77cbc685784b74c5dcae7aa3a27073a32fd928cdebfb3cd5016fa7bf3e2da8599ec8670ab10a021b6e79b86bd84b77b46e7b6ba65741b18651a9f1bda70501556e2c5043af208b22b90ef10daa123aecc75a002ee758950e48918f8fa485ee2b1728df6407fdefc8f4d8547785f7c3af4b9395c4b708630a57e09cc405fc7f1120dd8d760e894052cfdd547d942100be4eb1750658b0cee70e53d003cd09d32e23486c3b04780cd1ad6b337d87e8a5fa8e1c2448958ab45bfca89354eb215e9713cadfac261d890417dbbe7242015f564b6272e07144bd0afbb426dfd8b791634bee130f50b2efb85b44a76948e712ed84dab51c8f6d5135ebd3eaa44d468696879ab0523dbb7bbcf204354c49a0576a559178e6626da7c8ae75f3f618a7c389462456743b42d742a611151d405d46ffa9591edb9b2c1bfa08c112c91a327859b38e6aabec806b832d5200cf9c4eed2ad92ce4815563f3ee8dff1cba1058b8d241fecf066c3e665a307f2b86bac7bd3973a6d86545f72def0514ab746414e68497d87a255e39710d230787508c0742d499c7739fa84a9344d10e0577f4fa49d218d22afb6679266eeacde0c9a6905cc00506cf3090ac348c525a5fc464c3b86f28966300e508d286282d2d5f31274ba0ab3fc8b0ac000901996a61f95d976145f7aeba4f06942615e92814825d084d97d51f4aedf32ecad021ca1f1f3231d801f15ff1c5273cba92bf2d6339f965ebeeab4de8785ce20c94c5a09497389e28db4815cfe28d25f499a69beef7ed297b16b9235f5aad3fa1f9ecb1261cff5ba5ff4dc71853d17858749389525d9be29b18ab417e1a5d7447562a0fb0f76a36f02b538b109e78c5bdd38adcacd9abc7878070bdb7612b3de48bb218207c69532f9e8c9eae452da6e082184d9eccb26ee0524c422127a6290fe0561b1159904c0891f423a9c7bbc66fed57a10e061b6a584c18ace11b93c5a01ba8bc415c3d0149c9c385bb327b85bcb3891f720274ca96258d7ecc9acadce570a4d0875ae7f69cb87f071f6a89b78a01b325826591194276600e5428dee84c5fc42660ceb73b29874c1d40d609a4a44131473caf09c8f8293501a88763c2fc90e35efdca750784b07c4564fe608d83dc466256142dc2dc11858f111403436bd1629b490ccd34e562809492c8c2871811e85ffd51e09c87f459ea68447f683760b326c33ed1de76466ad3e00e0168d94f6834a9cf239d4b96e9e7ffaa3392a7189ed7e7f342522686fa5459f2b80ef87e2f8dc57cde4b0957fd45e806d51a61c13b33d56a9a98ca4290ddf7b3ab4348b649201cc7c53992c028b52088e67d4d37d48a69fe1d9b1a095e307632daaeae817cc3ae73ba3aae537165ff84e64e65b3fad672ca9c6cd342dadc9158b3f4bf8dfb9d953569de541628032e0732f9c277f51bd973d8802be40ba59ce1ef5b5c5323724a4baec6b05b91a7313f5ae1e3c3ae8f177d96dbfa386fc4d0aac154b591e1d3da50d090994ff3406662043f9b86ac58340a2d8881d2f903c615e9bce465e32a657a6f93b2b531f390cf4d0cfed66447062afc90be14520a38b21326f5f1a63b58279d27ceab1d64563ede9b8c1260fc68e4a8463530dff6657950ec3a5c2f433913028408669404a2103f8b451cee720562845df9504d205737f05ecc9ed1024a96a2d0aa99ec6990dde464cb025f2c2a26c8c3ed443a5c71d93f34fe32b6762d9a35bef52a30a8761dea88c4965d46f8ca3798c3b9c6756274fff9cf96e78d9255b3511e742252a89c5d4e2d4d80ed71738d2f22e3ac2ee517daab2c35130e1fba83bb8b102326e90f587d90d8ca5a63d0466f485976bb1a6cbaf73d5cac19fbb0c2c0d75d9b4623b1ced1a2f41e5bbff6695f1ca7d9b97bcbce3bc4c022d6b5335118720d2c7056fe2e0951b7757299b0506119726f8b801294db9c32956a5e37525293202a4400570dff06b0666ee8f6f437299d981e54054e76068d7d19e04571e9b54d32e1d529d2e69a593ffc07ab297fd1589786ed88fd0f706e0f18cf541ec6cfed8020323af07c621b87b8629c662b058df8354d994869b0aaabacb5b17b4f81b78b81a2078767ab3666b231fbcc99550a362ec052f0c1c4af792b420f22253552d83ee0137a544b4fe7435790f1003ba6e55cea43732789957a1b13d2fa91fee238795dba86a1e5fa11b3859fe241e3bcf7a61a3b85908dca0555a56e3f2c6a3d362580dc3ef900b383e1b388bca756fbb9f8d7d7326fd5791d007a55bf5c46654f4910a1032a1f4290bccb9968363a624550c3dde696a540b730900dc229486b378bbba8a38612e8f411ce85951516a4b9e6575f885e54e04e9484e1f4953b59e4209d16a13ce48b103c2b4cefe68244f312f50eb0b46ae0a98047585b48fdd24becc4995f58577132439918c57fd4e9e27dc45f114294e2ca52d450a2b33d86d8c0bc34810acafe12e19522cb3bebe37f45d51ed4806112fa98d5a2de7f3afdca185217c9bab6ecbf6cd275292d875b84e9deff0a9c74b3c337417c7c1ed00896250d2e2908c5e340847de947d084b686eeb466ccf7ee9c9ade5ec8944ab","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ea6b8ddc98e48439fa3d9b6841f4bc47cbe5e2e11e73996e7088dbba98b4fe572113cc6fa2836f54b22f3f650a1b533ff2542a180c233d8359257e0dcc98c562bc0e9f83e7c96c60a5094b9834bfe58e4ae6796afb6b073bc0de47b48ce8965bbbe786e7ca1297bae270864021e2ca0d062e09623022d1fd3ff455ba5f6008b8470cabfa97f902a3e1ae1c191ced9bd379f6db44ce42c723d5ae5eb8bead160486e665f4bd8316a29e363210a6d91bf5cda9909fb9cd8231528f543572fe7131587a559e57b370fe72f2e3f41a9637efaa23d12bbb8171bc8589c4d03a98bc2cb5ac64b6936d0fed9fc5b37b836ab4000834ec9cb806c84a64005faa17edf0384460556d738d2d454bb1c766863d28cf8c5989944654d2652582e7ed7f29cd903c466557268ff793e6bac6562e33883ee770996c972802732526baecb912b583506f55f219f5917ed9570b1f995465189ddf66c69cedfa1ca83b7c0c8e5b7c8c1bdd0bd960ad099b5936606207de05363fbd1641372f113b4f9c4d5f0bc98a17f55de653a225fcb908e37facadc53fd354e930138e1ea46eb29a094d8b93c30fcbb3e1390173e45e842cfaf458f5707cb507aa97ea9be70f018bc295e07bf3958c31c1d63e70ce785939688c706256e7ab0237e6532867a946267c4be7477a178df010a12e8af95a7aa07ce31d4e10672bc94a4a372600c62fd812b736d2861aca20fed3e622650ed1386619c94911139f06951a82dffd2f642820afd6e0df68817d78a52c3d8985c6ba931dc5c4ddf138f9eac6315ce2f84ffb5351ed695c380421a34cc8e69c277eb76cbbef1222eeca9aecaa58bfe3430c240c06dbf603cd6af59dfce04aae7341a314779bce8ac624b3e871d336cf30955559dc6a5a32b43fa2f9d8f64bc1bce739fadc7b4b760d076d5d2407fcc3497194d7868ec45ce9a8f39e6c503f14ef1d6a1b9755a613a2e7af69be821e5d191b60e6d330c28e3f269a524750bfbf4b5cd1407a74b2ada42d0e42715f10721b0485fee0f1b5c57e086cb7686bdd3e80513af49ea5849f95d6b95dd31b16c0d6b22a46dbae63d9f1b241bf8476309bdfee8576982a072b95ed3b23780f1871c39001fc229329548bc7b9061dea671f1c8f768ba918177c410281ea1017d703772fd3fc6e36ed5f3ee8993c10fd85a1321dd1ed65e68bcafb38fba10a5473b0fdee97b8d74b5a626f0280f9a83ec40fd3f7e4522c436225011dbe8b857f0577f882a88b30469e1e8fdf5e30368967de7535b17b66be96b4f7c88032f936cb10454ea188b4cfb614d2eca0389c6fa35dc4327ca989e787503b08b2d727f463e44f2a2b8fc01d9316b620572815897dbadf95f424bb8b12bb89ef27f82ca3c78a04f0deb54f227c906879fdedb878e5d4d95baee04c42929472c4e0b9e8be2fe2e2f2d1c6e6fe567cc0de8b967c016671d36559b232526637e93a6895e5c90b83283bb418be83a43c5393af27add90da40d3999ead531cf5a30fa1bbb386e49c7a91f458a36d2f7cbbd34631e75b2d7839914922ae2711b1db72953e0eb45450f29a85f14ef11ab5df795c0b7559e08527d8db523a0bf751518950e48a97396e2c2ac699edd7286f171504c13896bdc09c036e932cde04808e0b43e1fdf8934f9f7ed4cf56335891d71f8c1de873bb390f48ca897acf9582a78b503a4bae2755f50c293ec18505e5dc61c8393e2a84d26c9d7d0e5a8360a5831717b0353edaae4dbd798ab4f939aff37995f7351869d9d719431f0808e6c8a107e71fe78a8a612e8ffd0eea19d31eb56d2c54c78de094d806c6c0fbae750e73dd27cc7023e985756cdc91c9d743990cc5dc9d66f6907f8e95b9529233abd4b928f4a5e17ae6c9be37e5b917ea6277afa0eb4789ff2dcf262842d210b5a1cbcd99bbae547c7fcc7fc9d0cd7c5787bf76feeabfa081d3052afaf50c37819a6f8fb44d497c928ff1247b237c2073468e2a6603a07e0ab3a20145e9aa2717017548c64c2f9f16a1312186a50872ef9915375b27ffadffa2ee98568e9415035184602ec56f9476725033d67bc147d3298f7eb08fec9aa585e272736cc124aca3c3c48f0cafb4962f330c919d8a0f1793f22801d7078ece1ad50b2c28452c2326b2d8d8c58fa32fe4fe9c64478e26465a0f77bb933b0106955c50068c826cd015988aa623ee3abaae82c4ceb1067ccb13b8d388ecb49668c169ee55729d9eae7d17f3e57db9a004a44ba15effb66b133ba1428b946ceaa9643b1c377c756a29f0e353cca871b1ade1f4b23ee92732f9e7e407cb57b87c49f11b025545b41cc197f01da268ec23b172a0b4988a1771186a9dc4495efcdd4cbc4ee2ff2175fbfa8e9fe274b868a9720bde7d9641e728b92e267a3f066c4dc12e22087dfb5937e5a6aee365d5dfbb681eff4a93f998417e7172ac6c4e675efa3bcdbf1e43d3c13e5d2a65ff7b60d7354eb8ec20bb9e3b2d7752d3c7129549662a76f8c0f14e174aa42c7581bbb3ef8b8e60eb603636a30a14ba6e7ac7b91082db35c3633022388ab749c212552e405a26afe52c41aee6516d9c09e6fbf67e986eb14959d633ea456e928e5327f1b20d69bd92638e17b1e0fcd3417b80d2c1de37d593edb205603b8a7d34d74c3e508dcea05b5ab1cfec67e23db92f12c0905423002092e0982dcbdd2a3157d2b8ef109a60eb4d734c0329d3778b27d6243b6211083e43d42831331ddb920c4670f48584bce2d73d52721f7b0ffbc6594539f70b6d30340f1c9044d7a6628a32c5f77eeced06fe56d9de028ee8a6cd02291712b63ffd6d48c470d8b1a031f02e03f23cd770413d171b0df6b97f295a1268ca12eebf8184d7e5e8c0e99dd594630a79e58471f4e9858363f54ac8263c51e4bb7039536df2587a62c4ca9d30e8cce4366a776afd4470df99dca5cba3bde7c28b659e291d60112cf42036c7473e53e748e278639abe49108d2576537a6e1c0875db4b669530e0a39eeaf238909f9cdf060ae0523102323c2c802efadbd627b176e59b0e81f2bf16ff3d9089521839e4e6915b3e317a1f47be4e544c14d587915cf530f7f5dd5c951e8b3615e5b3b0ab56f41955c367429cad8122d806072dbd6d52a76f59dcd619abbee11ee11bcd2c87589baac74faa28a500b1d3ee412387b96a3646b711cc95de0fa9968736f755c04788432a6c3e2b2c649281a5c57543622f307460c4ca533457f0c103af465ed5210b8026086a1c2d2675f58b45497a88170101a7be1b661c5e4132f8c990bff952707725cc3dddb139da2ccba6eff0264eb2eabc6cba1679717fe121b0a382a6d36e390a7b7e73384604c710673634864202486a0d4d92e2c2d1fdf4b681e41f567801466ca479a8bb0de44cc185c2371509ffbbb98d3b429f7f49af383b8e332746b684d9db4e0c4e767646bf01d4842dc8ea127e13cce3f72c86b3a66ff4a51ef92dc5188a98d9f8b91dfb2bc42b03efe890b746c6880405eecc292c40889fb5d863a962ad42f6484c36983ea28c513dc81930c68836c66d2ca1414bb586d75c07f71465749ed6c2cb594b3cdf70cf392d22a67e5ebde91b39a903c990354123fc90a1873fcaa59f03df189ffa358ada5a0a61c6db27f8cad5fcc54e18c251d96a7f3850a264f55289aa56b11455ee01f8138c9a59371ba47308ac1c17d6e30897de8cc7db6d2b7a20e6ef41cb117a98f4d30ec2d0f29d9d2f766cb27533b03e1a8d975a15064e299d8a741bbfc59b740925fa6168def4936ffb2151e51ce9d3af73baa77f86dced8de8c3445342a3ff22fce2b3e27dd2b76719a4b7730047213366f79fd84a4835b0fb756dd8d8f905401a492e7e0dbe7ea8eb83738dbe1d9a5d0b84105a144f321eb312dc991d88fd511dcb8e0bf7766cada8c8304e986da92374b515954ba5242ef028981a97807768d42b0503ec02c0e7569dc0e9d39fd3078cc04f6d5e170646afb22b4b90e0abd5d7d6e7ea14aee7e8139abde290dc34da46cd1247289b132a6d4938cb1d6929130d968ea81c030fcd749f3380fcff2220b1540c5dcc45b4af35937d1ac37b1cf0ce486ad459490598f8bdb63f4361630a95ccb009163cb49b1fc441f729f6e15df7543610507bd1bed55011cc14d9e5a6f92aebdd6b6c8a213f91514363e51f31e27c4b92ce74cebdbf1d9786b172ba4cd732aa38d4c6cfe34a153a92f7e8f78aad03452d4e7098bf86f46c3f104693607825fbaaf0846763fd6b7da6d08b799e29112b18e8c2bfacf33abc9963b9a11475362d3b13a006d952e52be26a2c864cd32f688cfd3c593486d42ac818d1750bb1df51760476801f34b86a29e6b813b57757a177bb285fadc423823839ed8a58c8da95c69a8d274506098b523f7cc900dcaaf8894c56684fe80e6eaa90b0342939456ed2a6a5e9df01ba82c6a4a6219c52659b833777663382e699407845dc66d80d04b5a22541e8c936719399fa6973db83df37e3db11a6197bfb41589f4ad95ae93f0b3e1386e76bded6a337a2ba05b984e101194c69329ee9681cbe11fcce16040a6b501e2981485718ac2b060c5db6532b8dc0cf0c3c7f32713fb2a2b7539811380a23f91bf811dd6b15e79c9f0f5bcfd48a88ae55fbabf7ef5052ac77e247f23c1f37036e07c25b2e142e64b000e5c421458df47090ff0d3538b3eb58806e49f2a4c7ecb31af6df148dd49342dc6737d8cdd1f465e8e07391c4af065961655680a2d8c99405c183b29904571128069077f762355d617bf23a872e369e6dbdeb2dbe86cd3c23a44e530ac205b410bcec280e401b6c4c5e14286fbe7265d21dfa9e2c60a8c70fdba9290942a90c8af3b7357924f058e180aeba51eeecab3f02c7fa21402f6a743d4fa9732a43f85b9566ca76e6c629c9777039b3b9fccb58f740130fb3edc13a9ea9a669f381553a53bf2c189baf96fd738a0386729d4fa47deffe38b10d60c63759aab18e9c231ad416dfb5b203159cab9c178196358be70f8180103abf75b06ae31f261c8d8a013270b3c6b5e39b245d6f19458bf213ed15bf743d80677b76c96106a99494432145bb8903bf23573bc3b2c6e92bbee95958073714aa1f8c6231d4513135c7a5861d4680cfdd664782b204c8ded11a343c334f453128ccaf7c663a4e4cf77ed9119a2e5ac3dc3a837ca2a0d8d3b0f34744e1d2b1ef538ede0d6e8f5e0c4d51f0c6d87441a4d10a767085f67bd336a667bed107c7c3b3bbd14c365a4756f4efba9e8a3b6c578a49bf8c165c90e5556ebc83f9fd0549865b9bfd1f5a24336e463650953f2ae265ef78477243e2eb15e4a24737eb3da2c918efc6cbbea5680d3431b3f3b8d9fabeda79f8d2e38b436f4bf16320b8bb06deebf1598a4e6b4c2b78e2b18c27b77bb92371b411e9683df9f7ce9e3ac65123eed83cc820b0218ff0c258d6b53981b0b80401df8d8a4a14288e942bdbc86c02655f161963545c778be393be7a3591694f74be4c484889df9ac5c9764271015b1fb53e49e07f8cc491327adb804dc8a4f2c5bfd5fc2437c1d7f8de70ddd05f2f97344721e879c663dcf8619e31c186c27761b6ee9c3d4b282d2f2c68a4b50dc432de8305b308d3eff8d45514db579165849db0c6c1ab283c035588d35c0c515a45bfb13966fff841e3080409b1e798e6940c75a78fe132f0476d84ca0d4d0fc3022fb2892c4877e866a4aa5ff66148d41bd4dd45b25ff762d77622d8895aa1cb55479135471513131f5e353b87e4de8802ec56dae04a271153e9cfccf90b599f73b5f6bf12f20acbff7dd08f5b949905b07f266cbcb184db6bd09095ffe1c2a8ecdb26c2174d42c8b395a07116b92af2ccc7f76a410c07211ea0ef89956e5ecf52ce0a11d609eb7bb805a4723cfb3329b6fefb4ca17f9868f1209c777016984e7de667bc4f7ceb22269f6f77c8b4de6d59828edd8be50bdda7cce9445b2f12ad91bc4d424508c2268aa773ad2234787b8faa5ecb11904883c3275816612c100fc8ae7148900739c9de6c5c840322cd69328d1b92fdcffb85d5889030eef1877c6739ee0e3dc966b2eb92aa5165041a2cea199ef8201b9b2758e65e2cb40032099da69baf7d61a882f15ed0e219ca3182a9ea52ecab4c17c15a43215d5d5e16d1fe13f0c2db530ce27b17cb1f613fc057deca84021b001a30b4be05b65812b9f9ea4da2bd7536cc28354e55f77e98c56e143bbaa39f34f5aa5351ddb4e3eed40be7f56c2d580bc8742277b5739b1d6ee786929e611604f2636812b05a291860d065fa40317b5f60d3ac4af122fa3cbbf69eb08136ef45a94b7aa343e07cb7cfc7b0e35ca3d3945377920aba3f535a43cd536a6ba789d332307d4689d1a8ad63ab57d2462fb7430ea65c02dfaaf5a20f129cf4b3ad3be1b661f044d4079c0081edecc5328ea6be13d1dddfc6fb5b7cc76160cb92bf13f4a8c76ab8937fa736a33fbd7ecd18aa6342162e942bc01e3b6ea15c51c4f91b2a82c689d1e391f2290660d633b8c8877f57b81ba19c0406a7fe8c1b3b6c1143b5a056e07ee5eae5abe95ad68d778e1beaf128aad956d8d142b5818659cc4003fbfa72012955a0016e38a8e6fc961c7b80dc52f52b0dc8407d550f9a52c2b91642fee8928c41930010665cf1ffe96b818c157f11f1eb8502a61943f09dbcca1517412a7991682240682fef86f11ba53625d95afcd735ac7afe6656e7b776436f66e02ea73f0cfb91591d4ee78e589bebdc7aa968e4d43589806453ae89dc999c39251a0e3045eb234ebf3ee96706ccd966b63f4116bbe2e71eb862f36afde96c682963cd3f4c25e494df17eb947148012c855e815f7d1ede90d332f971c00233381e7fcd7485da13e28ac395e06e792240a8c88ea7eeefb011ea92bd445e92bf36a462699d7f3dd3ab43bfcba7b97fd360a2ab0be3e26e55176b541619560d1c35a216edf3b99c0390089aa95f2a6cc4d197b5659de9072d446b2d3ce4cee9612444b30d51c52ed2523a4d5b1695fdd8aa328d7b54c4a3cc9e64715b9a422ef77b5f878e90eb4dcbcc82f87d7050aefbf45752768a554002988a2f151fbf1c5d4335d2d08556f8861372ad9f7d105d4b90f8f1eb62f36fa3a5368377c0c0575e57c41c6399eb2ec075aa248abffcc8ab3ced0108923a11dda59add8d71b10e1c73a7d74b07b080b4e2767287a7d0d3d5877ce244d065993c0d83693b2e4798355dcb286e809264b8936e2bf9e159af5fed8b46e76ce0d7fb593933d438686fb4aa4a839f55c242242bd088d835ae24788a42ce925aacc35df7ff6e507f181339ecbc958d1e4d689981616a8eedfa5fa24e05ab80dc0ae0d05271b9b76575b135c6607b9c5228efcc1aaf03848082b92220864a76b800a78f143f5db3170007e9106dfff0a2759233e48ffebdcb23d90c505127bdd9cb9420d44ed333147a8972052def0ab0b1ef707e71195800abd24333481bbdeeda7f241d0c4ef88849b3f42718cfdb8c914715f10455dd3328c7cee77325d167513c6edf4efda4f347a9d173900b2edc386ba521df37463c690690fef32a3b6bb0c455e9e1f5e44bc543ff5027024ab8c400503e7f09b3f6ea4609780c445b9266daa6f2f07b361f03c06c8d51d8487664ce94d9dd2d9dd9f562ee2b66405d86b127c5b4ed31347d493bdbe857b66b44158d2a90e6000079a13df48b89995943fb35559bf1989f8240f0238936298db1d65b1c6c6ffa6acb21a864f00d9eda83f417bee5fe45a987448a03557970058e6a226086a8676c022dde21923528d82250cfd0aa470f8156956fba3772048d3d185b562ba1cd9a632f427eba72f3738e05112d8b2cea47baace5836a94640c5e596e636de60ab3798a9b0ae576bd0f66ed7f095a6a6689122cc1d2cd4c3a4d1731186968249bfd03c5fdd338cef7b2f0a8eb6dff46715d7fb375e2a841bf7f1cbe493e477092f91b9f5579e87792a7b28f2790cc5eeaf8b695fef72a2562da4bababd7ace1f921892269892747c75ac5cb3862cf00b953e6bce85fbf6dfb50385399919341a36a47fb3706d46e97fcb2a6ea715a31bc243a1aa8227a87c0019112da16de833388844544eed06770e12051a4cfe3c03cb20cba870baf3dd5d13eb8cd519bd73ee55acd6777435efb95af3cf39b232cafe92bf231632f3f368b9831bdec9e18ffb8972f6ec0dad294e5d346ffc783ca4cff32bed279413a394e2b9ca5ce31db109c7729e9464179f5448d5bf9ce95ca729b2c587711ce40d4339a6a8f9c8d7e3db96fbf3da838ca1d671f6e38822e1ba6001f9ea7f465455cde597f18a1f6bf9cc6de84be24c5b7d9fb9999d0740ed4edbd035703c026d8948d2955001bb3ef8986f607c15c3b435a0de2b512ff2f499c35c24155f994a12276a51ad0df72819fc407da882ed407f1f46f7bda726a2427d7d19d2efd16a1020a2a78ff247ff9186d8446214661d19139306687a15671367891c70eaa4336cf44b4382a22e3a544718ec0e6e41d69044500c309f1c46ba364978b2f8f575ad1d70e4b4b74e53147b721286beb03f7dc43c0afed70302da0e22147464de792279ecbac5c50904f71e89e3c06154df67924661357a375796313094898e012c423fea16bd268f3ef03ac3736fb885708e83ca8fde5a0132712cc5e87ef6d4780e364cff2dddeceb854773b2654e900f7ab7ba48d9cc8dd940488c0823ed34399e274272fbd500ea5f3ee674fc100afbe726a2bbe2cd032419b859d2e9368fddd524b0c831522381627ecba5af587d33ef63d4bda8e52f010e3f9e516028cf6a134896897c332bade473272cee436aa49236442acc852767288d8ddd05b0c27b98f1bb87c988a9c46a28d642624520292c6e553658a4ae1d1811a43606310f61221f88d317bffd9579285946f228348b822a4470d4265042c74387ff31304426dc8fc665a47d2e4776e557eb8f92206ff723d8e43972c16edf9f9b50bb7bd8707806f3968b935286840529e067ffa949a4d3979c8d6adeb5d249c9035045235daef28199914d4a6db54146cf69cca4b8fed55e74ee3fd4056e45d11cb06e4c3e4466e7e171099fe7f45791ecdf5c6d681427e7e2b13f6cd0feae752ebb2a388e9024ff03c42407bf5e87801507ee9b2761798265ebf27d784c8ad8d32fd20255559f6a37fdeec8799566e7595745aa7f0e4f3c4daae3300f6a2793b1c9a948102e94c8059123c5e8318b38d12291faf452a6595f0e193b63ebaa88b47b5602294ea008312a7bca3a1476ac3b7cdfa17a376867029f0b965a365bacf0e916bc8fdc8f4393a0c15bf1aa11d51da84b13cbc59ce96864f8a9fecd64196f07119443e428c0b120c3649611e1614d9e81efd3a6685fd139a519c88c4cd6eb398ab3f0d588b4be769313eb7de45df08092c5dce420d96dc57eeb923981d853871b167c68044cc8a261b3c3750fea2fd288a9b4efb58a0808e9ac171388fdf6a7ba7e11b2ca9c72ed3e2c14e924a6ededf24bed2207bf47fc12436a05c926afb3aef1075ea742e5be7997e46794243da26944db84f139e7f97018f262b9a9a1f8b20c7a5e98ab7e01f8ded0fd15d40a519fa1fbccdfc277abfed93813ebe2c7988312a720f56f1c712a1a9754b745df5acfa630968da0271934552b7b08621ea816cab780e7110ece38f394218cae8d752481e961115a279a85aa546ca30a627ba84586b3b4a7950b572d212cef77a221d142417e9a3505dc81b5f198b28427ab97ab5b8af2926b3e6dab33aaf7f7059fe209540f407c127745784ec7176b0e9183e30578817f8b699f7483c44461dbec0e7a399c0780e4792293395c3d9f614ecf440455cfe1af3ed4acbd925c5f9a7b692605dadaeb0f0f21b96d3a5944ad9ff5a7c959d82d27848439d18e79b2bd363a62bb48fa78a2a3ff3b00af797624961ae64912a6464cfd1161bf0f6663ee5dd33f58eb6c83c7c41b6adf4c26831ca3ebf6689556691a1b451000d74612abd2a9698c259bb770822f6ad9b4f46517acd8bdfc3b69ae2e97481acabfd8cca4b8ac70a34cff2167c5bdbf18725bf1dd189d50753b2a5dacc38a7f59edd911bd08529eb5e0e75b1cba11ded76b683269d2684a1616414c5ee9c00d33eb1855e41774b7444caa5d00e216c216b9ebbfcbc56760a0dc2e085691e0d3aca9953f6b2b543b03cd64084d85b499f98e7d0b4adf566cdbe2b45b6f87264c7f71a30ef3a6e747ab51694ad43457586519f60d27cd2fbb7cc36c6a22f7f048a6269db8ded6dc81e9f9d9a1e58192db6b696734efed42c0fffd0960e193bfba505c06bb5158718136ee5787367e092f0467eea1b2883621a5f8674b732726f2d0fded79717442f767eab1fd380a7c416dda402d0b102b18388b5a7e663fe0ed2321407979dc1dd1d79c23f499482254d43e478a0155ab9caa6bc97436c90eeb79b5506012409e146bf5f305285776ad2f3cff9378ff9be39286aadd884df3d65d878113337e35450f9b33b69a008ea6ef9be3a915482bbce3208de0b9253b1d723707518aaac6c93550ff490b4069442410a2e17f3f41808db4df39ef4d9c77172e94989c0af201b7d427b6444489a1fcce800b8920120632e5c093ba59e740d903fc6524b0f8e9a8b51dc02a7e22d1f2bd99c83f56c4dd6de43c50c581812c92ab460ea714f103158acd3b9287510b2a4e626b71f9dec2923c8c5adce27e7a23ad8d5ec6ecdd453f8e4f3988461d5d154299740410a7d4ccd1aa6074c3804d5551fe330bd75da2bd249543cbfb471d0c7dc60cf4332041c72b7887e90eda92c734252107986a09eee368833f245e18df8c8abbd6318e1f2404851d164cfca451b4f324873f5211c8ad6602267131c0dcc01f2efa201630051c4ee6e75a9f7641d2650d40a5fba3502cc0bf3ef7e4b5b69c4994d8c6079fa23f65f8efbda871f6de9fa25f3e102fed9bed2d53c2eba8774d842565dc5c92cb81fd3307e3053fd522718ec932ef2e03a81fc7f67f1070c16e49a39b02126470bea5d1d8b32afecb558bb6d06fcba5be15b76a11b1ff299da71856c1db62f78450540c16f0495ab4abd6402f1d29974fe20097716c89a503b8cfacdf5320d13ed58fedf3c70b53d81f878bb752225d28dd654d66b56f8ada07a1c68b34fd24beb8e2406f343500f09aa01d3139b63769e6727cd9ef441ba5b82b96c220b9736571a1a7c6d21cd1c8524791016c4a191ad54db307a7f9080e6f2cf05075bb7b7b421fed00285a8139c1193f24b846d5e96114af1d1566888e54f939a6e9d2018d85a9cbb75e329e37c3a17101b445eddf405385b0a13a0f2d5804273919adf7afbbcb8762b9d053013b32598f733485abae2fbce0d1c5a6a4dc95250e5c42bade67094b0644c46f89db8142defa5c6d22bafc0479f0db17497111f9a2c31feeac459e7d1a3a7974cb78cc05288a923c0644dd9f781e426f6ebfc3f71207cdcbbc2034d4f747ca9498244260f82bf1a1b4abc3c1ab8781ad71f9f8ef07a75d84592a3c93a0056a8ad8e3e6a29f124068f4dd1a88ef11fc357ef0770a67e8795b7d4b33bd7ea0f350f1090edc77d5ce411ca1cc322c49cad2483ff76a5b999292ef28879d7ec582ef5e16fd29c5ea5e6e9b124e624c6b03799b84504603cb42e7a0427ac783afe4f01446d186113fa43a328dcd00aed764241fcd7e0cfa329040cf3a9bc1eaf92530d1d733de90043b05f2795daaaba91b0f9efd3fbb7f3874502bc164313f588699323c51af8b5238a4620b10d5530782c219b5da113137bb6a9ae68db272b594f41008282ea4a267fec1699e468be527321b8e674fd470c422d98fc23a6001bcce4ce7e4582d0054ab089f975e6b4d079fc42e6008073179c50e525a7945de2bd1a0b9fd5128e8aa1c0b07c7588bb4e496e730a5f7a5807880755a9ca8a9cec3a25f54c3690c8d7b6f758157f04249c09eb2df559be9814240ab1c67ea81350353dbb1b7c9c04a03285c18fcff82929b63f2a8a8de9d7f9eaa9c3bf5f1190cb2d93b2b0f50ba7a93d1e09215e659633b37d9a566e7ad3e3d9b630cbea9484cd998189768c64d9457e06a918098af8b0ced514c86b23eb8231b6197423ec01b9628edfc72e1b5b5176d128a3865c9e680d06cdc6fffeb76b51794928e90ea6e47f7d01f448a5cbc598a0071964ffad6f83631ca43da3807607387dcefc6c55feefccb50c5e21ff681162adf70be79186fcd545a7281dbb0eb1f7384d42b1e4fd05a23a7ed9948418b747b8bbe31488887846fb37f654488382b51b202e81d394a1c375479c0a92e1d03f59387c187952b195aa7ac5339bcf055c1e909755c11717d8c380b69693009ca2d2e2fff4403d2f3994367f564232c12ad7d03d844f04a4699576e21bdc2cf6073c89d30a3670ac39039bdac8ce44ca1b1fa6f30ad3a0bcafe4044ed4649f0779c32ff7995926bf8c5ab761e9e44179002f6d42dd405ccc82c8d1c7e8458cb18182ade0a31de51c9ecddfa567948ea79626443913eb961b8cb35ca0328a86d703b87ecf1ca22634396287beb40c0b17b8374fac3fe8cc210698eb0a1eabc48e50177a91718df2c15a1e7f6eed87ec84cf6cb782a3f575074f3353a7be36d1472339b1a9299b00551c3534d36924b5460ccd6e7684af0947ed69fa96ddbe8c29032db5706fc17497adb13e52d2db87f82c2dadb0d00c18f56ceaa81d0c6db85f67fee2f07e5e71bb138e942b6728bc25223e85b9963103ddf248be1fdf4a7045876357c34870354c8e085dbe42660af22113932b5eb822c60e93c009da4ea0292b1b04bacfffa56b5726e8887958e1e507d5283214b690095dd324c942d37aa6f85dbdf65779186b858a0e0267d1351a9ff953103bf9fd3a7404ac59761e81cd044d7544ab48762e54e033a0c40e21c776d1b843bd132b4df9240e15e3658c01eafa199d80f45dbd174f028d604f6d2f47f29a0977ddd81b1bd1b00f95ff6b5ce346c38e240337735ace6159784f0b51c652cb90cdf34e1621aa7fa26045df41b9c46af47abffc8d7960bab62ce8fe3d93b6234768e1d46f9fb8c5121b46c6abd702b966e9cd68e34bdfacb452615101ea849b531e1919a81644ce0bcf9e11f5b1791f5da6af1dc68139405e6bab311e0343144dd149c397a2f1ff846047ab5d33f60bed5e7aca2a9d1b628306c3f50d0c93bb21ebd421d94768228483a507ed88c44078946411057344eec4be6bd07a08ac87294d78780fc0e23f49e6e81913407b1c6690c571c10ce37494d8c4509ad59be45b812cba2f74fe21355cf88a81a03622c9d912477c7e89926c50341a7234ef9462bb75ffe1f29553deeaf3336b3f1d73d514728ca2b011da937e0ac94f5b98ad5037cd93fecacfcf31a4e5938325ce3625c95a3eef66e5ac80bdf082ff7cb4f888bb899328badb14150233418877b535d7afe33df9a1b16652468f28f1423c44605a83447b935ccd88cdc3cb5a4608401571977a0be6ed9f948b0a1a4f7dd07f13087b9465d3bfad48b70b6c10e33e41b17cd9a5768209a82b2be5ccd498510ccbbbddc4e2d438e7b3396b214812928ce1fe7e68d59136c4876d34d1c81d275c5a80c2a86c87ec993edc54cf46c98c848877022f1b3fa14fb67b4c8c6596a44a9655b51d8dc46512a1fce060269776a50012c64b60d086afcfd241cd1f409a53509fe4ca1dbd73387c7b81d0864bf6d2a6ab019aec902debc1ec5667096254a87e61fde176c2c717af8349a6db07fe4204c6cf101e47aee61600c49509ab7b9d8274cd16bd83e0aa1e914b82691d98d2ce2a1d0e0addfb332a8eb728430230312ac6c56eaf6a6dce5400392a7608b99daafdead1cffbd76d8e4a7585f3c863f626de2d859183a3d2c66f256692583076e2e1d441955b96a50d6ebefb1d683f9f273803a6b459214f99e4c2ecf912ffb0e3c8f79e92c14cd994fc9a57513a214f16a4cd029e486b6467073c74b366056445fdb42ed73dacac8cc73a9beb326731860cc6ec6f2724fd582869cc50e80d627bf777a8efa806cb7d98484f55bb7a3225e626777dccf07059612657c821afafd1cc85afa782ff66a2821bde082d7897d0e9aeb7791e706cecaded3c261f73d7b510d66cd2514a177cd1dbf96b91137f3f1ddb21dc1c64110f1e5f5e205a6ace3dc4aa46904f780e2a98e38dd3005fd54345fe0e0849e7036e0e61e1cef2f957a5e8cefc507c40c9e678ee1a2f25b8fa47c0f49c016ef006daaeca0526692d5cf99dcc7cfda8a9ff7e4e5844268314eba0121be65cdef29e589d0014efb961e013da999087cc1acd6a00f41a9ca1621ddfec452c1e752b386607a3d3e8bef56d220dc42253f560b3b0545144ba6fd4449f81fca494611033876e513c5afe7c54ca45ab77515e5acac33eb60f6fade61db22f242a6eceee43f3f28beb5297851922fef9afa765ac352edaa3a10ce63f1778d39be470bf8fb55d1e9715571b6e82fa782d520bc78b79fee225f2a76e13b6f73f137c96f36f4a58886f2b58d248b307e5777f9d1f99d6a4c76b9acf1a80c39a4a81d4bff203f8772aa474c66039355059d3a4d35f2c412640025a67a996919a1914f7d773813226479b8169c396fbdee27aa9d4b7704389b15144d15cf65a301c22dc622ac2de31d70b852f6946d1b3b775de0cb9c70b8a6c48d297e7714253fb6b574c9a35a59e637fa5d407e2ec105f65b97c0f113809549e092921cb30c4b3c96daccd00a436286b0cfd402660776329efa1a1459129fff41588497dfe3d6d03e9db475cf53cf14e3a6456ec3b54f824637efbd27e744ff5345d82c16e16f947f9f176cce13b8b63196ae91808a8953b77163d3ef33511e2a266725dc2fb62dbf32920c34bca08c67c30ef91f7dd5982e090110e0048597183eed82b7bdf3bfbdde4e110a4417f47f13f66d37dbd3b3e1cac67e405769faca1fc2bc159ef5bdf5b18e47ae103e2e79538f98f0094ba99bd52f19528aed14a7a231fad8a22078d97c0b852d5dd60730689062d5703b28af2d73e3ba34d5719cafc10372eb73fb9690fd56cfc753dc9c0e0f5abc22e18c471d3fa90eee2356fed16b817737de68d049590b4f1aae08b9d35056ed3ccf97f0bc4d75fde9c150fe16bdba840b6a7b1f43807219072d6450205912b1bc65077dd018631c7620a0edf270c2c3cd8b31d77ffd52554862c8ebc361f8dc275d31dafb5fcc7250b350723a164deec4d152b639ca9ad998ce46c8e54926d378558f1e272fa4e37871c573fd85a778005485f43707427a360a4c8a585eff59dc8edb198ffdc111350e14e88e34430ac64dd9716d1ba6472ea57b1e14597c4ef29ebbe7e32e1711edacbe7dc2cfe03e6dbb1237a8a7fb7198fb6c18cdb87351ac58de63eb8176e2f0898da5e3df2dbe4678a5c4e2008fdb8002ecefa7d2e905f95c1616b7599273c4cd49c0c5cb7f5dc169e1cf648c513081639ebd223b95744eda44a360ab61257f19650e2f77f61eb6621a5052d7c1aca65bdac65c28857a59cf488999c4ad2379f0583ed8917933f6b12133f639bd17d8489d8a824631e19748a6b0e1a7f236331226e562ee8d9c339d78ee3e3bf808eb21d2cc8a7db00e241b5d3aa0cef25efcdaafdfd8b5f6c2ffa56015161d341c230f6cdcce3d86af7e314dadbe1dc241dbc8e7342d22c13920001ab4b17295811931cf73cf7eeb0c7c9afefd936342011c0316e0184de71926db4fca2c015b5a29774c36c198a8fda0b892321941beb04395f9f5ae8240540fed5c87f7c03257e471053ceb746c23a45a00b650637d213ddf50db686ff30a29d5a39303268ddf229ce09e6f0f3e01f23da10d83cd3d5b199ae243c31629dabc52ba4310ba7ec52e45639379b5669f3c3f373bb87e5f28539a50fdea1214546f362bcf50972bd48795246d74805cdbae2951fc536a53942326dc2e87fa41d7919990b22ebebf131578e604ea25b6a00c8c026939241a6d68dc163ce7fd7248418cf9652871e4d0696242f0d35619aed362f864b7c52604c3cd8137e9aaec2f782f8d0949ed701f85a247ba05582757fd055be29f4b5b1411657cdca8ceb5ee5a2d5e291f8d45a9bca8b879aaa51405ba8f347bc958fa50c7721af7590e699af6a0dff372cab3109aa4fcb8557c8c1e41d1efa9859fc51d5e972d4aec7d4690a713c46a1b1e3e442e08ca59087d5afe71780b2590856b7e0047e965afe125d3dc36a7d2fa478269241d91768315d9cd98b5ac3604d572ccc73ebc487313d23c1c1ae581c4e332497a0c4b7285f5b15c524c828c366efbd17e03d3c991adf5c9a8611b0d6a707ce859871a58cf80fd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

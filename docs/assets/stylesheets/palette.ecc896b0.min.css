<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8ccb8970a889e2c00c06a3f5b3465360ddffed840841a3c207936cfd210c848f46a3807771ff3eb2aa01e21907cb4f51544f307045566f972423a1c9c7b587e070e719b916edbf45ee2bc4d01ae5b17d1072059ee5bfdf609eb61d6f61a39ce18f94160cef12035919ac7814e9fc3eaa9d934a2099414639e7849edc7f1d5de03ad2dad2c9873c579e0acb32612859a4c9ed8082b7cf8da854beffb336cf946fa5438d8dc8190ddcf6232958e5794beb3f2655f6da69583a83d2b7c21f40bdd379262fb0d6883d5619f1f9a94a15ceb759142815ca573926af04c256c911a33e125d6d17a8fa0e45409e0d8f4c4c974f21c1d8183fc8f20d01b224b79b199b0f33b43254950aeefb3cc4c4992027f321c21ebe374a90e904b75ea07067304733e9132a2cb7c6cd45c945b4b03748c7a031132a654f3f4ae3bc2452c1e025ffb87a9907aa658b4123d0fab14cf2b2b1c2af306e3c754a4d5c645daa3fd558cb247bae47f6c04569068ae87ccce7d8db8d0a1dccb461636511208505321da366be6ce8febca445f686256aa9bbe3190499bf169fccaf13db63df72fb5379adc63c1e07e565766362906dfeba991fee40bc823964db03e7c96325dd1c40b1df234dbc89eadabde9e28790a85ea862779a39f9870e0eb66a2a5a4f6cd2067104e200024636594542faaf1b6ad86b072a427551f61a1d342c2c0c98977dad526a695af84e1439e08927c6c4075b42980f1bb139800ce384417f8363f3bbaf1cca80f74a0bea08f5f968b860b2f5b91cc011670aa99639ab9e8671b79d92941f57e7252a4c64d2f9b998fa1fc868d79ffe4a6c0e4a979bd5baf84403637b00225a13124dd0287d89c319ccf0de490f3f99df5b434748e3cd6a51ba50f171a5d074d5925ddded8f0d9bb6c82182e02d9e85463082768e24fdbac48f8f441b30725cf216844430cb300b5f448aa83ccd57cd39a7de97551b2a430ba1b63986d9bcc4f5174eda51bc4958c8930d4ed70dda196dbb0cbe7a288c150b7cf8d38bd5de90d4041ed849897b3369e4e74036c57399a5489a01c34c08e62c58ce1238f5fc5892fa7f9f3aa938b963c9714e2e34f6e018ceac6ada102e60af4f392de5831bf10ac06a64c582c7902c582346e71456ef200316b45a2d146ac7e32a4189c71b2a9e2def3925dc3f7987c93620764620885269c5659d3e29bf85b59ec1952a0ef998570d81b278cc26962704ffc1c62b247dd0ba2598f6f8c0f57a545845973c05f295a25270f99fdbe27c69d4787954883031c024523ac99435f5c38a37a9ff434fc171cb7b031d53c1fe597c67592ebfe8c6b987f652442dad5378431aec259d5fef4d34c2250553472b18c21ee6b1a74e21778e574899b013655a48ef12cd4157701a5e4486742f4f3b8909305ea491405c48fc3a5d039477c56f6dc873233bce4a692b955a85e45236c153493b52bd9b2d1e0f5b47538a2106e152588be330f585ff98d3172a9fea15d55222ecc9dc207958155e7bc5f3e939ab53e511eb50d6a695158f4e0733056ac04b41e649d7c7c68df95e75d68476300a4fb822869ea91296776c732be8dd10377e47549e3f11060533de5f93ad3d6224b7f7697456286d26242fdf246520b896044cd14d1857d2bb81cb1642f1bfb4e12f280712f0e5caa2bd18ba9559e66010363ea07ffb34611440dbbfe501380fa24ff044ecbd6ffd575a27764fcda3f88511c5368dac64619c455155c6bc6983f916ba6c9c8125ca6e3310d18c510fcce8c13e039dcee684673949ca31f4360fe542f24a851514e00a8ed6461f17f894e70eed1c40e0d2788ae0ddc5eaf100a16daeaa0868413ab07674bbbddf8ec811cfc8c3e3b864f1e445c766418f3cbd8063c27205a57761aec6a3a5a5601e5d7e4861cd23037cab7446d23b6be93e70da874e6495d00bc378cd1fa7950fa864ba88dfa82e12a32d410fe57fc2d4f9093ba6cb11c1e41a6bea701e8967c51e7fa838dd9f74f393b6d090fcf87e3669a4bae94e2361b324a359e42a9e0574b38b894174ee764c779182b471cfbe8201005bec6932fa7c9846209c1d2c3d685a5bed7117f13a9d30423bf135afd250859314a254f063cf7f21073ec4af0204fcd3c5dbed0ac92d651f8d2cfffde095819f4320b14907bc6fe1797fa084664671a8afad7a9cd84044b609acaa061eccb03e76bf67581829e79cfe34f0d7acbfd519085d29aa59fc399e5fc95ef9845cbbe4ff2cda599687da8963a3fecfea86c1ef24bd9c41fe74e66fe39f43fb10ded0a940756a3a7283c163f2e18c0b657d6b4ffb974d2b3423c3558938761b5a2c6c3ff60d7efbbd99c776e6206aae6439b3a7e7633a2066ee2a14ce9281b9a9072ba95b3add93dbec69d75f696917a39e158248047a58f9de6e9d89501b35fb1b4c41bd3c844e0017ca540bd5cd74679e673227651f5e86eece5058ad1735a9ff8b9b4c0c91f9663962d75daf22cfa33c7897221f8841603294743989f752c3994f9a174d4fa31eca52bff92a697b9b9e99e7b99b8fcd13b302d477df71c0f6362ab693066ddf1e9f4e9ea1af80cf09a4e89c8903c380807f53dca049e9da9a114cec1017f10aaed9269414c2bb2417fc703926f02b967663ab58204f349ac46ac559d7f3da4211970686e504bfa1ba99b32fc8cbb5d33bcbfd2a373f73b3dcfa0a749a3df91e42e5d6710a619495a921f3559b52a531578e47324b299ed8b75ef5500a8accc7f3061ef25e139953f7b030d5af772468ade2e5cd196902f2b2f35cc969938dc95575850b2b545888b5d9b16d8846e59ded792cc2fcc0e121636e3bb12bf6d375c4dc1ecf875dce49c8a30d67f2431c4e9273dd4c59d14a4a4a4171d0af9aff0ebe25b042f48c6a34cacf8aff55cc61541c917377f12a50fe3c43631d60d968692fff4974f76bef5d19fd49709e6a3a906f2b7285768cf5b50122e88baf086ed7bc59aa554e33fe47cdc51ef3ef0bcee846f1d72e9b9b23885a751ec347c6cdba96d47b5b0f480faacc2dc2edda5575519076544050d16f8fbbf9762fb6f3308d0e2b0c5457504b3f1de8f3f0785e2a4180045bd79be9b2b80e97d74312d8a63e405c811418fc92d3b5a06d39b40898fc21917b26386e35867724314dff15612ee74cb81c25c25184dcb2bff368bb452b37990c086db31d5afe98eae989f66d5de0d184ed9fa97fd93a06757ebd333cf067cb8fa390092d7230f2c45f315914488bccd0475510750d461166b320119cdcb9069a0486aec1391c4bd877a236e01b8810ccbbff2ce93d3d12d5a0df9c3b5991347ac5f9a9483497ceba1628c06704a5faaf793573574a838b45d7ff0e788f0d49159f3164443f4962ba378cf57307830f309d8d402cdc7ea65fea8b8627efc31db8a7b6d6c51758c480730f4842613f38e218977bd95bb5c3e3f8cf85d0cea97dcae02277c820e2feb49a1b9a22ffa2565bacc9c4239a64c28fb26199f3a4c8e781873b9900c9d42003ba8033da18b5f2b82c9ffe365f7b7ace8532b7b4e99aba98dad42217875e0ddd9d3e8d43a8997ac0d623b5cca30ce2117f81c5582896129a7321ad709e51cf2bbbd7f8eb78697b0e675d78195377a295e4cbf4ebb7f487f10e9e4d4c76e8fd336c0f868353215f8e27c0c07d6ad74f8425af52b264f7ea04d24f4e339bb8ea6143d2f6b532f6fa78ad1b5bdc3fa84586df3144fac18727709727adcfe00dccec156b8704f9ac93690fe0de07a3c367fa7531a56ea311c67842f004beb1fe1ca3ab6613b1c317addf0846ffaf464781da9284290279609699fb93d478af386635aab3068412c16e812e7b5f2fadcf5c207510ede710fb6b48d0047196c284012258f3cece9252919a256f1c2d142ec213d7ffa4aedce7016accdd19d81c09364f9ebaf9b36cadcf36cd8637d197065f5d45caa6146861ed6699b2784466b97b692add40e32e81c1a008c2939dad53699a50310ea3ef780f7d5e5941c302cc9ac80b96ee2309e6b798a45bec483d74dae2b5ee2afe0c6b186358eee35f8c22238c71e6c26cb9b42ad1fad510470c13a507da027bff6a820c8140e8c2e617635f84ef979d20f1d9c8eecfd7864176e9a6cbbf5966abfb7c9bcaddea5eb2d45c3f69f8edcc480b5ed37cefcca8fdda9836ca7d38a926f94ab806471618ce77839187fc1f7e0e8109dd72fe2d83b8f20612c36ed0d8e75ea637b1643ab9a896ab8450554d9f3f322ab7f51a146df04f1b8baed6e682cfef467d5d3a1995a63e84f64066115d3b85694afcbc20a481fb7d5bcedde2a0ed7054a1e476fee66e16ad6c49316ce01be44f65f1b41317f178e2101877377d7a449aa2e44bdd37e89297ce45c703b5b7a7a9903aff4f35dd17ab2842590b9cc39a9f6a30a98ea1fcf58f1efee103882967636aecd8551d57ab0f931fcddad57c55b207ef150272ab13266dba657f348b8388ae2ad68e2c88e4c53595e45d52a6e2cb74452adeec3843366e6566323ec52e265a01048a2004bc3e58563e069dd28ae02ede44a7296eabd8f292df9d7cae3ccfa99325266d4446f990313d55f7ed64ecc1df6e03173a553bc1bba1b85ee6607fa88b20f97d9f2112922a51485dde03886e103f121db3fd7884f973c081e85057cb66a17bf1d58776fc9762740f02ff30b9313452e1edf195d9a1926d864154c52f50ea26099f7948318e7cbc0cd40273872e3f8b73ec41d4c0edfa5c409a228313f9c64498dc2ac9a7b91c2ac22fa7fc3b224f0f01e75e60dce249b77b6a98fe1c797abb11f1af43a4b3a920c8d8ce6a343d1d440e8973e3492f37bd7ff78b0e795c24e59c1fd83d71b435fa7860004938f39bc217178da2b6eb565b561dacbda9bb81e74841dafb9ad4274cc0d013489c4a834d6873a37341671ef911d4f424c347841d0738629d0dbce91695766f86828c4f683473d7e75fe457f80035fc63224ec3b14d69c8332c58972911347fb748f888064b2a9dc2ca1020968a6bb264f39a1a142c30a1bf08c3b662fa37a86af09e79f40f5e3b51eca8b6fd9495ee9c1ee5fa9c8b64f4ead4cec9968064bf0006455265f8c05a920ee2e8412908c76f0e943d547d000c50e52bfba3d2feacf6604d1fe50ec26238e3149872d2d03d1e72fcb4980a69da18490b83ccd2b735f930cea40d2f329dbc89c93ea6c3bfade14088d30b0079659d2599ba26bb41d77c10b35c9d9c71d82231e33e2f9fe3f5554d4a62109074e5ff0a52d743f0c567fd0327dba6a24d41132f6b9bba8e047b067b2cd3999243324ec4e80206c0c059b472cdcbf39c45be2862d26bcaa1eaac7b6d394f680c76e1277f3229e159b984cd15c365ab528bd7e63e510dbe621af0c38800c821c908e55fb29c645c0839e63c6153254a52c3f73929f8e7dfe64d40c68653df94ef80621a4300e60483012750cc18f958a7fb65d667d70d7a1167c6530e18b6047c7344b6d3647b06ce9d31a0433a085881ac8efa3724c1d54aacb909cab1cbe2b99cc2169e26aaa13cd7ad808bc1587a094b8f06cc0a8fc4895c7c72229214668ee534227813113a76087bd03c964e720539aee1a8b6dc035e29faf7dce06e35430fbf96a782a5213dc3e14735806bd279ca25f4d2d1e569275d446991b33ec56872dbf25b4003904764cc2e5b9e14c015309c4703246247c32fe2fcbf0ffa99436b59df9f44f2d383d385703b12405bcc6e830e8c35d06025d5764e53c0db09b84ec71072cd068a6cfcfd3937a3dba321fc3337db841f1c427e7cfe04799c15afedf9227b414787db120fd9567ac68078cfb0d52576c55444b7e8776078cb0664831b214fa5b0a4f8b3c9ebc7070d92e7651e227ecd8304b32993117f2e10e9002f0260cfb7c225f0443fbcb772635db48e844a2e43ab1335f07cde11653b1b08fcccb878530319867974f2c1da0530ae593c7f2cc659591d05b13c8ca33af07da279ef865a9f50c636bdd6d85e8fc004e8500dd1c2c8de3060daf53a6c4592867084d69f0bf65c809b984183d278964a86d1383dcb27195f3a9f9424d7c6085785cae35aa6e662aadee376f8811629d31ac190b5a6182dafaf50e471d85c2ae3f4120f65ea44f833f5511a925cd4fe3c8b3046de715f7a48f7dd8a8696b278751e10806841fada42dda8bab17b49b43d60b88adc7685d51b7d200d5170c9861e92d6e60fe63aa57e17a673cabcca39863bc254c1333748d6ac0cf6d7bc2b4f03a58af066373048e318cd8ff45683af6e9049cd886a76151e10350c8d5376c2758520c8dc8ec56bd33e2fe0e2f218600f10a1b6bfdc35e3035f3e8df1d60d2a70fd20f1358041e8088f1df500ccb101f5541dfd70211d9b8325e78e5cf367c63447f31bcc47c75a1f7371fc73c93504a1a031bfd123b955be8197b597df54442d7f0216975d68bed2408bbc5dd766792dd7ee3054d8418f34e5a430a89a3e5f3b7b805a2b45c32fc3c45af4192cfa6fa2afb3f7108d1b8a91ed80c8848cd7993edf9b68c4b5dc436a45c998dadf7c0f5dcc9e5d3ba73fbc31df7fcc3a527c4e3cc545853e271f526c1a3bd1ee35f6293a43473b9130a86cd28f04506006ef5d1dfd86cd3853f735f1aaadc96e20117236e2d88cf0c08fb5bb5535d37f58a96c8ba02ea1d0340f75667a3df3a9284083923c68656ee0558145c4dfa4fe3e7ef30f19e9665749123c94da35788e18131397a15afe78b3eb0decc837a1d40986737ee9573573d36299cfdb33b9a718c434f1b662d10459f1e1a9e36a501a97f0ef7b84b938a82c055138e23ab10060256723d97133875e40823fdf29ac237a250b86bb1fbf574dc5eefec115ce0a56fc2e5834b408b2d4fbb3568b3300beb4b88bc3e1ec36a18aed8ac7fbe4ddb6f2ea608a8c59828255b9ab19852c1d51536b6e1a6faa41f9ff4e79c2d5dcaff67bd616b3a656ec32b4618bebad834eae150a027c2dc2a2f61b72738377207cae4304419b6de5bc09a0124336c378e930a5d1d0ac54f09b4fa2c9e09e05c34abe80857b85d7723a06f1a4b0e7af33ebb99731d11a9dc9a79c76ed960934aa096c88da53bd54bf889745078f874c14ce84973cd12ffd50e2704285531500a4c4ee13c172dc63508d972e0a082c80829a6541b8b05e081f2818b3a4e747d78ec10dd98bb50b7625767e4550cec8ff6a95e0b3a1436dcb56d447c5b1c239dadae3d27eb06efa60c7969399406a000a6fc3dfc091702b34de316aa8a737ff441d3a6a20cf6d0cd587d209423cf2c199ad87f97645676b1d4b1c732f409dc6517d45048e0efdfce4bc760e8203282dc46bb95d0e871ef823781802020492baa0470d3dc801683776a684948c75e3531a8df496c6a6515f182d54d54c1915c48e39c740ddbb1ed6d2167f4b8a32a957c613d928a572001e027b9e77b313eae58269934c84841b1c88f7520d6e65e112be3c854f4449587332ba285a9d8702577f44cf91e952a7e79c2fb89303c1624695e27f8a9c2a038a71de9d97bb9f8e896a75009462b411b980e3b30cb96841167eed6cf852f1a3bdb3afe71a1aafe07edcf3c489c9d6013dd73dfd5ab833b614a854b6acf903b0be343d91a110ecd9bcba77ae66e34bfe2b6ef8a933a302225ed89fdabd1682e01635402e09258e2958bc4399cc1d96263438143b0352c1404bf09305ff8b468b4010c660f4af97657b51ea60ee3cb86316cb0703d6c06f8b3bb278555a0ef4dbba5c320e2ceed714fda6ced751030678a36f720dd6ca7bba385f2975411d731b176f1edd37fe9510e64d87e2946165d36c8802519464367d5f2b2129d2ef185b119eb210a91dcaac3ad34dc80739e3a605a589a8befab68db4ac806deee92c894f240fd2c38f9f597a2cc0e224534b1faecebb32cd59f00e8c826acc77d656625211593eaa0bd1562a755d6f5c05ca75997fb34c8bb12c9a22d899f74a567da6e9b30bbf6c1c52adb1426597dc44340026a6d1a7dac5c6cd630e50055561eb86be48aae1b98ca5b8754a16a9c414eddec64ae44dc40fba5c5189c95560f15cbd9bdea5efaae76484b1e989aa3862e016476b849cc7a6473d297e11dae528f15b96593294b6da0ccec70811c94840ea82695d9044a9d2fa1359c7aa0162458b8ee9879cd721fe069072d114f9053347346291e569fa327642a2a5d59787a73dafca81eb9a9d152d127788134f5e1adfa699ad998df368beaa23a97973557060fba9c2566bfb6e6270ba29af6e73e02790f2a348ac0e65afc39661882a21616c4e10cb9f6d450039cfcd135073a2dabaca95b1f6af8ea067be8eaaf782382214d8578cf41ae374418cdb8de8e3ff2b29904e2bc12cc50fafbe8a9e456dbdc0017450292d3be6cc04804e8948e43b4a32887f39837d4b91292595b92221a2d06489fd4a86a4f05d3deedc97cbeca4880168737a9e7887e3bb8bcfbb8339c6fcd2a7676e94be46dd5b7827c1eb07c414deca798499d0ddaf555968905c454d17a71b395f233af31a1392c9bd3a833c5853f216906b127540f0175a0b823c91fbef83f9f5cea7004a930f011e0cb9d172a0bd8364f3f23e5ac0f7f82ff1cf4c232eb32b31461ea67fe9cb4fa4b009f309cd8731362a5a6e05657a02f9e40789fd4d3e7f08ea2742bd72e5610461804e1a8aa2695a9bfb1a0c0b9ccb1a81d1cab9f662d072a15eab2a6106c0c40375464a40ea2848267fb3aadafa3e3f0b0571eb9138e496fd12b74a989828cbb933f24539235b77a2abc3371ecd5bdfdba64cf9d0832ea547d69c156d2cba995194f94d913200691b7aeb01f08710ac2827724f8f3637085f530d53da795e82a2efaa797f7db3e6f240b8bc61bfa9efa4a6839777e2e824fa457dbd3610fa1a99c93f6f158258534f27218762d3f877e66373571d8aca583c26b7e38d1083d98d57c8106a004c897ac8e18d88e4c3788dfa91db3003e36b405a9cc27f91fe8f5ba08d32cb7386c3381e15bf6c1ff2b956f754e98182e3c3a40655c6a945b8c0494e0f8b9853dc6968c485c638bcaa6f3e58dd403911dbc2dc0df6482487a9e80aed7ff5cc9ef50e9ce45451d3007952ae219120ffdf4964ed50256d668074e95553b69fda7e45804c8c08a8d3cd33f51a7850222772425a5c7acdc06237b9c45b7cb71121af04ded6f964255feab9418ea44bf7a631d93a9809f95cc34a628802af1684d4eedff888a0cfc4fc3438fea256abe656f688d3c4a766834ad625990a4e2309ba359ef604017c12f033d7051b1eee1d833f7a64406a75cf323d7429f811af46d8ca3e07842e91c989444d8b888e4e6c2ccb0d9f54903621dfd747978810bcada5fdcdd3dc40706e17c8f21aaf3f652b01bc8e3a60818f0209014b478fe6eb430a0332c9924caa0874fd24813e3792b2fcd85a31c7bc8b7425ec299f22e1c453de21bd4d62c5ffaf65019457f5e753ea0d5e4a370b09d4710e686022624f3aa4b0dcaeb543a0c373630cb220a9d0762b08fd418d4cac60e188ab76336e26c19c77381c421bb0911c4ee1d88703b844faff6b3c4468de7eaa06fe947b7e9ea74eeb8cffed9249fb7e61373e008584a05c47d9180f152aa613e9a5dfa84ab9ad47024b75237914679fd38f2bb3e546b78c1418e6b6432e3660ae14a733f2bb53525f5eab5042f1b88d7507ee6af3353dfb7e3687ae894fb62c9ed2158115b72a7b89f632bbb15faaf84c5ec27b3342a96d7dca5e7f486b2f8ecda8b29eaf5941262f7117a874e5a1651c9ab37f99446ebf5d0bb592c6fa150b03607b451545e104c77b47983e8f42caf123d96117a4a2f5488b58085126d0e08af550c053d16ed1fea27803a11847030300e7f172cf5ba9985a128730b1e3cf7b8dc30ea660c3511beeb4e4de49e58a5d2aa96e0b4f173b56d440be7e05893bc537a2fd5e3be2de319fd357ff5aa25e8df04ffbf14a5bea85407abe97614ea279f8f0c2948deb135e97b79dba4725d5fd184e82affd86fd148b2c2d2c7a2293903ad7da084f3371c1a52c2181d675ca051f5858820b29d3404c04f1fb3da2b0aa133a1a93dcf230eaf2be564029b97b324c5cae8902286f132b7d80f97cfeb4b430157557cdbdc86c80ccad168a786531a7ed0ad5a614eb9a219ab7de2f0f2b8400e42d560e72b7743e6ebb49d2a9b336f4faa4958e2cb0aebd7eaf7d4549e8943c42e810b497f4d45790965d73c71dbc851c71c0cc06730e9611f9e63298e0cd91b525fc7b4a7c3b1c1be0950e3bc4e6c6e3c9d25e8fb465d41058f54bc8f902ae5bb1295aaab25d8652ce3edba0935ff5b596d37a519840d6fcea02b5a0b4415b4cd9512e66d0fe0ee6dd3dca03bcac7e50916526b001944d097f28978e731164c4281d3771a9334849d04925ccfb344db33f5d7af02e0b8443f47902978c1fe6c42df1a90d9866d29272e9b21e5853527acbb65d85be94e97f9894a84279f1bfdda6e63eefba183a6ed69a874e1f692b80f26b315c2e2ea2148b4b098c2bb88af284d9c3e606ec04cfec6c8db1375059c806eb4b73963c5a37c85ced5ddd6ff9145b7f47ac817d1ca70826f780189cbd3dcc4d469d2e1634d41e59848887caff2910f79e89c0779e50833141a7d00557fb8ea555d903aa80bc450367b73aff983b7d283c6d09c0bc124664d655ad7858b4ea5fa6337faa41428d641b05994f2fe351ace645bb39e748934b229d20fb7398e8a8ac04533607a50b2100b2c454c9a6c8771390be4329fd2ba22e621702ee650395e776827facdc5bb5a4d34e30db29693a6e4369e845da110ab7d33457cb817285b9a7ca299db2b12cacfebabf2ec45326e5ecae8b4d807e99f71e84b0123b09b06b2895d2e551d3fe9adb2ff40c644d75194ce4b33a4a188ce536176df445ee2d25d5b4b7fb15efd3b7dcd200a36f2044926edf530ae07cd685089823f0bad2838ee27e127572964104a5ceb8bee368273b6ee869d3a17ae04ae7d32f0f5cfcc36a7ad356d7e7d6b172d5a3817d8da60e08a1cf3d7a1d8803d8334adae35840cd5d72db972c89a58ee77441ce977b4b8cab4c18744f918bdac1057ec1246dc3362f7060938c0da09adbcbd0e23f518d20b3d64aec705e4e4a7298ef0c4f2667f443a477f9eea5f0d7a8a74939a3c8cc73ada23044dfa004943279d40e7644c7248d9a7fb8ff43e722f5542eeaba9a4caeda18a245f97249bf0a81d4346661b19510719fcb1b125ddeeb167fefab30739a82ab0a8a04cd5a99a47b910f6c8c465eaf61fcabd2c30ea8b8dd89a3b141c0703d022d855856564f828051ce36e9a513096335ae227422e57357f38e61e53e5f980ed9d64367cfc258bc3bde445047a0ab96e5c4c89a7a33280e2774ebebc478eec6dabbb13be195bdd5187d2fcdd4bd235c6489d099ee0bd3539657cde922ebfb98e64decc01682c3519a630e9ce15169e098da0c0bf2716cbb714bd4671ddeb287f6fe305fe3b8e3bbfab603131da10859b705e39aaaae9404fbe5cb03b5569bd7ef91c7812dd7617a5a5603d30517c4bf0a703af6c93ee561dd4ae7ddf6cafc6e97a7f6d0018745e178692f94c3587e770a74cdc079d9a8bc6162498227b4464582d8f54928fd2d3434c24430f523b002a908076e9cce606cb7a66b7b762b3f48d8368611d84b66be06a7889cfec90632051d6771a2395f74567ba4b63862707e1d0742e1127f8dd0ca9cc3f246786c413cd51292a733b5ffb574eb74b728e46c6512bbc9766e835e466383d8ad69d7cabb7850b0c212f052a61bdf85a26819ec4911492b6fc2d637866163e26966f054c55e9f81fb44a419ab5a319ae19bb9d8129e5a0aa968d31485222bfcc35ff562b5a4ac370cbed4e0427665b901db28a05a9d9d00a121598f6e6801e8d3b1af0f8c72848f9a8bed04ea5c8a2ec5181b768e57c46b5779fd863a794f8cf153821743fbf544e26a46e2b6d2eddff8eb158ff6b001d8ba102e2d6093952507103fb6e1993f39cd92cd3099c09d7ebb795b68cf8c68fe7162d7c0ceae45d041fa2d6b9e3b10cd7419df1798bcee55bc96f84a13a202f2a52ec7490680ad10fc109361263e9e5baffcabaace3c4edaf03c0afa7408d1352140bfbff57ae451e7859a8e262adc3b3f212c568d4d74d145d506103a8902404c0efd4f8b211fad313ca2ff74ecf673865bec32a9544d1deb9906cd9111400500ee2b89e46902defda2d7ca4e6b593a42e9997038e18f8bdf3502df76ad8d2dba9351fc3416d82b9cdee211f81f69a1a1ebb125c9eb512ea2329b9129407f6878f18c7444aa3aa41bfd1e0a33e33ce1cbc5aeed848281cbcaaab5eae1cb55f5b9212966b925d63f813e457941de434a0ce22017e4a33c7f7da6166f8956cbc5d664f822fb0798537903f4ee1029715bf09ac6564adffa19c86a5634955ee88ac6eb71ca3e154efac2d178571444a2278d5df3ea390474bcfd995bd798173c691a3104c7c804ac3ffb09bc54d5ca884225ccd1ff0aaeff553febf29a321e9d04c2012f5010ba72870d9ea9ba80c0afcb661ec6e0eb68cd9605eb08eeed9a67eae6e21d06b2650acba89a5c6a1f01a0026bc651820eabd8e373b66dec4a974a78e9c87c661c51bc8832e8729477a21cd15791e7644cf5e3a7e61e1112771fa6b00056334bf017b76b261f3e482a50135542c88e5de93d4727b97a8783950083fcf2a80b28a2ab97322a38a6bb658d2cf70701cb923111233bbbb1f8512c2c2a59f8a61b673c48f697529a695c2502fd876008b33a08703329194f03e198a6339623eec447a429aba6ed3e9240f85b30d537cfff3da887cc959150f579762ff1a11c9275617f5bf28eeb72148c05da2b0339275b9d71c05eee434bb382092c99615519fb448ee2114e5068a37641d2f3f9fba3a7910850ceaac741fa3444ae20e8c16ffe4d43b87f16488e3b6507a188f3dec886ffec9623dba1ea9ff44bf0fbba228160662af68a33ffbfaa956551cfe0cf51ed702c4aefb1737934ca1987b61bf5953a7ddd672916d215c1b436d11590f99bfc47dd4b24d7c5495c8f11606ae99c7ef70b9faa6541b014236b22d4f1c5bb19d9571cb16955a93dc141fdee633f50396095bc74e736dc8e4a57d57f581d94c23a8f3f8779451db98caa6ea1bd2666d3f0ccaba01bb243d621133219f40c849ccec15efed8dc27e1c9d539c471421e880ad3fdd2396464b173acfb1916a363525168d66fb2330cc7da80991f7e8388d4e30927e150496eb78877a7b093b758e2ddd7e14e1066a033de7ed0505195687be3780f71397361cac57391fbeb3bd1bc4ec4cc78b92973ce2040c146a297fdca0dc4f3223a5ef39445bf83ec47eaa17f2d5aadff4b1ab7cbf2e51b4f9515557a5c708beea626ff5d2070e8d8282358e31d278d2fa46f7f9a0aa6edbb471631bbea22b2690465f009c524fcb302a5130b94ed6bb7ca924ac3652f9162d64dee46352dae336ad86e41a3c8e184d797845c416d3c02b24244b14fb05758c20e716e48830f76a3cf9796f40262df550fd26816061f6f4735f494cf80eba84d6d692d5f0b89adbb4ba9bd808a3cfbea7d4602f882c678722224c66bd31790746f077ea4326b1ead5856b9cc496f5f362629d745e7b519af5442e6be17df393d884ace5ac1091e960685793f83f4bf839291272c25b326c26d6ea361fc32598dd2abe4e7feb5dd6e2c460113980664247a3fed92451f508363ae6ebf53be417ca2d3a1ea44ffcbf8d1e8338d2b3181873e5aad5e5d18526edd32e0b7abd465bcebe9a3bd4c64d324c96d1919b3801c9dc826f1cecb27fabc7e5ffa723cc22ee37c89698240be2546dbe756d76246b8cc83361611edb79dcac54a7d45476b84cb7869438bdd9c7d2ea476dd64a5ff3e48f8bdbb02095089231ae8a45ab5a9490248efb63e7592962ff302b328e13e715152d11ce62ee91c9341ec3d2f50441e3154d12a8e8cdb8298cafeae7b0e2ca3e083c52353c5fd04901e3180f8c38e91304c83162e994628c35b50c955c8b03b12af33b2bb86fbfde2d7ac960b41276808221eee8ce91321558e7396b95f61a1e784e2c1b93e6d234876f62f161f95bc96902863cba56cf467ac0c88626adcc0783bd5f82f6df8e02b5f0d8419628ca00fe70c1c1fe44263cd84f9d98629b99c47b114529196d66908d92fd87a528f4780566ab6bf7b5c2c8c3867b825550871a0320574274ae2c4886d296ea2fa13e7edf42a2c10c337468020bf19fe2d940a8197faa6e883f58fc7373e7ac7327dbfeecb7c161c2b0180c5d89e66332a18ff103baf42eeba8b042c303e43da8ba0ee3a19d085bfa19495a41e861eb4e89c610f63efe8b397c9324755830ee1b72d194e1e98ed2541a625229e58782cb76d2d7f6751cee3812e9c37303d4886517aa26639c19db70fed27b74ccaafd21130325308cc5f79d2b4b7c9d4f0be7341295d725265000128fa814a928a5b55cb87b81a327466e4d3e2a17a27a61d016eca72831d8330aadf57023e492194b5e441a22e16202c1c36d1c2b1811af32f3c30831f1434a206d6f34efb45539e1261ae24d408daacd4f3a8b1836e6bc88c589a187793f4b38bd89df33f3a82e1226926c6de562e8cf175d07636b060d327bf7214340b2b1de2b8d7bd16147d357522dd3380cd8c3c0b777f5e88ddb625d6b3ce96763b94dbc6276d3587988f78b530a5309bc38795889406c02d03ce3b8589143edd3e734cbdedf3fa9c35403aec69bfb6bd336b37080e43b6e6c66ff5573c8dcc8b636afd7d24d8165f19e9e4e847b62d2004368406c320ad2720900420cc941403362c5c1599151185cb2827b1d52dde808f8d84a3f465bdc53086f062b25a1a403d3b771f2d739415344b0a8614d6710c4974d2aa4f78e1aada0ea8efd2cdd22dcd5e59ee4f4ce30d42ea78d5a6e55f3f6ed7ff916273462e980c0b599c8e63264a1f6900e2d1e6020823c9faae1a1b7f2ad02091ce8aa35b329b9dd88a585f7332cc777c41b0e8b48cc374f2eaca2cf8222c449c0fc23d1ac4b728ad0f9ec42cdc5ed8cfe5cfe13cfe7d713cd6709a869ec6b0fa8ce43f6ab316bc23d610f9d312c95f1f4513e634efda833c334f65fc255dda1ac5ef84af95ae416b49b649285271ef8dd4ea979223c4b00fcdb9d95fceb161fec0e53e1b488343f28ba312b9a86fe3bb1a52ab24e35f7bf79c56eaad70ed7e3603af5d84e7b003a0e07be68d7cb323f4ab73fb6671b6d853f250b7b33cf836c03a4f40bb949960c8a5e71fd69ec6df04a8496909a8f00d874221b647ab1cd15f50bd14bfa7a5f450d7a6750c991f8c1568a6a4f3edce9a82e53e1abbe95c6115a691ef6ac9a3a4a89787e0c9faa487cd3ef5c6b5af65edca87b7376f0b35176e1f1ef28432a966ee463c8f1b729d1dc7d8f26f975f4aae91b1b9d34b63e4c6a5c438db4dc0aaa836ac6da30e0c79f2319de6c415bc164dd40adbdbef33062dc6704e36d3c89cbca73708281d2c37dabd3b2166ff3363944e819df98b097fda23954e4f5a5045497dd8c6141dd3ecd4050844efb2f0b6c549669086a7fdf372719f632fb7989327cfdc2d1a3a31ed2d087fe5d37f89bac76e028e61875099336db8897ab47c039925b6590f9532d7cb3d251e9bc80fd18a2a9b45aabcff52fb8d7910157411f19efa33131dc82ed34ece2bfdef895961c537a25871e4d455ace43e85591b58952d0997a27254e3e74d1bb60d4115367db06a78562d2b69579977e305c550ab5a9f1e79521b2b1922daf88858aceabccd65aa5707a25c41ac26c88c3e8916850b2e0a456f31676a971dfa77bea5cdffdaf1fc71386b2ff7008fb93c5e9b9bdaa4650e7fd85c90e9c3c8d9d3755942a63b7b238993f46bb7fa9eb75989564a27053e6348a8f2c66a3d79a210aafb19cdc3208563dd63b5d7aec3b615aa291334e112ff3c2fbd9d3af3498d64161e23b5cd53106051a839bccc1ebf0ec12d49ab0650115214b1732af09df2a389b889ee9b370a89ea9adb4e8cb289dc26fa2b0402874b8f7e89200741b281728e67f014d9bc0759670ab242b43772d83a67fbc5e2d017ceeedf0e32ccc0eca0f364de42ca9e61b9d822115cfbd2bd02ffc2b8be6ecde63d4603363d9912f198bf76ace0386b34cdcbfca2e0719c74046129980736cbec679d360a0d4a754257b14e3e4e59cc82fbc180525acf013d44fb40a54342ece2a3a92b292ddb56d5ead79307fed153643b7587e4bae0d0a4abfd7009ca02e1980146b6f786431f8b4401621b92c2fccc085e07b6f5886178799df5f5687275463442bc049c5fc165b77848503e1663e4fe08f5ced023744db4b9a5ffb004a4f00754a2c7261aa425675e799cce3edd3678c034880c40ae0437feb54d86667097fd334366c778375753ad19f508b73189565c458f6074e37224bfe0dc85084cc24ba0155dc413d88ce269d6fa5ae5968d4a0069b289817641b7a70b90ae121fbc33b2c054aacab7abd9e9683ffa92d638e2b6ce0d9d0f01ec11035d9db91b4503c638fb69085406db8035c64e6f509b758635e0649150d2d4f0a4ddccb85995135ec40497ded919af4d082b437f3e7cfe15e19378c98b04ad1b7d1a9dae75dc590e92e706e988d935caa7f33417366a54e6dca12aecd455aea912c9d874d5c8634b62ff1966c48788da11389ff5e3e0be74d81fdab8d59eb8b17b54ef0576dd106d43992c05d2042905b767ddb3ede2c35a184e4c0c5872b5f799ae7a0a99d878a154608f9361d62460b0a28f26d1861a231db0145223484d8f61acf6644b200011a930cdb6892cc9fd9bbfea58538f3524dbfcfcf771cdeb2b734863193dc5325ac8b6314f6bf12a09a6407ef8ff922bd9bd275fa6cb23c11d9b47d4a52c2697ce7480859c559d6a82fb635dda9e5dde5f42cffd05814b98f240e04f5231bc8c6255914d929238bb2fa17044b1bf999a023185c8d6c21331ecc467bdd9d3dcba375823acd771b6742f2700e6634c0be72c8e2d3b22ee292aa05aa45940e97d93fe26536b8b455652560c0c89b6adb13a3a2ff7a14b3ad0c933a5294f3e54fc2ee3e00a79b919e8ba4bc29b2c0838ae88c848f940560285bf25071e1ed9336b28b6594cbe0eef2dbc3b4bb321113b10b7aa75b0a24b8d497991241bfc885386fefe60f5973467097a23a43909aae51b97dcff2a443226d5d849b634f2a9b785b497e86a45047d45e21282e3c5417eeda9214073cda22760b298d3718447fa8cffb5dc442596bce62eba2e743726c39bb9e35fcd5146986aca837a1ca979c59193dcd948dcd6bd42fcc400e691a8565cafe23281077a41f7d9fc82c45abfa111596c038fdb537403c1a1c165aecacdf50fa6708fe84b23f1f101b50a9ab96e5dd218f10189","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

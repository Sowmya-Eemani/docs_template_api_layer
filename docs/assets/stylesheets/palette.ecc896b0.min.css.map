<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"512dd760b3c299800636c4e7c49f9af24d24f33eb1e55b8c780cccb298af3febaca0e3770e36b2f52ebe5561b24b22f61597376b183979881a20e79d4e306dfe367dcdf417fd69c485f4c0e2adae17ed927a2f499fee10a1ad5c73c6bd2c3432cab990007d7501db3d2a083b26dabc2f9582e75ccb253ea713a8635f416d467f38daeb71bd625c3f0c93c72098124e53ee771a95451795fc96025d602aeddae801a07a129b760febe6e49c3c066542feeadadcd8caaf71241d9e01aa75726bd9323a10a5aa0224847fafd96564b6371e64c036a61127de65aecffc6dd7c860ba385eff7cefea8583ad49320f6c670ae355569904c87a23b0f10cf53b3b9f40e0e5dfb69cc507d203a2cde7e63a911410ec097c4e9361f3a80f7a384f90e3ec44c4d63bb10604a7e524e43c8a99bce3f6ca60abd6e09cea09b39272b8ca57995271e0c8933783233ba7c37ee7f6781897f4ed76f243bad17ad67b08d27e966211a8f4c612af2c8d0357499a52b72ebf8bdeb945e1efaa42649895b09e229a8e6dc4c774ac67b9e56c56f50947f0a8902b68f7d082efe2c9eefd29e70dcdb2824b8f4eb70edb0ebd4fc101d41be5995dd1b468927cbd999c394a71b2f8477df2bb2f42458ccd205d9b8781662cbfff4ed39ff954d4ef4f939ee301ac014a29222857cbde38e08d6a359718f05517ea352b6d78b7b3da8231dc61fc669d972aeca811d2c1d91a1603ab7fd7860fe29be4455b6ba554823a4742620c1de8182281dfd772f2acdbb2be96ca55a93c64d4ff89e145f029356daee29c0ac1d67ffec67d31fb5c4ba9ad50d8666b6d74b1c78586bfc284bba5158f40d25ebb0c9bc7972a03194f15d8439208235760b375e8527b3dec91c1e5bf51620867c70a576579adb72397121b8b5025b83ee4e7378e7a33ff6f6f612693dd5800eecc45ca87fa781ffadf471aae051541afcf2a0923e2c0d9c8687625a112bc52ec1cd009fef488764b97facf9fec7285f0b22db4b84b5ca75a74375adf9dce027ba24b70b67b416e5b8ba2f1a35f06d3e27bfe6158efbcfec57d0f398bc6c996603d10abc096e49e0225942aec12638757d56f6deb3183bea9fdf5fefe45cd30e1fdc07aafb504ef8facfd9bc1575355b44a87f9d47569228ee6da516cbd7e5228612e36d90314645dc9b6f31338f3d4185b73074196b46ef37c744c0b1d011ef98fa768f69dee5993cd022ae5f9d62f283e83ced583b513efff650fe4a41831be039ecdbe516d19bf8c6812f0866934e795d561a05f0fdf0abac0f4bf029b9ae41ff7b00490ea76e2309092f6f614e7fcedc9510af345d52696ec6462a01d95ba94b45601f75e2a69a28d5014985a714f54741a65ec97a4331d4610e84a4d3668db89a4552b31febf3dbd186b50256eebcce14775174ad56749a65434d5aa82dc0e2c38eaee16573bb85fde089b3311f8509209abf19a1bcc53bc9f02b7a808644ba68641582e5c2de77b7db882d612e781362e6ffb2ed1a68b0bcd69172e3c4364c0a754c5b0cf08c7deabe776f948af7fc04bb3b3902199d492c1709ca3945b7830945324d04b5d459e8554387679dca9d7e673a0258469c4fdd57379c8acaddc614a76049357552d47856215d30bceca132a0d75d846bc1ade033caa81689936a43ba5d92c44545c95cd9c09f388fef4cfad9e5a2fc2648d0ed2b7f4d8d0b745ea9d140482dbc3ba1712ad93ee3c8d0b414317ae8e85f527f871bb172ed5ae9dd0893b7678464b3c891a918d5c1cee4412f61e7c47427d7593b0a1fa1965bea5c5a1bcb2189a090e8d65f3214ead0d2b02f957e66215b8c86cf23063a5f648d4f0480712661186ea20ff37e3e1df868d0ecc114970fa9b90d8600d0c1dacbcb05961a6d9a58995190ad04daa36fc0ee8e3a307366ed1fb5d0a3550ef0195812f035484fe7f6b0295fc8e3e51d47c652e3f35667762f8e262b8142a8d31b78ab01de8907b825c692ce2b5f9821c19ebb9f635bf58dde41f5c879f906e7a1664d577e3548b42ed3afb3c568d50cbca7824d8a330615fed703019d03af0fdc19d35e5bcce260c76a45b20ee1cdb54a1ee707030022af361fa9e4b7a055b689a8586eb66b584c1ea6a4d11ced19ae35e5b2d9e326a7f4844f9f06673672f32e0023b58dbfd4c8c7e724579da72a728b8a856eaeae2dc4290afaa0818d13b5a5805fe6c1fe11a10383294066257b9dd56635329bcf2c699b86f172fe4d0a19cc529328df87e1271c616dcd4b5dbe74178f59ba4eaa75c60ff3fa7677912c41ccb8c20fa2b896fd9e54c4a8574c299112f249514f2822f1029ef8e6549a35effda52954a4968c38dc3dafaa652f25c5c71f3e330864edeec8858657a5589790366238a41d0495113d07b8af2966d9af01e1c5fbcf1030c36a547e67b60d581472394807f244d417eb6ff57a1a038e2db61a295043dd4d7e9d9783c93ae52f3636dadc590eec319cb3c2e615fbd3346dc75a9ce7cb59a3739faae09b7c245a653f836a3a3ae5a4cf4f5aeeda37bb49c80ca582205e2b32447341e980e33981cc7579abf580189f831d94cafc8e0f8cd39ca7c303230e65cb76ec3d8a5539709bab593a52e052a103651661b20e5181af137dc53b6c0b954fb9c05f7cbe3d96cefa3cd445554b9c01b49bc12090eb36adde5f02a425ffc82bd6a56b26f88cfcb3b1170084153ab0de6b40158a67a6ba6b9393030a1d0f5ab871293dc97816d6ca16b43db435930f6dc662a52f3cebdabfc3a09c4b07d0c68cba8d42f704b53f85c68a8b2fb6cfecab2336e09bbcc2c70899aabf92c1ba60f277a334f7939155a87ff635072c2c615ff0d609381dde6e440e7fd7e8aa4439ffa209fb2cdead807c431abf846f95b8ced1aba4de5418223125b866038d1f19b3ccfa57614faa86ffe6c14640ad263125effb1a6220adaf5b6edd4f6b036dd2b43d4920a13d514782353b59bf38f3b9a6309cd298e7c8a26a1bbea50b360bdf509387fd5eea36f395208b0b2b1d64999fca0c57dfaa2dfa19dc0de2e4fb0da9c247aea748afd937d8bb71f1387273e864697831c3585d08794ae37d000e2aa3fdc9f2e40aee4ef5cfa0ca1a15c5cc8019342ab9fb2760bd51d25bb9e71339074d5d56c6b51ad8e89265a6fa3304724bd74158ad39b9fe848d4d2622b78a8f5e7c53fbcc38dbf3f0ad40d68ebd3eb577ca3e713689c7d92b7012f0405fbf4033a6a4148ccbb3e1995511043778163ea0cde9a506759f45a9b043d715ea2754a4f2dd7bedb520fecbbb58657dc85460c2b5f5933ef81e3a1c6b23976cc52e9ac12708b5b32ce0e480fd5faeb5b11cf325125054765ad8962e25ae61d3e3a5118d6446336537733233362c981b6366d857816e7a16a4d2a76bb8ba1a72c2fc430ef05577302f5a68623f53ea8a8e57a459f68f04fd2143717ff0fb3a9131513c9d3a281700f535c8e1faef804595fd751db4ffe5984b994f409270855b32913402528b6d00b9bd6273f5a4bdf18a41bf18f5200325f74f5596e40b5a2deda0a02886981bbe916d27c47179af302ffa42b4ed1df15f055b60dfe3d9482e2875276863c5e8a9a425b9bef0c2c0422152fbcc57671f6115d35fc0911e85b896946a3161ff19302fad026912f17477bce05f71b59d31ea3706e13e8061d1d61dd706d2f796be932d3a76fbcf537a9a8c2d06bfb8fce4b0010d45cbd3b0f3fc2ff4c584661e5a63e371460e460978a857cc475100076e03ae3a786148085d9020c3eb64c44aa6c8f3965b0430de63ca27c7c8b0eea4db97c3bf1cda6ec506a42f1e08085704eca1ef48c0452ea6789e2abb1d729dbd62dfc61feb707fa7237ee4ca5a0a0026002fc868600681acd25b87d05d9647bfa87b66075c14fa1cd551b3a318e51c2705c9c6bfaabb2815e5d829ebfa17b2a39fc04c43d7f338194e7746028988cd8abe5d00e98a956b86504f59ca7f38b02dc20c430d2abdda6de3b5c8a4857e7f3b6544403ec43493bddb06f33203fc97d52a3067333643ae43b0996c9074cb1caa3ca5dc46dc15002a8e5cef6b8ad15723880cb01b0524ffb9e860876e1d1a535dec4240ff91761e271396c8813852f38540b5ef807e0933877f70d2bbca9ed0571effab3156078dff3cd23556ec1b7e5aa804760c2d1d0f2d3253b10277eeb8c293825095b682743abbd34375869faa4c4569fa517fc063a499de28010b5fbdd3a8bc85941444a95262bdee94a18e83568beb065466ac2c2b740129902acaa9ff215aecb3647a490d7056e4d6b67b92e264ffc4c6cf7d589349c4f7d75546f75c0d37cd2042a399754486e15183eb2de6e984a2a61353ee06717475ab6a0bff26d6a855024f506497947ea9b54bafe2188ccc4053ae2522adc56a15b7bab57e768092b8fbc19d5ce31c5a3e078ddd88678a2f8e912da5af2daab88c89f977f7326cab5d414b7634c812b68cdbb14d0c63cdcd43dc66b05431ef6af97902f14ac30d12606d58a674dd99427c92e98cd8da6226499e1364e394538209c275fd98c8f465a9dbab719d74e8d5edb074c59441e35e586a4b64f269714cb0a5785d9c6b974d0c4a88e8a1f1ccfb2d744086dc9e6a1004e0b4b5b6aa0baee31e0778960e267c139a11152e1a44b9ca5d54a33bde34d9ea20c5bab2fb5c80c40e38997bd3f0c85fea584845b83fe3b0a0bc6e217cef5675f9a40aaa1a0053d284c0e68b279ddab8174960c292300b9501b03a183aa4c155586fb8950785ab9ec75cc473af244f79bfe38dd4d5f00eb4136e3ce968b1b6406d19a40dbd9e2e4515ada21c4d67e2a6e5008b8b3fc781f6fded418108cf1e9074a6362cbfa87e96ed763e2cd4077e96860ffe8ad8617425ab0d611178eb07e00457de6b30341accb5003029f7899227bf932bd23e8c6f90585d8553bd4520b9f6fc8b845f0040cdf3fcc59fe6268d9071a1b994d7173e82aae5894368383ae4d518827d6f8b723f024b4a10a1dc81a7ce3c8de702169f5d93586cb0cf0a8e3c0912978f145eff42528d9bfd01f0ed54b487462e209410fc86ba966c66ef81faf29d2377614183c143fa1233903cb1d12a687c84f310aeacc0d3aba49f49d80169a6a31210ff75e300a74ccaadeeb6a1bc4ff8b5d24b9109ff45c645ad07cb869bcae48dd4ef8b2d81a58cc0bff0e0d1d7a9a49c65b34e22e1bb0d3e9c3134880e503a1e6b97be2aaf53121c5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

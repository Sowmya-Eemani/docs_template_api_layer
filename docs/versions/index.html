<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"074dd56b7c3e661ab2e3f89a36874035281d777cc02c725975ef223cc40b59498f79b60e3ee309b23ef99c15eb0a2b1cb3f9a88a3cbe587a00fd106acd5fde6c89d96e58efdc500c9d7017c6f60527c8bd818c51f3530d82dd803d703dd53e61cc77cef42588c0f82406d5a88f35a606adcc7a4817fae2a591c7735f9cabfd19bec95c9f2e848814d84f6a04980b2bdcbf8dc5406da03caa8685449864d81f915e78723ff5935916cc2fd1f77f37d0c4f91980e5b29360c48e169094acfe2397baa12cf333c8ef523eac4811bf3fd3e3e67af4d96c5e1a58275a2a9fe70b55531533548503cc29ab9b979f02eb5a720fc508074d9d783b79ba21c30147c65fa90ff17c3f9aa9203e26455892f893b470cd5418e5b49c53599852df1c217fefcc13161a96772c0b2bcd3d5bd2b10516d69be66df674be0ded63c6a12e35baf01f8168194609169d38f26a3942a5f28591c0af07023682c110880712596295a170a138d59e8944fd8fffd74f5a68329bc92adaec8ce7a795165f08cd77d5571d73828e951e5843e43a2205d81b9f767cdc1a47c132f6c28f4c45c434993444090bf085647a8217b2cbac7210e8e67486470a2628129e27534be21fc0973d37d0c93c4666926ed92172fc7c2b171c36cc43e0ceb7d3e7315091e12eaf3170745216286c0e33b24f1944e98ec6411331e9f74898f8e02dd2689e29eb5042209fd7de69d9990c6085492b2181c34295d69eb18149b6d1f4ad9a65a0e6b7ddc22903cfe47da01e01b6ab807226c83b4c77d99137f6ae355221c29f10c46211e3aa678ec03590ff70d6ea1441d12b2514a0800ddb63c93e15bb43121f39142c7661f0ae7c524f2fbf62ce2ee23917a2aae6030f152840f99dda456afda35529363464c03a8b54331c993768a23e48efd9db45c2783a2ae5511d9c19c4d52b9ad944a4a18d0b59832060c96cacb4600b9a5c66eff85bc637f764d2c7742fa86dcdc4f03eb8041b7546829e7cf294197c60892287433adc8f4e484d58fa1b8721f04b32c28adf4ce079eadc8c32852c622b5f789a731911dae6a88eeed29758a8b4deeda64ea31cf9b23af711b31902c7656cbafe11a48cfb0a72f2876e0e7563f69977cb47bd72e17bc5ce333c8d19eae5aa9ce907de974bf19bb47d3f9176a10402b7b258de52fae3392294eb26439a6b47b055ed6cc36b5098d38cc1ea69986f980f1c02373680e4ac89aeef5b62783ebe56b599424738cf393c3b81661e6e669ea7488fcbcca01b30550d34ba5f23154e6e22ff414c28dcf6ad6fcf42ef5af08b3a20883afaa9ea236d5c30b9a6fccf684176efe36e0cad34fbe84966abe5a0fffee7904609d8839eec2b9f856687f1bff1516f3ad54aa253b3a6fe4fc86a88c6532c771a83b023d2fb1fc6a7842d43777beccea9377c323061da3c70fd08788fcf6d426b8edf86e0c1b9f59afc19a97e94908886aca2e1b7c157c495de6db34aad35a529ba95f378797c356108c1071f49e290d8d872fd3dd0f7c77e9282aef7800b4ff85ca4b8d780ea84bc024beff60ceb91b28d4573fba6e2e64140d78c42c2c960b93fa74811dad4e6f3552c7dc1fb2c1160e91f83ef4d61e952d676d33371dc616e24dd4ec39e0bf789498ea4ec507b972de868d98719e6f50bcbb937f6eb677a88e968fe6265302071845cb0a13f862eae35af0e6787f1331462cb05221a846cb2a3dd15531dd95dd84f96e5cc111c0e41947aa0730b3f9bd33fd4dac52b5c383b524601cfbbe8468eca9d86adaf247a06e0202a412a15c6052dcaaf19586cfd7b1117226e5b9fa4248ccc648e4ab2d12e88b66acafd6f834dc473c55f9979ade5bb791b3ecc382e3c5bff1ddaeafae4632827010207631caa99a098597f674890911766b6a32220422d555bc236b54ad588a954a5f1b94b1c47f85bec93720080ee370fa0d7b9e497972c057684c5b72c4e9909693de525152ae19ba870986983a2eaae7ecf56ede5d3d473e7b6352500276dfcb391d2bd75dbe26dc6d44b30ea73a85e00c2e99e292ddd9af8da32e7fd0668c343789cd1ccf7988182c205c559892da119f8a4eea7707b2eef518597959a3cd8aad436029cd006d4111ad6f95191d66757aa032b2c5602a2b8206a99acf04ab41e8a557d6c5f3bfa01de57f6bc240a43edcee28ef48a66ed38047870b0b27f63bdc922998d7182329c3b9d04ea02b7ee09e145b82b329e34e50ed1508347604b9f8f893da67267afdcad6fc7222ab5d23e434243aec0fb69e67932231ef296b02467ea7bae33ab0da2a2877f1eb063bc43c09053286979a7e608cd8e86488f1104456a1ce1ac8acfb172ea20b660f4799905d9fc1e65ed49f65c43960228c24342ffcd866cdb081acea73398b06922e7b7bd711f91a2d3a89ca475322291a4af314df8e38114e219c84057315b439970d1d2b305650ff421fa229f0f25ceb864b9443b25785ace79b87e2a787c93d0ad1715792b71f57ac0486527177849207efafb80e81449ccec26eab14f444174477ac31cd02ef08b0f56586501a4b7941191f5326c04528b675c8177554019bdef2f8fe8aab1500f6428eed4934e3a8c986a174f953bd6e36599cd133d2cd93bb7b32450e9614731fb97c8a1f9f96477d9d307b74f09bc3b2457e7c5b80841c0a5c24db1791475408b5b5972add3529470e90081edd127ed212cadba28d0e2dfe3a34ebd2355d2c15eb91518c5ae02bc50df62a8126ef65cb6d9b1cb76e632f83943451cc175bb527c74f6c0ffa0d90244e9951ff8bbb66dd21c1c23f3b6c0763e53ba146257bc15af8e1790ad1fa01db07db73b13d6900896ea0ce941cd240da0fb8c6e81fd7b8da168a5a76ecd5bab49a595ce36aa5d49a19a4a5568a3c2afcd1e4c1d7a0650452b06f8199b2de6e4521b3269f73a6add332b720c5adddcdaaba2d62838097afdd55132cc9ccd1617d970e07c3bd62fa23d7fe5c55f113dd88ee9b6972a51750a856c8c2a85d2f568a296e2f481cbcc03258e0bbf2a7402d7c52be37de7bcfe95b388332d9f08e30554598f8f9c934b55666f8cfc2df1291ceb788ccd9f09174f040241fa633ad2f6174fd1c7167ccafa89c9ae12fac33b85d312f1aef11f01fbbbf725f3c672434fe367d1ce67aff517e741998a163c0f76bb3d3cdacf00db736d8a16f656a448b0791801e5380a04f071c6dd1dbf37ef69bb47f97ea7f66aad854945b36540b26a1500fcddc3e8ca768634f44b2fbf763f40cf228543939615daff4a6908d9346f5025b4a87ffcfef7eac7d116e9b7ec01919ef343f2fd06a15b49fdcd625d87c59bd43bdc66b17936fe45bfafe8869a90d3131a509c365d5004727d1b64d77252de415f4d234f2b2460a359133111273e6cf67f9f42a1e065c052ff52bcdf191fd1dcf94dc1535755775d68dd8c548df342ec66c3999e8fa7cf43322ffcf4fe0a6433065e271e0738945b8574945e3ea8fc4f1ddc75e8e118daaf8d27f4a1d77575fccab8b027b1da764cf0234a92d0312dded69d473a8c8be00ffc5c396d66cac793d800cba93db3fc41901b7262f0dbb7262cb51e7ebd9631b2091dff488cde596ce0b1468d397a93e029f65ddcef2cd2169abeb8e0b98c6c1793d079cb5e25c518e70c7af2e2bc283a6948c1e84f6cc4210499021d1a93f81fd51b141c5b684ddaeaea85a3a969900e943bddaf9211fe0e5c6887b06df29f249950a77e1d53ef0e9aa66dfed2f2545023b4c9456de10ed91c7f9c9a1f78e08904c7fcf9669e0775cedcddb5a619a067fe9b94c2685fbad46aeb052676db9456aefeabaed48f8eff4c7968962a6ffd3225dfb555d1da02cc81e9347d51434746427a7a99da9bc0d41072497173e90a1121d29169b41dca5addf1feff40d87f832b440fcea310d18edc9ebdc9dd43d4d1d9b326a11b5ece606f662cc572f2aacf6cbeea474cdd025d874f08949c2233721fb11fa1c66c28b8c36a6107b8900eca119950c5730c9c4bac030790149c7e870d3953940a65fc24053d02a6c2890dd85bcd1e5451481fbdccac0ecc4e69b0681ddd9a11426d3c7ae9068ec715db1dee36bdea3319538405d5920c9deadc6eabaeef2520e50ba95b823b2daa56a9a138703ea37511fee774e5168010abbfe56a44342c7fd5ced58b590f0adf6eba7b6a731022329bd255ea80529d88b98437ec68ac1f900e6356460ffbb42dc206934698104392cb935e2f270cb6663218ad2e303a9a41efed55d6cdf833b88b3d833aebd4c269334752ce25d473f35b85aec0e6817bcdda710e5989c44b93ff9ba974ac3b6d0182b96a16c14587b06cef14c18905558fbf2b2b04c6082d1005dca79072921f38e673660557eb23666b172f7a4e5f00c6f5dee25df5200a0073893a7383a324d7b49c57b6ddf43077e03714987aafe49c2d431c827613ed3c68622f52c572a4d00657fadd8448cb56133c57716947e3e75c3d0df2235669841bb91236b6a1e9354c0c6a4e0b8df3afb231fe91a86011f8d2753edc5d21e6f027a73883a0345bd07f88af4ef613cb95bfb31c1e14d02619a2d46dc98791fcfb3e5b0b2fecbe5d73e9dbad6fe572eb35e6eac6d21275effc038afa7f2e211302f5af844ebd96f475e8f36c44d0daf06f8cf99b79f675c8834217313f7f8c28316fe51d40857d67f8a232b2125e7064bbbee7cdded5e75a7ff90178063ad3cbaa266bf4755370678255ee2741c5a39e1c8ede0186d80a189e23c0b1e94fa065c671317cb29c9af4399e75a0d0760e3c5cf45564dc2296c45f17e95a03bc31aca1eb8fd5e54bd036504076cd96fe0ed85ae7d96eaf1f4e12bb275cabf38924d4847545eafa6229d1fe0f63a0986097272cccca87e4577b8f98f62eff242e08106958988d6e52b0af7bc321de5d581d674f3eb185864205ba180f2aaee9143abf18cec20568dd3386d42c2a86893416d5af62b0558fe37d21c34bcaa51da0ac400358b0de37af53425f241186707a6ac37b6b3943e22e2ecf8dbc43247785c70476f4a26bfb3adc253f67316ce60f1ac53af4771346dc5f50b8e2f960227fb97d4459d1bea970eecda194f26b4da209b1f2070d60653c1b69cfdab070f0eb4784873c641b50b1388ba3badb20725d77a482644f827875ca70fb315a13905fca3316411d0b83996d6870c94fe6ccc7f0c0f999df10898ebb30c97199c4ea452708928c686dabbbf3a21496fff1ea24cbc80a8b8161d66651bced7cdfc6cf637f43597bf8cb3a1c4646fa4a937c5ac5a7776be3854de123e18fcaecaa9b8fb99e379051f287efb37b36f9c56d971bc160cba39f87ddc5e530b2e73cbcf9acb0e737fbd7ccd82257e41236dc603c816b0f6d16b0acc428495dd66a3f20d0978f2f80680d919947109ab966142bcda0fca293ecc95767e976eec0fd07e85a8d1f21b23e750d27d8c60c441690fa63c67e3040a1d8f1da411de2667e763b69b1b5855dc68ab5918059d31a9461bc2c87ed721836c95c6f8767c8949aa21fbbc39616c4908127e3d0c28cff09da33863c881d07dba3851d1510892df859d064099b7d8cd293b1a53e712821c1e0d035d01fbf6c340a5b778415e1f49157aabb686768cc34d221a9469db44b3aa6c3cd2d011f4acf81382cfe72ce5f625785b5f24300ec2933cda3c7abf3075bb269bbbd17f5f056b1b4feef0885e51f141f8a728a6f7aa9ef881fbcfc297cabe6ebd0041c0899f9a8a6d086f3f64036c1460ae3dd8473852b640919ff94ee3294c0de306c61f85276fbece615ec9695a0a5b641f9010f438c15fe89a51921a9f1b451449700ed4302938c31c3c6afe0ee82e5e03d0607ea7710a47de84624cf7a6458dd67ed6afa16b9b272237d355ca219cb2445bb15e24b917318f55f9dc327823178817543f05812aa08f451007f1159c885821756239c9fc99e0f7e2e9f9dc578c316031366fee11790a8f015db647e58856c1d1f0bc1844a4dc0f2238a55a1ec0d56d632f2b0262f193244dca6513e739149c54c31ce5115add8e95f42ba57b02ae645fbdc934e187c09bed8eec04091bb5b7d2a9698c8cce70fc92224f2172c9c69c08d5b3bd22245d976df2022cbcb40dadda1f84b5957d7f484d5172bce76ae25739eb260810e0aefdc544e1ec3c404aeeedadd31cbb8f292c187543f979a02476ad5789bd3d58b524600eaf207bfb7cf294ce96f6663bd06d8826fdecd053c9ac7c509b93b717375dce732890f53a54dcce12baead681e2172edc1dfade2bf8d8665cd05a3fe8e8eb061c7c78eab7823a960aee44d5f23b4eff2279865ba82873a2f4b4229c29ffb32a3745306a17730cb6db0cecd67a8a0b8daf9db1cc26d0601676090cb90a215a098af91baedd6aeacb06d818f8b4a820e16bcb525686fc3ad51c44c5adf840629ed8a25ea3a9a0cf9e89825e679045b795c218d1a749bce0d5d6e85955fdf68ee79939126020ff087e1d3b213ebd5687b2fb4a4792358bfef7d635f355e2a8904943a294b1da2fe6f55d38e02b35c40150f84dd6366ac2eb387607bc97e7ff212e3b79bbd136ed6db07dcb2fa6bcc551a8a82779ea30be920ba541786c50dcdd05713c6f0aa12ed5f72b691cc2b8ea4616b990c4ec479177c313872d717b9e0defdde8ff5de0c49733a5dc3d203ae73084c71813cc1f8ae7c8939a7f3fbda403de807d3e943b17479bf6e35ec6f2dbfbf3b34fa6cffe8851d551514b471d784a3c598c2405b844289c393d9d06d3e2016e7da32b4f1105bbaffbc00d114864a30a54946ecfab7c4ca6577c1b97a49834ac936ea3aa29d1376d371883660e3c328d991df71e1a64bdfd06d04b7741e68fa7211e631b75f8ba1149711f10c8da5861fbac6b7b83da4732733f5227c6b42d2ff478d5f7cc61a469c1dff06a30ad2191ea595872d66c7dee488329aa705d2f863dc2980a97435b62f0ae136b3f08d97f874bfe3a7ea00f89243de63dd1331b566d016355bee3b5e65b03fff18ed416740c1f7896550210f9016758a36db1aebc9babc9893486eb2a29bb3b591a7ea0e000e0c4079f931aee5c411b560e22cbd605c39f32a3a201667c08fa784e0d4a5138faefff6ad7ce8ce011a94af8fd29fbf0b2dc59884bdadddb128608b359bf11c2afe4389ca008b200bcc107bae76a70985a96f0c310317accf5ceabffb34bc24be45bc5943af67ed181ee648385bd30b4e11f4afbdd0e804588a824d87b02d5dd7d4298c8fc7d0e80b260d6424b1440d2e6f04e43bbe00f5ab7d6b3a911139124e70d5f63dbe445c9f909ad404506ff87288eef5eef5212f59f5843e6fb939895b7deabe404a2ed4f1daa8d0bd8cc0dedc6c7916bca19819936b1611128f8593c59ffc12aabd3f88182194c8fbbb1aa612fd8096e8bea074db94fd039c5b54309b2391f178d5880d1bd117bec3511c2f384e28b35278c2bb2eb903328b10d3c2e2f99f75531542b85491b636206e2c05cf016ebbd93c8f8161ac9de704e3dbb1d59dfcce715c2c230d3754dcfb5d94aa0a3b57752d5c261c816db545f06d0a83b67363be80bcbe468b7937116b22f29cf6ee99229ad021d0554d48e83dcdacac48e689d4a6d16a63eabb9d1e6b5c61c7914e3460d80a3f71076eaaeaab9cfe36ce701d62554efbf569f61c9f4240c264b85e134cd75cf88e2f285a88559ef4640b2384b307d07f2a992b74aadf68413ffdd1a3ac5b527b7703ff55e5dfd1af2a639163526d8d003789cf94b9e5bfd307d62e5fc12cc1a3f00d57492f773c01358726b235e0d696ebd47a91ee03c180cd6e564cf011ac333ff717030125485dfb3b2475ada7a7fa90df073853e238647c5157e6befbd15995a8a4d2bb8b26bf3be604f95370e36ea5f2f4a953d08dff51c34e5cb390fb77d788694c41748783089d8090224068f0ce211296728bf35de8fd3dc8d4ae22b3efb0aa8656cb61925ebb68535b5db6fcb0558ba5a2472429c872863ad9b4dec2f4c9a63639fa786df2c6961002838a4d20eb29ad40b537af0b1082dcb717ce81b41b8af0e8d7d3862bf89ebf45b7b656d569fc8942e170e7b90f833de395bf5ea5fa598cfe4d0e45dfea7b85432bdcf9c57d0abd0f6bd2779e72263876ec9c0c536e3e1cd4fbb43894a8ae3102a9e36fae52e7ebc10a49300543137407ca5e518d641f32e75c95f3c51dc70e3d78c3340bf8a51a502da0a3a7fc8ac69f402be9c67a3b5fac09053ea404d271b7ec79a2f9f177cc6e2195c6fb7ed1e3b70416ace5bc2e1c1aa09b404a769b0850ce49054d3bf288da7743d07f45277d1af9334a4a6620616223495c3e3ceea67f4debf03a754077d9909912738478bbd50de68b1e6b52d77e5215dc580c5fcbe40103338a23fad4596704ceb06958e02020075e6483631ad2b50bf29c48f38d1880fd21c956425c9f8dd49aba348dd05d797fea7001c88b92594354db488c348d921c30791e715dc3b19a420aa7eb8f9173867a17a63445cbbce325b0592a77737ca088532fbc919e0b8b5bcbd1d1d9effd9d28e7f8b403bf130d4938ab370525be1584dfc13d269ee7b025fc842ce3813f9160a666847de19ed150fee8f8d5a643c1b0ad4b4ab27d7760a3631888ad65fbb38abc5bdf3f2f3a2e08cfc0869f3729af2f4a61efad96f8ee2af3d45937bb055c6d1baef314b875b784b73f4d5fdf5717ed2396009ddf3e6097228dbcd5acbda1c149ceeab237132105739c547906026840602d68a730617f429707855609d4bf124bc8a22404d2f8840e58b065454eb01ccef97fc0e5659c17af0d817936ec4484c50d24db9f4848059fd6896089a0659c2860e1aefe5c3d6cb45e8ee2dec5857f896b875027b2ce5d869547b6708adf7311b1ca1e2ab17ca78ec834190febe951041230faecff812ba593ad6c1d1120981c2c818a3dce622fbfd08eb85aa216be38bab8664cd3e70d531a8876d281f7d9830f6a5891669145507cae3d15bdae198e5c84b47abf184091528fdf74a214f28ae24d475fe0262cc288ff5eb18efb94d66e40134764268d1e42652df8a63290e967cef0c9c95743157751262993102e1bd5d6f449e86ea35dae2e33ba4fc3f2d3e5f23cc477411ec07540af551b9ee02bee27f8a777e4c460c587e81cb53c9ca3af858e6744d342f78360c219ed73325fb9fae876ab00fcc093c6eeab94297e428fb2ba7d4a0719878561f739858981ed54eb58ecd14eef85b682c50910fb4024362fb1a8676b501aad84e26577cbffc6cc102f2314064c18843b78aaaea5635970d3a26de624ef1ffacb039c02d03ec60f8fb3e395881f1d07be06f32f40c652234305364983738ccd9964d4010b7ac6706d0088cdeef4578340d76bcee99849b89765f37ccf23a09fd19aef762c704136cfb0281e14b3e6ce780b8b728b73378d6f775db082c81b166dc4e62659370a3bda4db1e152625d391c2d8807d2846f4c787811a52ef7a46bfe96b18d91b24baeb155d1caf8e46b183dd7582a52fecfca8ef02b5e07d139bf22c30373e5ac7ba8b289f81388285ec999ef438d019d9d864e69d5f4e6fe01df174877e3794375426b4d93c26e112025248432c77d90e1a00987684cd618446e364d4621567d05e99b1a045b1c414975ff306b282227cde0db03d8eb9db48620192b8a5bf68bc3d3d464fe69b632075a3f80ee02986257a213d5b7716d5188e1e7cd8989f1c2c0b18216cc0afc094a61d48e714dad33bee3ae97501cd14bf88821ad18ab8eecd4121e87c981e97650000bba1b669625ad2fb48722fcff5d9cc37c1a0cf3bbb6cc64f78f9134fb810761c89b04d4cf55c8aa7af163068014f8cc986679ae47ba706db6a4a88d2327c923848743a896a03dfb86d23bd48d8f0fb96fbe7ad4fb405a878090e98d13adbc7ed4a7c0dac7b177f6c6c23fe1c3b58f4a933f0a465e117c68eb50d78c922c6345bdddcc3242616cb5a23b23eba05ae413e193044003df9399d659e06c9dfd0b1752f631391e3f2ea7e134d24300a5cdf72d61295648d07f2d434981d27e0cfb5897a4d06f8d3a1d0582a13ed84f4de03ed4f246e5f21fe6c6a0738d2aaa59750b00c955d40b5917ae6be80c46ee28b1f921cee5bb30976d9749d2d3ccd299bf1587c835e4c4e0714aa5c864927ecad32811851926853b2f8b370919ed3ba7947eca490d773afa4a6e60a5b7ebfd29716475abf05778348c7f247506a5640bba1d68f922b46031c1951bd1499fbb3da57e87a4bbd5273b4eb3908a0e427bfe46fbcebe4ec7b426fa4996ffedc9e6d96f30059b15e592beb26b9d6877821938268b5730ddc76e69c7b8224e003d516d2f6d0a6e9c78a25e58c11f2182e17003e3c6f1d89f9b6375859f20471031fcb8604a24bfef0a33b1e24c4f6f0a152f66065dee87b2ff64042d8f308f2b25c6e48dc4f89fe59bf82e37e50b133ebf191d0e19cc97d3f9df06ded0249c22387f75f18d2c6bdb4ffe842ba238bd907df3c0ebeb9b0e2ede504a07d8cb17976e013112ff6ee011d1a363fc2d5d030d77be2ad90bd5befb9f711cb5be093be65f84f83d084ca970d8c73f8c4005d43a4c4b40501a254ed1455fda57301db3f06d37c5b841b0f76560e20aa6b97aa1ff431b56ae0e8c189538988772185c1e2bb52f04eec4c3d356a721becb0869f48173923eb9952aee3428d78748add076a04cad8ef2fd8855c153591b151396caff1df652aa29da2cced1191e9ea79576bc55a656c60c481f0a8e1610ab13374c5cdf74d4f6f49e441b88a78af57587302c1d6ff6dafee61b15b50dc3688324ba0c1e0375e3d158430e2bf1ae63dfb457df8361b24b4015e8f055ac403bf3f08dcb37eb4f0a02386a94b637110308858aa2a61af5aa18e9fdbb72bcff0a63a5430e7b1bfed68769c9a5ffe50e5d2c00704ea7a13c243e39ede574ba83618ec1d354b3d0549f876c03bf329e62a535e99a1bd39236f223ff420a5ce8e0463eb0f127b2c52e320e347e35b08b79419024312dad323548a42680fb4cd430156dd5946046ea3d3c18715ed5a7cd82b3c1fcba2c78f0932b597c485ca3581df20eb52f4b793205d9b59fd1ea67c48df0afe3983984807a181c16019130f7b16ada2158ba1ab919e4754876dc8c5d5f0fd56b2ab4b484caaffc9f4c892a1ebb22d35179e2405e97f389e2aa0fe17aecf150d044839a9ec03dee821ddd5d94e46bebb3aab90e6d8b824468d7563b829d8361bc474b942e2f2df1901452fdacdebf0628322569bfe04eb6a1a31b8aa10462d80107dd61c2824577f5ac95f132d1c77aada3b7a55289a950be0ae4558ce03366f4161d7cc82efa5b7f0d482dba402a952e2b4c9ea46c43c9fe30e28fd886d674c425547fd303c2c22c5f4ea170dc5f87c5984c00a30797e0e668e48ba75010c2efd2697d677e621b455037541ab8115deca1a857199b579f9f6318d3f9793470419da3a56fe588174162b2811fa49b041562c69b142f882d2ab4c31680fdcde1caaddc4e79148a3b78edbad7011809f639332a82d31aaf7192cce52afaf7b65b5e218071b64717a4e6767bb2c31c4a9f9a616f3903b73d00e27f4fa9c355ce7f43f90e60bcea65c02bda17b22dcd649fe79ce50ebe719d82fa79acdda333616929544219a8a78782df63877e8767a68f957e07d4d9bf848cd16ce656f7efdb3b11a952cfcc56d0e7c10038702d7eeab2c58bb55e45306bfe0fb35b20168a00873ed55b17a7a3b711328c539c6053544fa29dd7d7e2463f11890472876ae05c0e9b0f8359cdd397fcba3025aaacec93dcbd7332ffe47081986b662f6abf968931926956eae34ac9d3a6ef87f0e467c9e60e4518618d81d1302282a31d76e9fb484a15ec6a2002259fa5dd69f1d9650e4dde31d3d90d9f13076dea0f287395b187c9bb0e377fe795ad741dd653593091e413c96bf22ddb441b2b4200028bcccceeb87d60397eae37fd839b257078de5c3b29f3dc1a23701d1d42c5b64fa6d79757d73714f081dc6f137e93e3345a8ed38772cd9826f844e9c6104e100b78fa1b48da0fc39c8ddd5ef2391db4703ad75fe1d1be6d4184373105bd4bdfde940d2a94c4bf55dfc339e853aae04e10a1545c7cd63b79e737c2ac10b26d8a52fd37160b6a22d123dfbb30cda08809430f136b6a5c75b57a3a33e346e8bd3f8a4af05dd6c755cd5c3a247e03cb84f21da5057c7103a019b482ace5c6d904f6b2f93333c8b04cc2d5b891a6bc3c9896c0dd7eb63a38b37d1e3cc5a92da7c8dc5d8d2555d5104600f935436725c0d47c6f59e880741c75dc899d85b1faa39d5112b8e0248fafde844f96b2f6a91c3d08cda0aa7e48116c41adf4ba8300fbe869d5eec45f4a0089662015ef291d0f5148bb709d6294f1ae4728cd12f2d73cdf9b3b6232d72786f5b6cb716203da8e791ad6aba63cff266ba474ba0540bbf4f476895e26980fe840c565793305d577adbc626ce87e32a60cfebdf0bc2f9f87c6cf443a1156531b2b5fe53b7fbce2eb45fe2374d412cccd914721e58dd3fce3a8780e13139078e612869693cd0aea28a233d764a0881087ffb6173fe9a59db6bf1c6118e76ede7fe866641ce38043e60bc057e1a028ceb9f294b77560bccc9295f29f8639280249c2e841200f036e316bca675b48952b458b48ec465505a2f18be9a4bfe96fc512091706186e85d22ef7e7811bf8beb4c28faa9dd123c5caf75f90d864730ca3e2e5deedc4099197efd3a1440505bca283597ef7900f1a72774e8b9d01b27921a4c337d473a8e64f8a8bb1d2650f6254b22b99194cb01bcfe998230388e019bca2f646aa438bb5a90d72dccea1fa883516c3f379317c5aec9f782b3273ea4c41d9df37497f83c46e7b56fb93992a89d6536926194fe0d2d391f9bfdc34436d5b231b7866f51d8f666302422a58f2080ff6c5507293f8d99d9404d59d0cb7aeb0aba437315ac096399cab480e8c807dc57dae715b19126c75d8c0478a2e3213c8849799c402cf9ff37664738513700636e49881716cb69f08295c68d3bd074b095e01d8d0c3184d1699b53c3bf95248013e681654d3378f35d7257f750478955940f3fccc49801a13877e75137b83f04feb31f49970e54eb1df350367b209bb167525a0d6cba1bc578b53a2a90481317e9585e6dbad33f06d4b1f08522c436cc482c4f11ec5afba76cb8f3dcf7fbfb10f3449b01fb61891e0bf8f3ff51cb414700df943e7046f5d8a9bba10edb73074cd754dd3dad3dd5ac2f982b556b1b5cf57c6be68dda1077a1074108bd8674ac41c472052d68798ef7d7060ea049fc7e1634410f7d5550f43278150352a0c83daa046ba23bba16411df42938b95083133aed7863c949508f35adab912362b0d4cbedc35988139f91a13afea169a0c98934b29fb8c35c947ac2c04776a0e33b4d17b8651a6c4ccd2913f519020051d6d117cdaf8d65703c59ab3589baa87eae877cb3f3b436fb506338a7cc10d77770a1563bd4d8fd788aa6c11169d12e6d7613b3c33a463a625af99b5ffc48401c665b5759ff5059b5045bd28fbfb145aaf25d627876a188c0a90f8bc071fa68c4e2f2231676e8ed32de74bf47006e25ccbcee8fa1326c341d8faac91666251e55a2fa896ad63ac9d7c2a8a3e82344aa75edddc12ac75a3e94911420885bcb12dfff7a32eae01effcd4358a78737fb3f4c8636790d0914d5083ec334225265e81ebb69b4be69813299cf1fb8ac93f622272c919fa44175e53cdc7ffeb356be578c5caa26fd0c67e5bdbed4ef894b5857b12e7edd9002c56e0882d4b6912f00478c65681014de6b2115ec7721354e6804dfb35356fb8cd1c6c4deeb101d48fea4906bab91400856ad346b2b9f7754563c371b48468f49dbf81bfa8f2305b0ff2bb5de751ccfba881fe0d57dd8ae6024b30a11460e9aa17e7097144aa6135af9103bc36ca0be47285d0c92578d3d9d3429d2f40bb840101bb30e512dc7ae0e7693b54747bfac99724f501b3ea099c0bd57f410fccb20f1d8bd32c4dbd481bdc8d56fc649ca32d36448f6eb99010e4bae76661f4e9138998cadfe231af7e154777e133b7786ac82d95be003d55fb7af0590359d36f6d567f5db804971447c795729ac7894b5fdb4cc7d603636b607531c054375c4f7b1c0cf2193ac33405e762f1c09d3e8d6992c44f1c37aab7d405a2a865c132fc6a2758473d65ff748977123fb042ee52225c2c2032ae096a840fbcc011c2fafa94f264d59f353f9fcaed533f14a342f150cec639e38261320d0dc28d0bd0ae7b324e832df3348690c38c2440bfb2aa8d8e1f4d13c3b82dc09b3c12bbae0b4a27acb8aedb22fc6a280d54125912d3783d75155a387bf1725697e8c80c53fb9ab7503acca395063e848a267b02e61623b540be90aae4170d0f96f28be5779ba083c90fce1c28ab645e34ce57d194f0eb1cf2e941e23e025ca84a2ebbf6a0209a64b689691006ffdb20bd26ff3d6ceea3537552f1dad614c9d111c10e4440c7ca9776aeb275ab63d933eb1770b4a2464a2a7ec9a43f0783196e5ea1c128c0cb1cb3fd9910c2fdb1f37e20a4183f51044c4b978bb169b8d8db5cf1fecd379b62d779f9bcccecd21c395f46b8eef4ea2d7997b55605801694b0917ec390b9840bb3c9e89cc0e3787decab2c93d57dc03aef6b37d921528a0c0ce211e373d7f16f4a8b7e6a4805148d71c777b556d6c6f1e094373c60f7de07be2fe0ec473d3d9ec24bfce65e247f2551547e7ab7b32e89eef76c0291d6c926a64f83ff37bd27cbfaa5a17cbbb4e8de5e45a0e424a0a14654c39fa1542505cc321e70c8ce2185ad7d5d1f8fbcfa127be563f5c1ce776e9b185ac679f91b1ad3c3d7a7212edad565ca7204dc38232adfe7a589a96af45cf43935bcb43654f4e66a01357b99511919d052823644ec9c7c2208a3aa1584fc6d7d552dfe1dc991b558cba5250526b38ad3a74ea90e5262226367a3f63764eb0e9f89b1614578dc942cbe9f8ce0022156c5674679b3163c8111e603a94e25de7ccb57be26d35d0cbc59083f8ddd44dfb209ddb1324eaa05be93d78bf205634d2b00931f3cbd1311b1ef943182739d99d59e903ffc50ce5f180959b1adf50adcf6ce90614f4ddd035223dd5c3c94859c39ea07b966fbe6548252325a5441b2722631cb2f82e6f1927f65262b1a6725302bd84f7e001ba982c8c3edc9f0ae15cada56b300687155882fdbb157d8e8c139d779f0c4ee379e3761104783a926c1c004f9f0113d56caaabff7b09af11f282360811cf3ccd541832f8205769cadc093c60f2fb024574b36ad56fdadb5cb08e84814bee7e41af1141d748ba835bbca9336203e638d21991cc2756982be563f9d3ca0dad0a5cfe924fcdf86a2109b415c49bdf01d196a5745bf71b075f4bfbf02bf7c2bf23a6d2379c0acc1032728ea1c14f72619cdaec6b6905c3c152f6a7d212bf579344288c980097413b2e0755e7f1216c2332e983744d5887d861aca86289b96f33f03a91faf6c93e6955ff818e17655f4dae88b009921110c9dbc6ee360c4dcbba1280897fac242a4c137cf5ac0c00c281c00733e444e54762581d8545c1c8ab841a73355e082d14668d1aaaa8da6065808379ba4cc794e41a2d9c65a2786b39a6dacdf58a3b40d8166fc56795b9bc7507776f8916fda9559aaa7deb498801fec67f3baa3836fd655c0da44818e266dbb1ec96ea26973011cc5469976bd38f4e2059581864fb975c0a548a62e78a4f38732f6d50c4a0b3ce25f226a7739c594dac322683bd5b3ac27a5ce5ac442286713492eab14fe2963b1ffe706858a6a7e3ca9412174ec099225fc5cf65816e9501161b9a8b195d9ae1f4abeba6609b73e55bfd6e27c23fb15d3e61416808470c13e776d1157a51896472442aee3eabbd899e69000d4d33808f8ac9e4567da892c65ceaeb11a7fbb3684859b6773a2f1f136bd2f699e6fd803a39c4470473295b89ba4bf807b2d1c91d0bec24f02cd8815babd05c2b49410830b865a840baf5aa7b97ff36df8a92e67a7f91a8348669857cac1373ad5d3a85e4126a8b80beef098d904a5324690bfc81f0ea93dfbf0769975eb96fd4c230f36bdd3bf8c7dee86b9c8e4dd8fd9da18238eed2fdfbd99b4c3c056d8622bc4697622255acb38e3faf25efc09721f269f7f4c011047d5647d9dcd1f77f4cd9339ef210be62cc09f9668abecdfc0fb81a6ddf4c3cb3eed83dc9e9d0b3a6096a6a398038943a95b89e79a5a0024412e8d966eb28d7681b43682a4cd7db99d5790400bec05f3925e6b2cd2618f354c2f5846a946c60dcd1cb5be332d3998a15a54a601b7fbd5802899737bf337083ec3063e41b7a4bd048534d6180e9b07804f8df193720f59136ff361018b8c7676b204a7e518f693af3e12f18402fc5dbfdb3e143364e4b46817a4a7fd320d00c18fcf8e5dfad93f6e0a59330c9305e3d7b8951ba3801a68d46963726d4cb6ebcada05f3d745441a1508f475fe54d0b2426cdc4625d9ece7785e16e6d51181b15a9e2f3d7424021a91fb63fad6fd1b26e163fb84b469e8ccf5decaf7fde54e93feadd1eadf1f4026d901e7515924255751f8fd430093de5d208e4763b71f5ec481eba2d1fbf06bbbceb99681ab8bb06bdb515cc455b6ccb2b53ad84af8f0f8d08a1cbfec380562739b7f8850349941fb95ee405aa5b0983877a774f25b64fb6403a80dec966e6b48882bf8fe04a8b3ee4da39c185b146f6e0a04ed17422f2bca8e11ee3906803c6f931d470d200841e8b731ce5dbe73ddfc3472ade666d3b70e0ae1211a73c0ec5a6a355dbc4e8bd7b2cd86af446514137f109972f4243ff394c1e6d9145df913e38cd89a680a84d6d92786f1db5edf792e04caff63e54007c4256f7a5e7557fbb9227da930c0c4c04642ea0c99dbe992bc481f884cb151064c19aeb43e91754e9808d5c7ed0da102a7cc7f49bf37ee5f701b230dbe94c34698314a55b6d993e52363f05f8117050b1d9182640bf6d15bbf920e142925e148d81b1ae4e856f991198a9b90a86fa5560b1b50e42562627893e3ffb1392c8bdbd4bfbe217cf701718f1e5ab791ac27c8cb6362eccdd65873111edd6265226cce5eea1626387c8a7880d20a2b367895f1d067bae31c53cafa35a8db3f6e385af34fd50823b44318944658f6ef9c39892110c5529172a56c6e1c3e43d5c7db70e05e6faf77719c37342f33db18c00a5fbf69a6cf486301cc51691f4998854052e5e51b51d3bab77ef7269a891528f63a1a0e5c46a598f4ae8ce57e0f9e2a8f8b81fe1638d4ddf1de31849c2d5cede064c630f483c83d89a4b323b91768d98545473a164bb4cd3c4d460810e454e4556ed0453222976717b1ade92bbb0c7c94c4773ebdb39bd16135fc04f21a215e433081701db090b481e2412184560ac4764cbeb3c869005fc567de7f19c43ec7cb0ab5ac54199262597a8aadf7135dd131bde17756614ebdbf65b4f231fb86f0c6048115a2d4d203648a788ad43ab50b042e19380cf95f1b79ccda614a1b3881d28d9d4618f92ba14767c5a737011b798ea6f495f30c44a690f1736f4d4f1caad95b63d8c8720883ab2a9933917ab5c48b352d90810b73218ddf146b2293becaea35c3dde24fbfdea79845dabe0b485038ad576747d6e08e5e2facb67e060efa8191238928d04e77b12fad249b328134016d9269caef63767ebe5db3247e06f2e539d759582740fd0f9e8df038a985cef9db38b619f7928c1db7139d1580aebbf5b602c750f0c79a7f0f44ef9198565af3135a2fc66f054a88b50c255675577fc7543e91ae56f31d1c448bcf35e106323a32fe4a711a5719d2ecf631ce443392e7d405f90d8f13eaa7609938a98683a995a247643eeda6237f5055542125592fc2a29afa7a4edc3515a73f14c47fae0553de2650c70a080e47a59c799a04c159feae5436eecf6f11da66766e8d7289588d2a0538a6358e31855a4ec2a954b1056fb2b3b7be6becd72b76c796d775d498c004957ce06611d31af8ef71cb438d592da32a591ed7944232de45918f25f4a3f16ea5b1a9c8636deec1de0c43b478d6f3e609949bd5460b95204120c30214a7ea96f728182d3da85174baf460c3a9e8610c35a3f415db4f34baf3d0b55b7e6408a3c2252e37c3ebcb15724130bca2fd5b2ba4da1e1a7c50d41bd4e20973f684965149cc584779355531aa1362583f0cf4c25c182c0985edf78749e3292c1a57a6bdeb1f4f46066c6df4865f47a83f52a83c8eb8fea2a44e2f11e1640f21322669ae357f52b71b0767b9d7c85885f84ebc4b69ccab0cea8348cbe0157fcb5a14b3026160ab69fc2a5e7ffc3f06d1136be3cb9b14ca0f48885603ebbc259d666a7a6151a91d21c1b117e00382b3e7f91d8488fa6ea237d0c2c7f8f177eca6aac1af8adeb4212debf8d67bded7f14cec159316bd6b13056840f100ae7cec356b28a561866fced2ff25394a096edb41edc2512e888b9445287f7a4499b63a54a0d9c280ce72a1d0df25c818946ac1b66d478d47bcc2a85e740f922cb859acb1b56e5ed63fa4e97251a873a38f7cd5b9d12a752c60197c59a15385d5c1fc3125abf9669b676aaf7c0c931349b25a614e39c4099c1779d955fc2903d0ee9d9f95f3b6324194fbf3c4358ce1bc9097f3a97faaaa7c00eb35e057e897c1e487e87d1632159e590ad00e80c6b82b8b39dac8716df9a3c90e1cc227a9e109634174358e060cf9fd865805a66cc6f99c3cd046a894631433eb36c90c460702e0e0c0ea2dcf8061770c63b12180ecae1140c7c03a2e92d244e8460e59f635ffdebde596db41bc0770818593a34ce39733a860a1b7fcf213bbb02341ea3d94ecc50bf81c5ef9501fe1f5c662ca4eba2a250de3c345bdbf39597b791357e429e73a71e5f789f15929e44ad3b5c0cd45698227914fbb1e4d97818f908d2c9546d1b5a53c30e97e9944ef67063f7122bbf1cddb934a5f7d08fc801ea4fbfd972cca053d6c905babf6b349576b997a81ad74c0f1730eb2d34e526a876d7f461aa7f86b603bde7398d323fd18954bde31385e25699e2790b3e9e99cf3c01ca368fe70e2641a735c56a06ba6d6d8c7deec45afcf9fed679b2d9a58a3daba626fd00af624ab7ca7d46c419bdda282426132d5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"731e88edaffa707c0029a6b34fd23319"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
